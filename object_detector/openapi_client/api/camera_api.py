# coding: utf-8

"""
    Djangolang

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictInt, StrictStr
from typing import Any, List, Optional
from typing_extensions import Annotated
from openapi_client.models.camera import Camera
from openapi_client.models.get_cameras200_response import GetCameras200Response

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class CameraApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def delete_camera(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """delete_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_camera_serialize(
            primary_key=primary_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_camera_with_http_info(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """delete_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_camera_serialize(
            primary_key=primary_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_camera_without_preload_content(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_camera_serialize(
            primary_key=primary_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_camera_serialize(
        self,
        primary_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if primary_key is not None:
            _path_params['primaryKey'] = primary_key
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/cameras/{primaryKey}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_camera(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCameras200Response:
        """get_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_camera_serialize(
            primary_key=primary_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_camera_with_http_info(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCameras200Response]:
        """get_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_camera_serialize(
            primary_key=primary_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_camera_without_preload_content(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_camera_serialize(
            primary_key=primary_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_camera_serialize(
        self,
        primary_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if primary_key is not None:
            _path_params['primaryKey'] = primary_key
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/cameras/{primaryKey}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_cameras(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="SQL LIMIT operator")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="SQL OFFSET operator")] = None,
        id__eq: Annotated[Optional[StrictStr], Field(description="SQL = operator")] = None,
        id__ne: Annotated[Optional[StrictStr], Field(description="SQL != operator")] = None,
        id__gt: Annotated[Optional[StrictStr], Field(description="SQL > operator, may not work with all column types")] = None,
        id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= operator, may not work with all column types")] = None,
        id__lt: Annotated[Optional[StrictStr], Field(description="SQL < operator, may not work with all column types")] = None,
        id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= operator, may not work with all column types")] = None,
        id__in: Annotated[Optional[StrictStr], Field(description="SQL IN operator, permits comma-separated values")] = None,
        id__nin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        id__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        id__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        id__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        id__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        created_at__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        created_at__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        created_at__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        created_at__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        created_at__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        created_at__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        created_at__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        created_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        created_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        updated_at__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        updated_at__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        updated_at__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        updated_at__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        updated_at__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        updated_at__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        updated_at__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        updated_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        updated_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        deleted_at__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        deleted_at__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        deleted_at__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        deleted_at__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        deleted_at__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        deleted_at__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        deleted_at__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        deleted_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        deleted_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        name__eq: Annotated[Optional[StrictStr], Field(description="SQL = operator")] = None,
        name__ne: Annotated[Optional[StrictStr], Field(description="SQL != operator")] = None,
        name__gt: Annotated[Optional[StrictStr], Field(description="SQL > operator, may not work with all column types")] = None,
        name__gte: Annotated[Optional[StrictStr], Field(description="SQL >= operator, may not work with all column types")] = None,
        name__lt: Annotated[Optional[StrictStr], Field(description="SQL < operator, may not work with all column types")] = None,
        name__lte: Annotated[Optional[StrictStr], Field(description="SQL <= operator, may not work with all column types")] = None,
        name__in: Annotated[Optional[StrictStr], Field(description="SQL IN operator, permits comma-separated values")] = None,
        name__nin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        name__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        name__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        name__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        name__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        name__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        name__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__eq: Annotated[Optional[StrictStr], Field(description="SQL = operator")] = None,
        stream_url__ne: Annotated[Optional[StrictStr], Field(description="SQL != operator")] = None,
        stream_url__gt: Annotated[Optional[StrictStr], Field(description="SQL > operator, may not work with all column types")] = None,
        stream_url__gte: Annotated[Optional[StrictStr], Field(description="SQL >= operator, may not work with all column types")] = None,
        stream_url__lt: Annotated[Optional[StrictStr], Field(description="SQL < operator, may not work with all column types")] = None,
        stream_url__lte: Annotated[Optional[StrictStr], Field(description="SQL <= operator, may not work with all column types")] = None,
        stream_url__in: Annotated[Optional[StrictStr], Field(description="SQL IN operator, permits comma-separated values")] = None,
        stream_url__nin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        stream_url__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        stream_url__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        last_seen__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        last_seen__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        last_seen__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        last_seen__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        last_seen__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        last_seen__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        last_seen__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        last_seen__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        last_seen__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCameras200Response:
        """get_cameras


        :param limit: SQL LIMIT operator
        :type limit: int
        :param offset: SQL OFFSET operator
        :type offset: int
        :param id__eq: SQL = operator
        :type id__eq: str
        :param id__ne: SQL != operator
        :type id__ne: str
        :param id__gt: SQL > operator, may not work with all column types
        :type id__gt: str
        :param id__gte: SQL >= operator, may not work with all column types
        :type id__gte: str
        :param id__lt: SQL < operator, may not work with all column types
        :type id__lt: str
        :param id__lte: SQL <= operator, may not work with all column types
        :type id__lte: str
        :param id__in: SQL IN operator, permits comma-separated values
        :type id__in: str
        :param id__nin: SQL NOT IN operator, permits comma-separated values
        :type id__nin: str
        :param id__notin: SQL NOT IN operator, permits comma-separated values
        :type id__notin: str
        :param id__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type id__isnull: str
        :param id__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type id__nisnull: str
        :param id__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type id__isnotnull: str
        :param id__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__l: str
        :param id__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__like: str
        :param id__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nl: str
        :param id__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nlike: str
        :param id__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__notlike: str
        :param id__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__il: str
        :param id__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__ilike: str
        :param id__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nil: str
        :param id__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nilike: str
        :param id__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__notilike: str
        :param id__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type id__desc: str
        :param id__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type id__asc: str
        :param created_at__eq: SQL = operator
        :type created_at__eq: datetime
        :param created_at__ne: SQL != operator
        :type created_at__ne: datetime
        :param created_at__gt: SQL > operator, may not work with all column types
        :type created_at__gt: datetime
        :param created_at__gte: SQL >= operator, may not work with all column types
        :type created_at__gte: datetime
        :param created_at__lt: SQL < operator, may not work with all column types
        :type created_at__lt: datetime
        :param created_at__lte: SQL <= operator, may not work with all column types
        :type created_at__lte: datetime
        :param created_at__in: SQL IN operator, permits comma-separated values
        :type created_at__in: datetime
        :param created_at__nin: SQL NOT IN operator, permits comma-separated values
        :type created_at__nin: datetime
        :param created_at__notin: SQL NOT IN operator, permits comma-separated values
        :type created_at__notin: datetime
        :param created_at__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type created_at__isnull: str
        :param created_at__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type created_at__nisnull: str
        :param created_at__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type created_at__isnotnull: str
        :param created_at__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__l: str
        :param created_at__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__like: str
        :param created_at__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nl: str
        :param created_at__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nlike: str
        :param created_at__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__notlike: str
        :param created_at__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__il: str
        :param created_at__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__ilike: str
        :param created_at__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nil: str
        :param created_at__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nilike: str
        :param created_at__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__notilike: str
        :param created_at__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type created_at__desc: str
        :param created_at__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type created_at__asc: str
        :param updated_at__eq: SQL = operator
        :type updated_at__eq: datetime
        :param updated_at__ne: SQL != operator
        :type updated_at__ne: datetime
        :param updated_at__gt: SQL > operator, may not work with all column types
        :type updated_at__gt: datetime
        :param updated_at__gte: SQL >= operator, may not work with all column types
        :type updated_at__gte: datetime
        :param updated_at__lt: SQL < operator, may not work with all column types
        :type updated_at__lt: datetime
        :param updated_at__lte: SQL <= operator, may not work with all column types
        :type updated_at__lte: datetime
        :param updated_at__in: SQL IN operator, permits comma-separated values
        :type updated_at__in: datetime
        :param updated_at__nin: SQL NOT IN operator, permits comma-separated values
        :type updated_at__nin: datetime
        :param updated_at__notin: SQL NOT IN operator, permits comma-separated values
        :type updated_at__notin: datetime
        :param updated_at__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type updated_at__isnull: str
        :param updated_at__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type updated_at__nisnull: str
        :param updated_at__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type updated_at__isnotnull: str
        :param updated_at__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__l: str
        :param updated_at__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__like: str
        :param updated_at__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nl: str
        :param updated_at__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nlike: str
        :param updated_at__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__notlike: str
        :param updated_at__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__il: str
        :param updated_at__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__ilike: str
        :param updated_at__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nil: str
        :param updated_at__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nilike: str
        :param updated_at__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__notilike: str
        :param updated_at__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type updated_at__desc: str
        :param updated_at__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type updated_at__asc: str
        :param deleted_at__eq: SQL = operator
        :type deleted_at__eq: datetime
        :param deleted_at__ne: SQL != operator
        :type deleted_at__ne: datetime
        :param deleted_at__gt: SQL > operator, may not work with all column types
        :type deleted_at__gt: datetime
        :param deleted_at__gte: SQL >= operator, may not work with all column types
        :type deleted_at__gte: datetime
        :param deleted_at__lt: SQL < operator, may not work with all column types
        :type deleted_at__lt: datetime
        :param deleted_at__lte: SQL <= operator, may not work with all column types
        :type deleted_at__lte: datetime
        :param deleted_at__in: SQL IN operator, permits comma-separated values
        :type deleted_at__in: datetime
        :param deleted_at__nin: SQL NOT IN operator, permits comma-separated values
        :type deleted_at__nin: datetime
        :param deleted_at__notin: SQL NOT IN operator, permits comma-separated values
        :type deleted_at__notin: datetime
        :param deleted_at__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type deleted_at__isnull: str
        :param deleted_at__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type deleted_at__nisnull: str
        :param deleted_at__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type deleted_at__isnotnull: str
        :param deleted_at__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__l: str
        :param deleted_at__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__like: str
        :param deleted_at__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nl: str
        :param deleted_at__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nlike: str
        :param deleted_at__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__notlike: str
        :param deleted_at__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__il: str
        :param deleted_at__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__ilike: str
        :param deleted_at__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nil: str
        :param deleted_at__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nilike: str
        :param deleted_at__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__notilike: str
        :param deleted_at__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type deleted_at__desc: str
        :param deleted_at__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type deleted_at__asc: str
        :param name__eq: SQL = operator
        :type name__eq: str
        :param name__ne: SQL != operator
        :type name__ne: str
        :param name__gt: SQL > operator, may not work with all column types
        :type name__gt: str
        :param name__gte: SQL >= operator, may not work with all column types
        :type name__gte: str
        :param name__lt: SQL < operator, may not work with all column types
        :type name__lt: str
        :param name__lte: SQL <= operator, may not work with all column types
        :type name__lte: str
        :param name__in: SQL IN operator, permits comma-separated values
        :type name__in: str
        :param name__nin: SQL NOT IN operator, permits comma-separated values
        :type name__nin: str
        :param name__notin: SQL NOT IN operator, permits comma-separated values
        :type name__notin: str
        :param name__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type name__isnull: str
        :param name__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type name__nisnull: str
        :param name__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type name__isnotnull: str
        :param name__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__l: str
        :param name__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__like: str
        :param name__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nl: str
        :param name__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nlike: str
        :param name__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__notlike: str
        :param name__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__il: str
        :param name__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__ilike: str
        :param name__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nil: str
        :param name__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nilike: str
        :param name__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__notilike: str
        :param name__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type name__desc: str
        :param name__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type name__asc: str
        :param stream_url__eq: SQL = operator
        :type stream_url__eq: str
        :param stream_url__ne: SQL != operator
        :type stream_url__ne: str
        :param stream_url__gt: SQL > operator, may not work with all column types
        :type stream_url__gt: str
        :param stream_url__gte: SQL >= operator, may not work with all column types
        :type stream_url__gte: str
        :param stream_url__lt: SQL < operator, may not work with all column types
        :type stream_url__lt: str
        :param stream_url__lte: SQL <= operator, may not work with all column types
        :type stream_url__lte: str
        :param stream_url__in: SQL IN operator, permits comma-separated values
        :type stream_url__in: str
        :param stream_url__nin: SQL NOT IN operator, permits comma-separated values
        :type stream_url__nin: str
        :param stream_url__notin: SQL NOT IN operator, permits comma-separated values
        :type stream_url__notin: str
        :param stream_url__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type stream_url__isnull: str
        :param stream_url__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type stream_url__nisnull: str
        :param stream_url__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type stream_url__isnotnull: str
        :param stream_url__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__l: str
        :param stream_url__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__like: str
        :param stream_url__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nl: str
        :param stream_url__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nlike: str
        :param stream_url__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__notlike: str
        :param stream_url__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__il: str
        :param stream_url__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__ilike: str
        :param stream_url__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nil: str
        :param stream_url__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nilike: str
        :param stream_url__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__notilike: str
        :param stream_url__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type stream_url__desc: str
        :param stream_url__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type stream_url__asc: str
        :param last_seen__eq: SQL = operator
        :type last_seen__eq: datetime
        :param last_seen__ne: SQL != operator
        :type last_seen__ne: datetime
        :param last_seen__gt: SQL > operator, may not work with all column types
        :type last_seen__gt: datetime
        :param last_seen__gte: SQL >= operator, may not work with all column types
        :type last_seen__gte: datetime
        :param last_seen__lt: SQL < operator, may not work with all column types
        :type last_seen__lt: datetime
        :param last_seen__lte: SQL <= operator, may not work with all column types
        :type last_seen__lte: datetime
        :param last_seen__in: SQL IN operator, permits comma-separated values
        :type last_seen__in: datetime
        :param last_seen__nin: SQL NOT IN operator, permits comma-separated values
        :type last_seen__nin: datetime
        :param last_seen__notin: SQL NOT IN operator, permits comma-separated values
        :type last_seen__notin: datetime
        :param last_seen__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type last_seen__isnull: str
        :param last_seen__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type last_seen__nisnull: str
        :param last_seen__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type last_seen__isnotnull: str
        :param last_seen__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__l: str
        :param last_seen__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__like: str
        :param last_seen__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nl: str
        :param last_seen__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nlike: str
        :param last_seen__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__notlike: str
        :param last_seen__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__il: str
        :param last_seen__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__ilike: str
        :param last_seen__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nil: str
        :param last_seen__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nilike: str
        :param last_seen__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__notilike: str
        :param last_seen__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type last_seen__desc: str
        :param last_seen__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type last_seen__asc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_cameras_serialize(
            limit=limit,
            offset=offset,
            id__eq=id__eq,
            id__ne=id__ne,
            id__gt=id__gt,
            id__gte=id__gte,
            id__lt=id__lt,
            id__lte=id__lte,
            id__in=id__in,
            id__nin=id__nin,
            id__notin=id__notin,
            id__isnull=id__isnull,
            id__nisnull=id__nisnull,
            id__isnotnull=id__isnotnull,
            id__l=id__l,
            id__like=id__like,
            id__nl=id__nl,
            id__nlike=id__nlike,
            id__notlike=id__notlike,
            id__il=id__il,
            id__ilike=id__ilike,
            id__nil=id__nil,
            id__nilike=id__nilike,
            id__notilike=id__notilike,
            id__desc=id__desc,
            id__asc=id__asc,
            created_at__eq=created_at__eq,
            created_at__ne=created_at__ne,
            created_at__gt=created_at__gt,
            created_at__gte=created_at__gte,
            created_at__lt=created_at__lt,
            created_at__lte=created_at__lte,
            created_at__in=created_at__in,
            created_at__nin=created_at__nin,
            created_at__notin=created_at__notin,
            created_at__isnull=created_at__isnull,
            created_at__nisnull=created_at__nisnull,
            created_at__isnotnull=created_at__isnotnull,
            created_at__l=created_at__l,
            created_at__like=created_at__like,
            created_at__nl=created_at__nl,
            created_at__nlike=created_at__nlike,
            created_at__notlike=created_at__notlike,
            created_at__il=created_at__il,
            created_at__ilike=created_at__ilike,
            created_at__nil=created_at__nil,
            created_at__nilike=created_at__nilike,
            created_at__notilike=created_at__notilike,
            created_at__desc=created_at__desc,
            created_at__asc=created_at__asc,
            updated_at__eq=updated_at__eq,
            updated_at__ne=updated_at__ne,
            updated_at__gt=updated_at__gt,
            updated_at__gte=updated_at__gte,
            updated_at__lt=updated_at__lt,
            updated_at__lte=updated_at__lte,
            updated_at__in=updated_at__in,
            updated_at__nin=updated_at__nin,
            updated_at__notin=updated_at__notin,
            updated_at__isnull=updated_at__isnull,
            updated_at__nisnull=updated_at__nisnull,
            updated_at__isnotnull=updated_at__isnotnull,
            updated_at__l=updated_at__l,
            updated_at__like=updated_at__like,
            updated_at__nl=updated_at__nl,
            updated_at__nlike=updated_at__nlike,
            updated_at__notlike=updated_at__notlike,
            updated_at__il=updated_at__il,
            updated_at__ilike=updated_at__ilike,
            updated_at__nil=updated_at__nil,
            updated_at__nilike=updated_at__nilike,
            updated_at__notilike=updated_at__notilike,
            updated_at__desc=updated_at__desc,
            updated_at__asc=updated_at__asc,
            deleted_at__eq=deleted_at__eq,
            deleted_at__ne=deleted_at__ne,
            deleted_at__gt=deleted_at__gt,
            deleted_at__gte=deleted_at__gte,
            deleted_at__lt=deleted_at__lt,
            deleted_at__lte=deleted_at__lte,
            deleted_at__in=deleted_at__in,
            deleted_at__nin=deleted_at__nin,
            deleted_at__notin=deleted_at__notin,
            deleted_at__isnull=deleted_at__isnull,
            deleted_at__nisnull=deleted_at__nisnull,
            deleted_at__isnotnull=deleted_at__isnotnull,
            deleted_at__l=deleted_at__l,
            deleted_at__like=deleted_at__like,
            deleted_at__nl=deleted_at__nl,
            deleted_at__nlike=deleted_at__nlike,
            deleted_at__notlike=deleted_at__notlike,
            deleted_at__il=deleted_at__il,
            deleted_at__ilike=deleted_at__ilike,
            deleted_at__nil=deleted_at__nil,
            deleted_at__nilike=deleted_at__nilike,
            deleted_at__notilike=deleted_at__notilike,
            deleted_at__desc=deleted_at__desc,
            deleted_at__asc=deleted_at__asc,
            name__eq=name__eq,
            name__ne=name__ne,
            name__gt=name__gt,
            name__gte=name__gte,
            name__lt=name__lt,
            name__lte=name__lte,
            name__in=name__in,
            name__nin=name__nin,
            name__notin=name__notin,
            name__isnull=name__isnull,
            name__nisnull=name__nisnull,
            name__isnotnull=name__isnotnull,
            name__l=name__l,
            name__like=name__like,
            name__nl=name__nl,
            name__nlike=name__nlike,
            name__notlike=name__notlike,
            name__il=name__il,
            name__ilike=name__ilike,
            name__nil=name__nil,
            name__nilike=name__nilike,
            name__notilike=name__notilike,
            name__desc=name__desc,
            name__asc=name__asc,
            stream_url__eq=stream_url__eq,
            stream_url__ne=stream_url__ne,
            stream_url__gt=stream_url__gt,
            stream_url__gte=stream_url__gte,
            stream_url__lt=stream_url__lt,
            stream_url__lte=stream_url__lte,
            stream_url__in=stream_url__in,
            stream_url__nin=stream_url__nin,
            stream_url__notin=stream_url__notin,
            stream_url__isnull=stream_url__isnull,
            stream_url__nisnull=stream_url__nisnull,
            stream_url__isnotnull=stream_url__isnotnull,
            stream_url__l=stream_url__l,
            stream_url__like=stream_url__like,
            stream_url__nl=stream_url__nl,
            stream_url__nlike=stream_url__nlike,
            stream_url__notlike=stream_url__notlike,
            stream_url__il=stream_url__il,
            stream_url__ilike=stream_url__ilike,
            stream_url__nil=stream_url__nil,
            stream_url__nilike=stream_url__nilike,
            stream_url__notilike=stream_url__notilike,
            stream_url__desc=stream_url__desc,
            stream_url__asc=stream_url__asc,
            last_seen__eq=last_seen__eq,
            last_seen__ne=last_seen__ne,
            last_seen__gt=last_seen__gt,
            last_seen__gte=last_seen__gte,
            last_seen__lt=last_seen__lt,
            last_seen__lte=last_seen__lte,
            last_seen__in=last_seen__in,
            last_seen__nin=last_seen__nin,
            last_seen__notin=last_seen__notin,
            last_seen__isnull=last_seen__isnull,
            last_seen__nisnull=last_seen__nisnull,
            last_seen__isnotnull=last_seen__isnotnull,
            last_seen__l=last_seen__l,
            last_seen__like=last_seen__like,
            last_seen__nl=last_seen__nl,
            last_seen__nlike=last_seen__nlike,
            last_seen__notlike=last_seen__notlike,
            last_seen__il=last_seen__il,
            last_seen__ilike=last_seen__ilike,
            last_seen__nil=last_seen__nil,
            last_seen__nilike=last_seen__nilike,
            last_seen__notilike=last_seen__notilike,
            last_seen__desc=last_seen__desc,
            last_seen__asc=last_seen__asc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_cameras_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="SQL LIMIT operator")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="SQL OFFSET operator")] = None,
        id__eq: Annotated[Optional[StrictStr], Field(description="SQL = operator")] = None,
        id__ne: Annotated[Optional[StrictStr], Field(description="SQL != operator")] = None,
        id__gt: Annotated[Optional[StrictStr], Field(description="SQL > operator, may not work with all column types")] = None,
        id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= operator, may not work with all column types")] = None,
        id__lt: Annotated[Optional[StrictStr], Field(description="SQL < operator, may not work with all column types")] = None,
        id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= operator, may not work with all column types")] = None,
        id__in: Annotated[Optional[StrictStr], Field(description="SQL IN operator, permits comma-separated values")] = None,
        id__nin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        id__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        id__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        id__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        id__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        created_at__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        created_at__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        created_at__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        created_at__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        created_at__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        created_at__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        created_at__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        created_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        created_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        updated_at__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        updated_at__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        updated_at__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        updated_at__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        updated_at__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        updated_at__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        updated_at__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        updated_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        updated_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        deleted_at__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        deleted_at__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        deleted_at__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        deleted_at__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        deleted_at__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        deleted_at__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        deleted_at__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        deleted_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        deleted_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        name__eq: Annotated[Optional[StrictStr], Field(description="SQL = operator")] = None,
        name__ne: Annotated[Optional[StrictStr], Field(description="SQL != operator")] = None,
        name__gt: Annotated[Optional[StrictStr], Field(description="SQL > operator, may not work with all column types")] = None,
        name__gte: Annotated[Optional[StrictStr], Field(description="SQL >= operator, may not work with all column types")] = None,
        name__lt: Annotated[Optional[StrictStr], Field(description="SQL < operator, may not work with all column types")] = None,
        name__lte: Annotated[Optional[StrictStr], Field(description="SQL <= operator, may not work with all column types")] = None,
        name__in: Annotated[Optional[StrictStr], Field(description="SQL IN operator, permits comma-separated values")] = None,
        name__nin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        name__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        name__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        name__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        name__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        name__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        name__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__eq: Annotated[Optional[StrictStr], Field(description="SQL = operator")] = None,
        stream_url__ne: Annotated[Optional[StrictStr], Field(description="SQL != operator")] = None,
        stream_url__gt: Annotated[Optional[StrictStr], Field(description="SQL > operator, may not work with all column types")] = None,
        stream_url__gte: Annotated[Optional[StrictStr], Field(description="SQL >= operator, may not work with all column types")] = None,
        stream_url__lt: Annotated[Optional[StrictStr], Field(description="SQL < operator, may not work with all column types")] = None,
        stream_url__lte: Annotated[Optional[StrictStr], Field(description="SQL <= operator, may not work with all column types")] = None,
        stream_url__in: Annotated[Optional[StrictStr], Field(description="SQL IN operator, permits comma-separated values")] = None,
        stream_url__nin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        stream_url__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        stream_url__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        last_seen__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        last_seen__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        last_seen__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        last_seen__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        last_seen__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        last_seen__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        last_seen__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        last_seen__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        last_seen__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCameras200Response]:
        """get_cameras


        :param limit: SQL LIMIT operator
        :type limit: int
        :param offset: SQL OFFSET operator
        :type offset: int
        :param id__eq: SQL = operator
        :type id__eq: str
        :param id__ne: SQL != operator
        :type id__ne: str
        :param id__gt: SQL > operator, may not work with all column types
        :type id__gt: str
        :param id__gte: SQL >= operator, may not work with all column types
        :type id__gte: str
        :param id__lt: SQL < operator, may not work with all column types
        :type id__lt: str
        :param id__lte: SQL <= operator, may not work with all column types
        :type id__lte: str
        :param id__in: SQL IN operator, permits comma-separated values
        :type id__in: str
        :param id__nin: SQL NOT IN operator, permits comma-separated values
        :type id__nin: str
        :param id__notin: SQL NOT IN operator, permits comma-separated values
        :type id__notin: str
        :param id__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type id__isnull: str
        :param id__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type id__nisnull: str
        :param id__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type id__isnotnull: str
        :param id__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__l: str
        :param id__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__like: str
        :param id__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nl: str
        :param id__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nlike: str
        :param id__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__notlike: str
        :param id__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__il: str
        :param id__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__ilike: str
        :param id__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nil: str
        :param id__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nilike: str
        :param id__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__notilike: str
        :param id__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type id__desc: str
        :param id__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type id__asc: str
        :param created_at__eq: SQL = operator
        :type created_at__eq: datetime
        :param created_at__ne: SQL != operator
        :type created_at__ne: datetime
        :param created_at__gt: SQL > operator, may not work with all column types
        :type created_at__gt: datetime
        :param created_at__gte: SQL >= operator, may not work with all column types
        :type created_at__gte: datetime
        :param created_at__lt: SQL < operator, may not work with all column types
        :type created_at__lt: datetime
        :param created_at__lte: SQL <= operator, may not work with all column types
        :type created_at__lte: datetime
        :param created_at__in: SQL IN operator, permits comma-separated values
        :type created_at__in: datetime
        :param created_at__nin: SQL NOT IN operator, permits comma-separated values
        :type created_at__nin: datetime
        :param created_at__notin: SQL NOT IN operator, permits comma-separated values
        :type created_at__notin: datetime
        :param created_at__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type created_at__isnull: str
        :param created_at__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type created_at__nisnull: str
        :param created_at__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type created_at__isnotnull: str
        :param created_at__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__l: str
        :param created_at__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__like: str
        :param created_at__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nl: str
        :param created_at__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nlike: str
        :param created_at__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__notlike: str
        :param created_at__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__il: str
        :param created_at__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__ilike: str
        :param created_at__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nil: str
        :param created_at__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nilike: str
        :param created_at__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__notilike: str
        :param created_at__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type created_at__desc: str
        :param created_at__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type created_at__asc: str
        :param updated_at__eq: SQL = operator
        :type updated_at__eq: datetime
        :param updated_at__ne: SQL != operator
        :type updated_at__ne: datetime
        :param updated_at__gt: SQL > operator, may not work with all column types
        :type updated_at__gt: datetime
        :param updated_at__gte: SQL >= operator, may not work with all column types
        :type updated_at__gte: datetime
        :param updated_at__lt: SQL < operator, may not work with all column types
        :type updated_at__lt: datetime
        :param updated_at__lte: SQL <= operator, may not work with all column types
        :type updated_at__lte: datetime
        :param updated_at__in: SQL IN operator, permits comma-separated values
        :type updated_at__in: datetime
        :param updated_at__nin: SQL NOT IN operator, permits comma-separated values
        :type updated_at__nin: datetime
        :param updated_at__notin: SQL NOT IN operator, permits comma-separated values
        :type updated_at__notin: datetime
        :param updated_at__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type updated_at__isnull: str
        :param updated_at__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type updated_at__nisnull: str
        :param updated_at__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type updated_at__isnotnull: str
        :param updated_at__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__l: str
        :param updated_at__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__like: str
        :param updated_at__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nl: str
        :param updated_at__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nlike: str
        :param updated_at__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__notlike: str
        :param updated_at__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__il: str
        :param updated_at__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__ilike: str
        :param updated_at__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nil: str
        :param updated_at__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nilike: str
        :param updated_at__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__notilike: str
        :param updated_at__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type updated_at__desc: str
        :param updated_at__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type updated_at__asc: str
        :param deleted_at__eq: SQL = operator
        :type deleted_at__eq: datetime
        :param deleted_at__ne: SQL != operator
        :type deleted_at__ne: datetime
        :param deleted_at__gt: SQL > operator, may not work with all column types
        :type deleted_at__gt: datetime
        :param deleted_at__gte: SQL >= operator, may not work with all column types
        :type deleted_at__gte: datetime
        :param deleted_at__lt: SQL < operator, may not work with all column types
        :type deleted_at__lt: datetime
        :param deleted_at__lte: SQL <= operator, may not work with all column types
        :type deleted_at__lte: datetime
        :param deleted_at__in: SQL IN operator, permits comma-separated values
        :type deleted_at__in: datetime
        :param deleted_at__nin: SQL NOT IN operator, permits comma-separated values
        :type deleted_at__nin: datetime
        :param deleted_at__notin: SQL NOT IN operator, permits comma-separated values
        :type deleted_at__notin: datetime
        :param deleted_at__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type deleted_at__isnull: str
        :param deleted_at__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type deleted_at__nisnull: str
        :param deleted_at__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type deleted_at__isnotnull: str
        :param deleted_at__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__l: str
        :param deleted_at__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__like: str
        :param deleted_at__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nl: str
        :param deleted_at__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nlike: str
        :param deleted_at__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__notlike: str
        :param deleted_at__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__il: str
        :param deleted_at__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__ilike: str
        :param deleted_at__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nil: str
        :param deleted_at__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nilike: str
        :param deleted_at__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__notilike: str
        :param deleted_at__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type deleted_at__desc: str
        :param deleted_at__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type deleted_at__asc: str
        :param name__eq: SQL = operator
        :type name__eq: str
        :param name__ne: SQL != operator
        :type name__ne: str
        :param name__gt: SQL > operator, may not work with all column types
        :type name__gt: str
        :param name__gte: SQL >= operator, may not work with all column types
        :type name__gte: str
        :param name__lt: SQL < operator, may not work with all column types
        :type name__lt: str
        :param name__lte: SQL <= operator, may not work with all column types
        :type name__lte: str
        :param name__in: SQL IN operator, permits comma-separated values
        :type name__in: str
        :param name__nin: SQL NOT IN operator, permits comma-separated values
        :type name__nin: str
        :param name__notin: SQL NOT IN operator, permits comma-separated values
        :type name__notin: str
        :param name__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type name__isnull: str
        :param name__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type name__nisnull: str
        :param name__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type name__isnotnull: str
        :param name__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__l: str
        :param name__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__like: str
        :param name__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nl: str
        :param name__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nlike: str
        :param name__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__notlike: str
        :param name__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__il: str
        :param name__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__ilike: str
        :param name__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nil: str
        :param name__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nilike: str
        :param name__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__notilike: str
        :param name__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type name__desc: str
        :param name__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type name__asc: str
        :param stream_url__eq: SQL = operator
        :type stream_url__eq: str
        :param stream_url__ne: SQL != operator
        :type stream_url__ne: str
        :param stream_url__gt: SQL > operator, may not work with all column types
        :type stream_url__gt: str
        :param stream_url__gte: SQL >= operator, may not work with all column types
        :type stream_url__gte: str
        :param stream_url__lt: SQL < operator, may not work with all column types
        :type stream_url__lt: str
        :param stream_url__lte: SQL <= operator, may not work with all column types
        :type stream_url__lte: str
        :param stream_url__in: SQL IN operator, permits comma-separated values
        :type stream_url__in: str
        :param stream_url__nin: SQL NOT IN operator, permits comma-separated values
        :type stream_url__nin: str
        :param stream_url__notin: SQL NOT IN operator, permits comma-separated values
        :type stream_url__notin: str
        :param stream_url__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type stream_url__isnull: str
        :param stream_url__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type stream_url__nisnull: str
        :param stream_url__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type stream_url__isnotnull: str
        :param stream_url__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__l: str
        :param stream_url__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__like: str
        :param stream_url__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nl: str
        :param stream_url__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nlike: str
        :param stream_url__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__notlike: str
        :param stream_url__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__il: str
        :param stream_url__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__ilike: str
        :param stream_url__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nil: str
        :param stream_url__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nilike: str
        :param stream_url__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__notilike: str
        :param stream_url__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type stream_url__desc: str
        :param stream_url__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type stream_url__asc: str
        :param last_seen__eq: SQL = operator
        :type last_seen__eq: datetime
        :param last_seen__ne: SQL != operator
        :type last_seen__ne: datetime
        :param last_seen__gt: SQL > operator, may not work with all column types
        :type last_seen__gt: datetime
        :param last_seen__gte: SQL >= operator, may not work with all column types
        :type last_seen__gte: datetime
        :param last_seen__lt: SQL < operator, may not work with all column types
        :type last_seen__lt: datetime
        :param last_seen__lte: SQL <= operator, may not work with all column types
        :type last_seen__lte: datetime
        :param last_seen__in: SQL IN operator, permits comma-separated values
        :type last_seen__in: datetime
        :param last_seen__nin: SQL NOT IN operator, permits comma-separated values
        :type last_seen__nin: datetime
        :param last_seen__notin: SQL NOT IN operator, permits comma-separated values
        :type last_seen__notin: datetime
        :param last_seen__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type last_seen__isnull: str
        :param last_seen__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type last_seen__nisnull: str
        :param last_seen__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type last_seen__isnotnull: str
        :param last_seen__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__l: str
        :param last_seen__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__like: str
        :param last_seen__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nl: str
        :param last_seen__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nlike: str
        :param last_seen__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__notlike: str
        :param last_seen__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__il: str
        :param last_seen__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__ilike: str
        :param last_seen__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nil: str
        :param last_seen__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nilike: str
        :param last_seen__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__notilike: str
        :param last_seen__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type last_seen__desc: str
        :param last_seen__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type last_seen__asc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_cameras_serialize(
            limit=limit,
            offset=offset,
            id__eq=id__eq,
            id__ne=id__ne,
            id__gt=id__gt,
            id__gte=id__gte,
            id__lt=id__lt,
            id__lte=id__lte,
            id__in=id__in,
            id__nin=id__nin,
            id__notin=id__notin,
            id__isnull=id__isnull,
            id__nisnull=id__nisnull,
            id__isnotnull=id__isnotnull,
            id__l=id__l,
            id__like=id__like,
            id__nl=id__nl,
            id__nlike=id__nlike,
            id__notlike=id__notlike,
            id__il=id__il,
            id__ilike=id__ilike,
            id__nil=id__nil,
            id__nilike=id__nilike,
            id__notilike=id__notilike,
            id__desc=id__desc,
            id__asc=id__asc,
            created_at__eq=created_at__eq,
            created_at__ne=created_at__ne,
            created_at__gt=created_at__gt,
            created_at__gte=created_at__gte,
            created_at__lt=created_at__lt,
            created_at__lte=created_at__lte,
            created_at__in=created_at__in,
            created_at__nin=created_at__nin,
            created_at__notin=created_at__notin,
            created_at__isnull=created_at__isnull,
            created_at__nisnull=created_at__nisnull,
            created_at__isnotnull=created_at__isnotnull,
            created_at__l=created_at__l,
            created_at__like=created_at__like,
            created_at__nl=created_at__nl,
            created_at__nlike=created_at__nlike,
            created_at__notlike=created_at__notlike,
            created_at__il=created_at__il,
            created_at__ilike=created_at__ilike,
            created_at__nil=created_at__nil,
            created_at__nilike=created_at__nilike,
            created_at__notilike=created_at__notilike,
            created_at__desc=created_at__desc,
            created_at__asc=created_at__asc,
            updated_at__eq=updated_at__eq,
            updated_at__ne=updated_at__ne,
            updated_at__gt=updated_at__gt,
            updated_at__gte=updated_at__gte,
            updated_at__lt=updated_at__lt,
            updated_at__lte=updated_at__lte,
            updated_at__in=updated_at__in,
            updated_at__nin=updated_at__nin,
            updated_at__notin=updated_at__notin,
            updated_at__isnull=updated_at__isnull,
            updated_at__nisnull=updated_at__nisnull,
            updated_at__isnotnull=updated_at__isnotnull,
            updated_at__l=updated_at__l,
            updated_at__like=updated_at__like,
            updated_at__nl=updated_at__nl,
            updated_at__nlike=updated_at__nlike,
            updated_at__notlike=updated_at__notlike,
            updated_at__il=updated_at__il,
            updated_at__ilike=updated_at__ilike,
            updated_at__nil=updated_at__nil,
            updated_at__nilike=updated_at__nilike,
            updated_at__notilike=updated_at__notilike,
            updated_at__desc=updated_at__desc,
            updated_at__asc=updated_at__asc,
            deleted_at__eq=deleted_at__eq,
            deleted_at__ne=deleted_at__ne,
            deleted_at__gt=deleted_at__gt,
            deleted_at__gte=deleted_at__gte,
            deleted_at__lt=deleted_at__lt,
            deleted_at__lte=deleted_at__lte,
            deleted_at__in=deleted_at__in,
            deleted_at__nin=deleted_at__nin,
            deleted_at__notin=deleted_at__notin,
            deleted_at__isnull=deleted_at__isnull,
            deleted_at__nisnull=deleted_at__nisnull,
            deleted_at__isnotnull=deleted_at__isnotnull,
            deleted_at__l=deleted_at__l,
            deleted_at__like=deleted_at__like,
            deleted_at__nl=deleted_at__nl,
            deleted_at__nlike=deleted_at__nlike,
            deleted_at__notlike=deleted_at__notlike,
            deleted_at__il=deleted_at__il,
            deleted_at__ilike=deleted_at__ilike,
            deleted_at__nil=deleted_at__nil,
            deleted_at__nilike=deleted_at__nilike,
            deleted_at__notilike=deleted_at__notilike,
            deleted_at__desc=deleted_at__desc,
            deleted_at__asc=deleted_at__asc,
            name__eq=name__eq,
            name__ne=name__ne,
            name__gt=name__gt,
            name__gte=name__gte,
            name__lt=name__lt,
            name__lte=name__lte,
            name__in=name__in,
            name__nin=name__nin,
            name__notin=name__notin,
            name__isnull=name__isnull,
            name__nisnull=name__nisnull,
            name__isnotnull=name__isnotnull,
            name__l=name__l,
            name__like=name__like,
            name__nl=name__nl,
            name__nlike=name__nlike,
            name__notlike=name__notlike,
            name__il=name__il,
            name__ilike=name__ilike,
            name__nil=name__nil,
            name__nilike=name__nilike,
            name__notilike=name__notilike,
            name__desc=name__desc,
            name__asc=name__asc,
            stream_url__eq=stream_url__eq,
            stream_url__ne=stream_url__ne,
            stream_url__gt=stream_url__gt,
            stream_url__gte=stream_url__gte,
            stream_url__lt=stream_url__lt,
            stream_url__lte=stream_url__lte,
            stream_url__in=stream_url__in,
            stream_url__nin=stream_url__nin,
            stream_url__notin=stream_url__notin,
            stream_url__isnull=stream_url__isnull,
            stream_url__nisnull=stream_url__nisnull,
            stream_url__isnotnull=stream_url__isnotnull,
            stream_url__l=stream_url__l,
            stream_url__like=stream_url__like,
            stream_url__nl=stream_url__nl,
            stream_url__nlike=stream_url__nlike,
            stream_url__notlike=stream_url__notlike,
            stream_url__il=stream_url__il,
            stream_url__ilike=stream_url__ilike,
            stream_url__nil=stream_url__nil,
            stream_url__nilike=stream_url__nilike,
            stream_url__notilike=stream_url__notilike,
            stream_url__desc=stream_url__desc,
            stream_url__asc=stream_url__asc,
            last_seen__eq=last_seen__eq,
            last_seen__ne=last_seen__ne,
            last_seen__gt=last_seen__gt,
            last_seen__gte=last_seen__gte,
            last_seen__lt=last_seen__lt,
            last_seen__lte=last_seen__lte,
            last_seen__in=last_seen__in,
            last_seen__nin=last_seen__nin,
            last_seen__notin=last_seen__notin,
            last_seen__isnull=last_seen__isnull,
            last_seen__nisnull=last_seen__nisnull,
            last_seen__isnotnull=last_seen__isnotnull,
            last_seen__l=last_seen__l,
            last_seen__like=last_seen__like,
            last_seen__nl=last_seen__nl,
            last_seen__nlike=last_seen__nlike,
            last_seen__notlike=last_seen__notlike,
            last_seen__il=last_seen__il,
            last_seen__ilike=last_seen__ilike,
            last_seen__nil=last_seen__nil,
            last_seen__nilike=last_seen__nilike,
            last_seen__notilike=last_seen__notilike,
            last_seen__desc=last_seen__desc,
            last_seen__asc=last_seen__asc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_cameras_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="SQL LIMIT operator")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="SQL OFFSET operator")] = None,
        id__eq: Annotated[Optional[StrictStr], Field(description="SQL = operator")] = None,
        id__ne: Annotated[Optional[StrictStr], Field(description="SQL != operator")] = None,
        id__gt: Annotated[Optional[StrictStr], Field(description="SQL > operator, may not work with all column types")] = None,
        id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= operator, may not work with all column types")] = None,
        id__lt: Annotated[Optional[StrictStr], Field(description="SQL < operator, may not work with all column types")] = None,
        id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= operator, may not work with all column types")] = None,
        id__in: Annotated[Optional[StrictStr], Field(description="SQL IN operator, permits comma-separated values")] = None,
        id__nin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        id__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        id__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        id__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        id__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        created_at__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        created_at__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        created_at__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        created_at__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        created_at__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        created_at__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        created_at__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        created_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        created_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        created_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        created_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        updated_at__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        updated_at__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        updated_at__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        updated_at__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        updated_at__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        updated_at__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        updated_at__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        updated_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        updated_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        updated_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        deleted_at__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        deleted_at__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        deleted_at__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        deleted_at__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        deleted_at__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        deleted_at__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        deleted_at__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        deleted_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        deleted_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        name__eq: Annotated[Optional[StrictStr], Field(description="SQL = operator")] = None,
        name__ne: Annotated[Optional[StrictStr], Field(description="SQL != operator")] = None,
        name__gt: Annotated[Optional[StrictStr], Field(description="SQL > operator, may not work with all column types")] = None,
        name__gte: Annotated[Optional[StrictStr], Field(description="SQL >= operator, may not work with all column types")] = None,
        name__lt: Annotated[Optional[StrictStr], Field(description="SQL < operator, may not work with all column types")] = None,
        name__lte: Annotated[Optional[StrictStr], Field(description="SQL <= operator, may not work with all column types")] = None,
        name__in: Annotated[Optional[StrictStr], Field(description="SQL IN operator, permits comma-separated values")] = None,
        name__nin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        name__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        name__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        name__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        name__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        name__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        name__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        name__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__eq: Annotated[Optional[StrictStr], Field(description="SQL = operator")] = None,
        stream_url__ne: Annotated[Optional[StrictStr], Field(description="SQL != operator")] = None,
        stream_url__gt: Annotated[Optional[StrictStr], Field(description="SQL > operator, may not work with all column types")] = None,
        stream_url__gte: Annotated[Optional[StrictStr], Field(description="SQL >= operator, may not work with all column types")] = None,
        stream_url__lt: Annotated[Optional[StrictStr], Field(description="SQL < operator, may not work with all column types")] = None,
        stream_url__lte: Annotated[Optional[StrictStr], Field(description="SQL <= operator, may not work with all column types")] = None,
        stream_url__in: Annotated[Optional[StrictStr], Field(description="SQL IN operator, permits comma-separated values")] = None,
        stream_url__nin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        stream_url__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        stream_url__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        stream_url__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__eq: Annotated[Optional[datetime], Field(description="SQL = operator")] = None,
        last_seen__ne: Annotated[Optional[datetime], Field(description="SQL != operator")] = None,
        last_seen__gt: Annotated[Optional[datetime], Field(description="SQL > operator, may not work with all column types")] = None,
        last_seen__gte: Annotated[Optional[datetime], Field(description="SQL >= operator, may not work with all column types")] = None,
        last_seen__lt: Annotated[Optional[datetime], Field(description="SQL < operator, may not work with all column types")] = None,
        last_seen__lte: Annotated[Optional[datetime], Field(description="SQL <= operator, may not work with all column types")] = None,
        last_seen__in: Annotated[Optional[datetime], Field(description="SQL IN operator, permits comma-separated values")] = None,
        last_seen__nin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        last_seen__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN operator, permits comma-separated values")] = None,
        last_seen__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS NULL operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__nisnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__l: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nl: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__il: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nil: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__nilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)")] = None,
        last_seen__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_cameras


        :param limit: SQL LIMIT operator
        :type limit: int
        :param offset: SQL OFFSET operator
        :type offset: int
        :param id__eq: SQL = operator
        :type id__eq: str
        :param id__ne: SQL != operator
        :type id__ne: str
        :param id__gt: SQL > operator, may not work with all column types
        :type id__gt: str
        :param id__gte: SQL >= operator, may not work with all column types
        :type id__gte: str
        :param id__lt: SQL < operator, may not work with all column types
        :type id__lt: str
        :param id__lte: SQL <= operator, may not work with all column types
        :type id__lte: str
        :param id__in: SQL IN operator, permits comma-separated values
        :type id__in: str
        :param id__nin: SQL NOT IN operator, permits comma-separated values
        :type id__nin: str
        :param id__notin: SQL NOT IN operator, permits comma-separated values
        :type id__notin: str
        :param id__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type id__isnull: str
        :param id__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type id__nisnull: str
        :param id__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type id__isnotnull: str
        :param id__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__l: str
        :param id__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__like: str
        :param id__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nl: str
        :param id__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nlike: str
        :param id__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type id__notlike: str
        :param id__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__il: str
        :param id__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__ilike: str
        :param id__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nil: str
        :param id__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__nilike: str
        :param id__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type id__notilike: str
        :param id__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type id__desc: str
        :param id__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type id__asc: str
        :param created_at__eq: SQL = operator
        :type created_at__eq: datetime
        :param created_at__ne: SQL != operator
        :type created_at__ne: datetime
        :param created_at__gt: SQL > operator, may not work with all column types
        :type created_at__gt: datetime
        :param created_at__gte: SQL >= operator, may not work with all column types
        :type created_at__gte: datetime
        :param created_at__lt: SQL < operator, may not work with all column types
        :type created_at__lt: datetime
        :param created_at__lte: SQL <= operator, may not work with all column types
        :type created_at__lte: datetime
        :param created_at__in: SQL IN operator, permits comma-separated values
        :type created_at__in: datetime
        :param created_at__nin: SQL NOT IN operator, permits comma-separated values
        :type created_at__nin: datetime
        :param created_at__notin: SQL NOT IN operator, permits comma-separated values
        :type created_at__notin: datetime
        :param created_at__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type created_at__isnull: str
        :param created_at__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type created_at__nisnull: str
        :param created_at__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type created_at__isnotnull: str
        :param created_at__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__l: str
        :param created_at__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__like: str
        :param created_at__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nl: str
        :param created_at__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nlike: str
        :param created_at__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__notlike: str
        :param created_at__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__il: str
        :param created_at__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__ilike: str
        :param created_at__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nil: str
        :param created_at__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__nilike: str
        :param created_at__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type created_at__notilike: str
        :param created_at__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type created_at__desc: str
        :param created_at__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type created_at__asc: str
        :param updated_at__eq: SQL = operator
        :type updated_at__eq: datetime
        :param updated_at__ne: SQL != operator
        :type updated_at__ne: datetime
        :param updated_at__gt: SQL > operator, may not work with all column types
        :type updated_at__gt: datetime
        :param updated_at__gte: SQL >= operator, may not work with all column types
        :type updated_at__gte: datetime
        :param updated_at__lt: SQL < operator, may not work with all column types
        :type updated_at__lt: datetime
        :param updated_at__lte: SQL <= operator, may not work with all column types
        :type updated_at__lte: datetime
        :param updated_at__in: SQL IN operator, permits comma-separated values
        :type updated_at__in: datetime
        :param updated_at__nin: SQL NOT IN operator, permits comma-separated values
        :type updated_at__nin: datetime
        :param updated_at__notin: SQL NOT IN operator, permits comma-separated values
        :type updated_at__notin: datetime
        :param updated_at__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type updated_at__isnull: str
        :param updated_at__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type updated_at__nisnull: str
        :param updated_at__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type updated_at__isnotnull: str
        :param updated_at__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__l: str
        :param updated_at__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__like: str
        :param updated_at__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nl: str
        :param updated_at__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nlike: str
        :param updated_at__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__notlike: str
        :param updated_at__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__il: str
        :param updated_at__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__ilike: str
        :param updated_at__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nil: str
        :param updated_at__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__nilike: str
        :param updated_at__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type updated_at__notilike: str
        :param updated_at__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type updated_at__desc: str
        :param updated_at__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type updated_at__asc: str
        :param deleted_at__eq: SQL = operator
        :type deleted_at__eq: datetime
        :param deleted_at__ne: SQL != operator
        :type deleted_at__ne: datetime
        :param deleted_at__gt: SQL > operator, may not work with all column types
        :type deleted_at__gt: datetime
        :param deleted_at__gte: SQL >= operator, may not work with all column types
        :type deleted_at__gte: datetime
        :param deleted_at__lt: SQL < operator, may not work with all column types
        :type deleted_at__lt: datetime
        :param deleted_at__lte: SQL <= operator, may not work with all column types
        :type deleted_at__lte: datetime
        :param deleted_at__in: SQL IN operator, permits comma-separated values
        :type deleted_at__in: datetime
        :param deleted_at__nin: SQL NOT IN operator, permits comma-separated values
        :type deleted_at__nin: datetime
        :param deleted_at__notin: SQL NOT IN operator, permits comma-separated values
        :type deleted_at__notin: datetime
        :param deleted_at__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type deleted_at__isnull: str
        :param deleted_at__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type deleted_at__nisnull: str
        :param deleted_at__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type deleted_at__isnotnull: str
        :param deleted_at__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__l: str
        :param deleted_at__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__like: str
        :param deleted_at__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nl: str
        :param deleted_at__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nlike: str
        :param deleted_at__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__notlike: str
        :param deleted_at__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__il: str
        :param deleted_at__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__ilike: str
        :param deleted_at__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nil: str
        :param deleted_at__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__nilike: str
        :param deleted_at__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type deleted_at__notilike: str
        :param deleted_at__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type deleted_at__desc: str
        :param deleted_at__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type deleted_at__asc: str
        :param name__eq: SQL = operator
        :type name__eq: str
        :param name__ne: SQL != operator
        :type name__ne: str
        :param name__gt: SQL > operator, may not work with all column types
        :type name__gt: str
        :param name__gte: SQL >= operator, may not work with all column types
        :type name__gte: str
        :param name__lt: SQL < operator, may not work with all column types
        :type name__lt: str
        :param name__lte: SQL <= operator, may not work with all column types
        :type name__lte: str
        :param name__in: SQL IN operator, permits comma-separated values
        :type name__in: str
        :param name__nin: SQL NOT IN operator, permits comma-separated values
        :type name__nin: str
        :param name__notin: SQL NOT IN operator, permits comma-separated values
        :type name__notin: str
        :param name__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type name__isnull: str
        :param name__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type name__nisnull: str
        :param name__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type name__isnotnull: str
        :param name__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__l: str
        :param name__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__like: str
        :param name__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nl: str
        :param name__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nlike: str
        :param name__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type name__notlike: str
        :param name__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__il: str
        :param name__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__ilike: str
        :param name__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nil: str
        :param name__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__nilike: str
        :param name__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type name__notilike: str
        :param name__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type name__desc: str
        :param name__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type name__asc: str
        :param stream_url__eq: SQL = operator
        :type stream_url__eq: str
        :param stream_url__ne: SQL != operator
        :type stream_url__ne: str
        :param stream_url__gt: SQL > operator, may not work with all column types
        :type stream_url__gt: str
        :param stream_url__gte: SQL >= operator, may not work with all column types
        :type stream_url__gte: str
        :param stream_url__lt: SQL < operator, may not work with all column types
        :type stream_url__lt: str
        :param stream_url__lte: SQL <= operator, may not work with all column types
        :type stream_url__lte: str
        :param stream_url__in: SQL IN operator, permits comma-separated values
        :type stream_url__in: str
        :param stream_url__nin: SQL NOT IN operator, permits comma-separated values
        :type stream_url__nin: str
        :param stream_url__notin: SQL NOT IN operator, permits comma-separated values
        :type stream_url__notin: str
        :param stream_url__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type stream_url__isnull: str
        :param stream_url__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type stream_url__nisnull: str
        :param stream_url__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type stream_url__isnotnull: str
        :param stream_url__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__l: str
        :param stream_url__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__like: str
        :param stream_url__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nl: str
        :param stream_url__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nlike: str
        :param stream_url__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__notlike: str
        :param stream_url__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__il: str
        :param stream_url__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__ilike: str
        :param stream_url__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nil: str
        :param stream_url__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__nilike: str
        :param stream_url__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type stream_url__notilike: str
        :param stream_url__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type stream_url__desc: str
        :param stream_url__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type stream_url__asc: str
        :param last_seen__eq: SQL = operator
        :type last_seen__eq: datetime
        :param last_seen__ne: SQL != operator
        :type last_seen__ne: datetime
        :param last_seen__gt: SQL > operator, may not work with all column types
        :type last_seen__gt: datetime
        :param last_seen__gte: SQL >= operator, may not work with all column types
        :type last_seen__gte: datetime
        :param last_seen__lt: SQL < operator, may not work with all column types
        :type last_seen__lt: datetime
        :param last_seen__lte: SQL <= operator, may not work with all column types
        :type last_seen__lte: datetime
        :param last_seen__in: SQL IN operator, permits comma-separated values
        :type last_seen__in: datetime
        :param last_seen__nin: SQL NOT IN operator, permits comma-separated values
        :type last_seen__nin: datetime
        :param last_seen__notin: SQL NOT IN operator, permits comma-separated values
        :type last_seen__notin: datetime
        :param last_seen__isnull: SQL IS NULL operator, value is ignored (presence of key is sufficient)
        :type last_seen__isnull: str
        :param last_seen__nisnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type last_seen__nisnull: str
        :param last_seen__isnotnull: SQL IS NOT NULL operator, value is ignored (presence of key is sufficient)
        :type last_seen__isnotnull: str
        :param last_seen__l: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__l: str
        :param last_seen__like: SQL LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__like: str
        :param last_seen__nl: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nl: str
        :param last_seen__nlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nlike: str
        :param last_seen__notlike: SQL NOT LIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__notlike: str
        :param last_seen__il: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__il: str
        :param last_seen__ilike: SQL ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__ilike: str
        :param last_seen__nil: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nil: str
        :param last_seen__nilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__nilike: str
        :param last_seen__notilike: SQL NOT ILIKE operator, value is implicitly prefixed and suffixed with %
        :type last_seen__notilike: str
        :param last_seen__desc: SQL ORDER BY _ DESC operator, value is ignored (presence of key is sufficient)
        :type last_seen__desc: str
        :param last_seen__asc: SQL ORDER BY _ ASC operator, value is ignored (presence of key is sufficient)
        :type last_seen__asc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_cameras_serialize(
            limit=limit,
            offset=offset,
            id__eq=id__eq,
            id__ne=id__ne,
            id__gt=id__gt,
            id__gte=id__gte,
            id__lt=id__lt,
            id__lte=id__lte,
            id__in=id__in,
            id__nin=id__nin,
            id__notin=id__notin,
            id__isnull=id__isnull,
            id__nisnull=id__nisnull,
            id__isnotnull=id__isnotnull,
            id__l=id__l,
            id__like=id__like,
            id__nl=id__nl,
            id__nlike=id__nlike,
            id__notlike=id__notlike,
            id__il=id__il,
            id__ilike=id__ilike,
            id__nil=id__nil,
            id__nilike=id__nilike,
            id__notilike=id__notilike,
            id__desc=id__desc,
            id__asc=id__asc,
            created_at__eq=created_at__eq,
            created_at__ne=created_at__ne,
            created_at__gt=created_at__gt,
            created_at__gte=created_at__gte,
            created_at__lt=created_at__lt,
            created_at__lte=created_at__lte,
            created_at__in=created_at__in,
            created_at__nin=created_at__nin,
            created_at__notin=created_at__notin,
            created_at__isnull=created_at__isnull,
            created_at__nisnull=created_at__nisnull,
            created_at__isnotnull=created_at__isnotnull,
            created_at__l=created_at__l,
            created_at__like=created_at__like,
            created_at__nl=created_at__nl,
            created_at__nlike=created_at__nlike,
            created_at__notlike=created_at__notlike,
            created_at__il=created_at__il,
            created_at__ilike=created_at__ilike,
            created_at__nil=created_at__nil,
            created_at__nilike=created_at__nilike,
            created_at__notilike=created_at__notilike,
            created_at__desc=created_at__desc,
            created_at__asc=created_at__asc,
            updated_at__eq=updated_at__eq,
            updated_at__ne=updated_at__ne,
            updated_at__gt=updated_at__gt,
            updated_at__gte=updated_at__gte,
            updated_at__lt=updated_at__lt,
            updated_at__lte=updated_at__lte,
            updated_at__in=updated_at__in,
            updated_at__nin=updated_at__nin,
            updated_at__notin=updated_at__notin,
            updated_at__isnull=updated_at__isnull,
            updated_at__nisnull=updated_at__nisnull,
            updated_at__isnotnull=updated_at__isnotnull,
            updated_at__l=updated_at__l,
            updated_at__like=updated_at__like,
            updated_at__nl=updated_at__nl,
            updated_at__nlike=updated_at__nlike,
            updated_at__notlike=updated_at__notlike,
            updated_at__il=updated_at__il,
            updated_at__ilike=updated_at__ilike,
            updated_at__nil=updated_at__nil,
            updated_at__nilike=updated_at__nilike,
            updated_at__notilike=updated_at__notilike,
            updated_at__desc=updated_at__desc,
            updated_at__asc=updated_at__asc,
            deleted_at__eq=deleted_at__eq,
            deleted_at__ne=deleted_at__ne,
            deleted_at__gt=deleted_at__gt,
            deleted_at__gte=deleted_at__gte,
            deleted_at__lt=deleted_at__lt,
            deleted_at__lte=deleted_at__lte,
            deleted_at__in=deleted_at__in,
            deleted_at__nin=deleted_at__nin,
            deleted_at__notin=deleted_at__notin,
            deleted_at__isnull=deleted_at__isnull,
            deleted_at__nisnull=deleted_at__nisnull,
            deleted_at__isnotnull=deleted_at__isnotnull,
            deleted_at__l=deleted_at__l,
            deleted_at__like=deleted_at__like,
            deleted_at__nl=deleted_at__nl,
            deleted_at__nlike=deleted_at__nlike,
            deleted_at__notlike=deleted_at__notlike,
            deleted_at__il=deleted_at__il,
            deleted_at__ilike=deleted_at__ilike,
            deleted_at__nil=deleted_at__nil,
            deleted_at__nilike=deleted_at__nilike,
            deleted_at__notilike=deleted_at__notilike,
            deleted_at__desc=deleted_at__desc,
            deleted_at__asc=deleted_at__asc,
            name__eq=name__eq,
            name__ne=name__ne,
            name__gt=name__gt,
            name__gte=name__gte,
            name__lt=name__lt,
            name__lte=name__lte,
            name__in=name__in,
            name__nin=name__nin,
            name__notin=name__notin,
            name__isnull=name__isnull,
            name__nisnull=name__nisnull,
            name__isnotnull=name__isnotnull,
            name__l=name__l,
            name__like=name__like,
            name__nl=name__nl,
            name__nlike=name__nlike,
            name__notlike=name__notlike,
            name__il=name__il,
            name__ilike=name__ilike,
            name__nil=name__nil,
            name__nilike=name__nilike,
            name__notilike=name__notilike,
            name__desc=name__desc,
            name__asc=name__asc,
            stream_url__eq=stream_url__eq,
            stream_url__ne=stream_url__ne,
            stream_url__gt=stream_url__gt,
            stream_url__gte=stream_url__gte,
            stream_url__lt=stream_url__lt,
            stream_url__lte=stream_url__lte,
            stream_url__in=stream_url__in,
            stream_url__nin=stream_url__nin,
            stream_url__notin=stream_url__notin,
            stream_url__isnull=stream_url__isnull,
            stream_url__nisnull=stream_url__nisnull,
            stream_url__isnotnull=stream_url__isnotnull,
            stream_url__l=stream_url__l,
            stream_url__like=stream_url__like,
            stream_url__nl=stream_url__nl,
            stream_url__nlike=stream_url__nlike,
            stream_url__notlike=stream_url__notlike,
            stream_url__il=stream_url__il,
            stream_url__ilike=stream_url__ilike,
            stream_url__nil=stream_url__nil,
            stream_url__nilike=stream_url__nilike,
            stream_url__notilike=stream_url__notilike,
            stream_url__desc=stream_url__desc,
            stream_url__asc=stream_url__asc,
            last_seen__eq=last_seen__eq,
            last_seen__ne=last_seen__ne,
            last_seen__gt=last_seen__gt,
            last_seen__gte=last_seen__gte,
            last_seen__lt=last_seen__lt,
            last_seen__lte=last_seen__lte,
            last_seen__in=last_seen__in,
            last_seen__nin=last_seen__nin,
            last_seen__notin=last_seen__notin,
            last_seen__isnull=last_seen__isnull,
            last_seen__nisnull=last_seen__nisnull,
            last_seen__isnotnull=last_seen__isnotnull,
            last_seen__l=last_seen__l,
            last_seen__like=last_seen__like,
            last_seen__nl=last_seen__nl,
            last_seen__nlike=last_seen__nlike,
            last_seen__notlike=last_seen__notlike,
            last_seen__il=last_seen__il,
            last_seen__ilike=last_seen__ilike,
            last_seen__nil=last_seen__nil,
            last_seen__nilike=last_seen__nilike,
            last_seen__notilike=last_seen__notilike,
            last_seen__desc=last_seen__desc,
            last_seen__asc=last_seen__asc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_cameras_serialize(
        self,
        limit,
        offset,
        id__eq,
        id__ne,
        id__gt,
        id__gte,
        id__lt,
        id__lte,
        id__in,
        id__nin,
        id__notin,
        id__isnull,
        id__nisnull,
        id__isnotnull,
        id__l,
        id__like,
        id__nl,
        id__nlike,
        id__notlike,
        id__il,
        id__ilike,
        id__nil,
        id__nilike,
        id__notilike,
        id__desc,
        id__asc,
        created_at__eq,
        created_at__ne,
        created_at__gt,
        created_at__gte,
        created_at__lt,
        created_at__lte,
        created_at__in,
        created_at__nin,
        created_at__notin,
        created_at__isnull,
        created_at__nisnull,
        created_at__isnotnull,
        created_at__l,
        created_at__like,
        created_at__nl,
        created_at__nlike,
        created_at__notlike,
        created_at__il,
        created_at__ilike,
        created_at__nil,
        created_at__nilike,
        created_at__notilike,
        created_at__desc,
        created_at__asc,
        updated_at__eq,
        updated_at__ne,
        updated_at__gt,
        updated_at__gte,
        updated_at__lt,
        updated_at__lte,
        updated_at__in,
        updated_at__nin,
        updated_at__notin,
        updated_at__isnull,
        updated_at__nisnull,
        updated_at__isnotnull,
        updated_at__l,
        updated_at__like,
        updated_at__nl,
        updated_at__nlike,
        updated_at__notlike,
        updated_at__il,
        updated_at__ilike,
        updated_at__nil,
        updated_at__nilike,
        updated_at__notilike,
        updated_at__desc,
        updated_at__asc,
        deleted_at__eq,
        deleted_at__ne,
        deleted_at__gt,
        deleted_at__gte,
        deleted_at__lt,
        deleted_at__lte,
        deleted_at__in,
        deleted_at__nin,
        deleted_at__notin,
        deleted_at__isnull,
        deleted_at__nisnull,
        deleted_at__isnotnull,
        deleted_at__l,
        deleted_at__like,
        deleted_at__nl,
        deleted_at__nlike,
        deleted_at__notlike,
        deleted_at__il,
        deleted_at__ilike,
        deleted_at__nil,
        deleted_at__nilike,
        deleted_at__notilike,
        deleted_at__desc,
        deleted_at__asc,
        name__eq,
        name__ne,
        name__gt,
        name__gte,
        name__lt,
        name__lte,
        name__in,
        name__nin,
        name__notin,
        name__isnull,
        name__nisnull,
        name__isnotnull,
        name__l,
        name__like,
        name__nl,
        name__nlike,
        name__notlike,
        name__il,
        name__ilike,
        name__nil,
        name__nilike,
        name__notilike,
        name__desc,
        name__asc,
        stream_url__eq,
        stream_url__ne,
        stream_url__gt,
        stream_url__gte,
        stream_url__lt,
        stream_url__lte,
        stream_url__in,
        stream_url__nin,
        stream_url__notin,
        stream_url__isnull,
        stream_url__nisnull,
        stream_url__isnotnull,
        stream_url__l,
        stream_url__like,
        stream_url__nl,
        stream_url__nlike,
        stream_url__notlike,
        stream_url__il,
        stream_url__ilike,
        stream_url__nil,
        stream_url__nilike,
        stream_url__notilike,
        stream_url__desc,
        stream_url__asc,
        last_seen__eq,
        last_seen__ne,
        last_seen__gt,
        last_seen__gte,
        last_seen__lt,
        last_seen__lte,
        last_seen__in,
        last_seen__nin,
        last_seen__notin,
        last_seen__isnull,
        last_seen__nisnull,
        last_seen__isnotnull,
        last_seen__l,
        last_seen__like,
        last_seen__nl,
        last_seen__nlike,
        last_seen__notlike,
        last_seen__il,
        last_seen__ilike,
        last_seen__nil,
        last_seen__nilike,
        last_seen__notilike,
        last_seen__desc,
        last_seen__asc,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if id__eq is not None:
            
            _query_params.append(('id__eq', id__eq))
            
        if id__ne is not None:
            
            _query_params.append(('id__ne', id__ne))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__in is not None:
            
            _query_params.append(('id__in', id__in))
            
        if id__nin is not None:
            
            _query_params.append(('id__nin', id__nin))
            
        if id__notin is not None:
            
            _query_params.append(('id__notin', id__notin))
            
        if id__isnull is not None:
            
            _query_params.append(('id__isnull', id__isnull))
            
        if id__nisnull is not None:
            
            _query_params.append(('id__nisnull', id__nisnull))
            
        if id__isnotnull is not None:
            
            _query_params.append(('id__isnotnull', id__isnotnull))
            
        if id__l is not None:
            
            _query_params.append(('id__l', id__l))
            
        if id__like is not None:
            
            _query_params.append(('id__like', id__like))
            
        if id__nl is not None:
            
            _query_params.append(('id__nl', id__nl))
            
        if id__nlike is not None:
            
            _query_params.append(('id__nlike', id__nlike))
            
        if id__notlike is not None:
            
            _query_params.append(('id__notlike', id__notlike))
            
        if id__il is not None:
            
            _query_params.append(('id__il', id__il))
            
        if id__ilike is not None:
            
            _query_params.append(('id__ilike', id__ilike))
            
        if id__nil is not None:
            
            _query_params.append(('id__nil', id__nil))
            
        if id__nilike is not None:
            
            _query_params.append(('id__nilike', id__nilike))
            
        if id__notilike is not None:
            
            _query_params.append(('id__notilike', id__notilike))
            
        if id__desc is not None:
            
            _query_params.append(('id__desc', id__desc))
            
        if id__asc is not None:
            
            _query_params.append(('id__asc', id__asc))
            
        if created_at__eq is not None:
            if isinstance(created_at__eq, datetime):
                _query_params.append(
                    (
                        'created_at__eq',
                        created_at__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__eq', created_at__eq))
            
        if created_at__ne is not None:
            if isinstance(created_at__ne, datetime):
                _query_params.append(
                    (
                        'created_at__ne',
                        created_at__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__ne', created_at__ne))
            
        if created_at__gt is not None:
            if isinstance(created_at__gt, datetime):
                _query_params.append(
                    (
                        'created_at__gt',
                        created_at__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__gt', created_at__gt))
            
        if created_at__gte is not None:
            if isinstance(created_at__gte, datetime):
                _query_params.append(
                    (
                        'created_at__gte',
                        created_at__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__gte', created_at__gte))
            
        if created_at__lt is not None:
            if isinstance(created_at__lt, datetime):
                _query_params.append(
                    (
                        'created_at__lt',
                        created_at__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__lt', created_at__lt))
            
        if created_at__lte is not None:
            if isinstance(created_at__lte, datetime):
                _query_params.append(
                    (
                        'created_at__lte',
                        created_at__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__lte', created_at__lte))
            
        if created_at__in is not None:
            if isinstance(created_at__in, datetime):
                _query_params.append(
                    (
                        'created_at__in',
                        created_at__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__in', created_at__in))
            
        if created_at__nin is not None:
            if isinstance(created_at__nin, datetime):
                _query_params.append(
                    (
                        'created_at__nin',
                        created_at__nin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__nin', created_at__nin))
            
        if created_at__notin is not None:
            if isinstance(created_at__notin, datetime):
                _query_params.append(
                    (
                        'created_at__notin',
                        created_at__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__notin', created_at__notin))
            
        if created_at__isnull is not None:
            
            _query_params.append(('created_at__isnull', created_at__isnull))
            
        if created_at__nisnull is not None:
            
            _query_params.append(('created_at__nisnull', created_at__nisnull))
            
        if created_at__isnotnull is not None:
            
            _query_params.append(('created_at__isnotnull', created_at__isnotnull))
            
        if created_at__l is not None:
            
            _query_params.append(('created_at__l', created_at__l))
            
        if created_at__like is not None:
            
            _query_params.append(('created_at__like', created_at__like))
            
        if created_at__nl is not None:
            
            _query_params.append(('created_at__nl', created_at__nl))
            
        if created_at__nlike is not None:
            
            _query_params.append(('created_at__nlike', created_at__nlike))
            
        if created_at__notlike is not None:
            
            _query_params.append(('created_at__notlike', created_at__notlike))
            
        if created_at__il is not None:
            
            _query_params.append(('created_at__il', created_at__il))
            
        if created_at__ilike is not None:
            
            _query_params.append(('created_at__ilike', created_at__ilike))
            
        if created_at__nil is not None:
            
            _query_params.append(('created_at__nil', created_at__nil))
            
        if created_at__nilike is not None:
            
            _query_params.append(('created_at__nilike', created_at__nilike))
            
        if created_at__notilike is not None:
            
            _query_params.append(('created_at__notilike', created_at__notilike))
            
        if created_at__desc is not None:
            
            _query_params.append(('created_at__desc', created_at__desc))
            
        if created_at__asc is not None:
            
            _query_params.append(('created_at__asc', created_at__asc))
            
        if updated_at__eq is not None:
            if isinstance(updated_at__eq, datetime):
                _query_params.append(
                    (
                        'updated_at__eq',
                        updated_at__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__eq', updated_at__eq))
            
        if updated_at__ne is not None:
            if isinstance(updated_at__ne, datetime):
                _query_params.append(
                    (
                        'updated_at__ne',
                        updated_at__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__ne', updated_at__ne))
            
        if updated_at__gt is not None:
            if isinstance(updated_at__gt, datetime):
                _query_params.append(
                    (
                        'updated_at__gt',
                        updated_at__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__gt', updated_at__gt))
            
        if updated_at__gte is not None:
            if isinstance(updated_at__gte, datetime):
                _query_params.append(
                    (
                        'updated_at__gte',
                        updated_at__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__gte', updated_at__gte))
            
        if updated_at__lt is not None:
            if isinstance(updated_at__lt, datetime):
                _query_params.append(
                    (
                        'updated_at__lt',
                        updated_at__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__lt', updated_at__lt))
            
        if updated_at__lte is not None:
            if isinstance(updated_at__lte, datetime):
                _query_params.append(
                    (
                        'updated_at__lte',
                        updated_at__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__lte', updated_at__lte))
            
        if updated_at__in is not None:
            if isinstance(updated_at__in, datetime):
                _query_params.append(
                    (
                        'updated_at__in',
                        updated_at__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__in', updated_at__in))
            
        if updated_at__nin is not None:
            if isinstance(updated_at__nin, datetime):
                _query_params.append(
                    (
                        'updated_at__nin',
                        updated_at__nin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__nin', updated_at__nin))
            
        if updated_at__notin is not None:
            if isinstance(updated_at__notin, datetime):
                _query_params.append(
                    (
                        'updated_at__notin',
                        updated_at__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__notin', updated_at__notin))
            
        if updated_at__isnull is not None:
            
            _query_params.append(('updated_at__isnull', updated_at__isnull))
            
        if updated_at__nisnull is not None:
            
            _query_params.append(('updated_at__nisnull', updated_at__nisnull))
            
        if updated_at__isnotnull is not None:
            
            _query_params.append(('updated_at__isnotnull', updated_at__isnotnull))
            
        if updated_at__l is not None:
            
            _query_params.append(('updated_at__l', updated_at__l))
            
        if updated_at__like is not None:
            
            _query_params.append(('updated_at__like', updated_at__like))
            
        if updated_at__nl is not None:
            
            _query_params.append(('updated_at__nl', updated_at__nl))
            
        if updated_at__nlike is not None:
            
            _query_params.append(('updated_at__nlike', updated_at__nlike))
            
        if updated_at__notlike is not None:
            
            _query_params.append(('updated_at__notlike', updated_at__notlike))
            
        if updated_at__il is not None:
            
            _query_params.append(('updated_at__il', updated_at__il))
            
        if updated_at__ilike is not None:
            
            _query_params.append(('updated_at__ilike', updated_at__ilike))
            
        if updated_at__nil is not None:
            
            _query_params.append(('updated_at__nil', updated_at__nil))
            
        if updated_at__nilike is not None:
            
            _query_params.append(('updated_at__nilike', updated_at__nilike))
            
        if updated_at__notilike is not None:
            
            _query_params.append(('updated_at__notilike', updated_at__notilike))
            
        if updated_at__desc is not None:
            
            _query_params.append(('updated_at__desc', updated_at__desc))
            
        if updated_at__asc is not None:
            
            _query_params.append(('updated_at__asc', updated_at__asc))
            
        if deleted_at__eq is not None:
            if isinstance(deleted_at__eq, datetime):
                _query_params.append(
                    (
                        'deleted_at__eq',
                        deleted_at__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__eq', deleted_at__eq))
            
        if deleted_at__ne is not None:
            if isinstance(deleted_at__ne, datetime):
                _query_params.append(
                    (
                        'deleted_at__ne',
                        deleted_at__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__ne', deleted_at__ne))
            
        if deleted_at__gt is not None:
            if isinstance(deleted_at__gt, datetime):
                _query_params.append(
                    (
                        'deleted_at__gt',
                        deleted_at__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__gt', deleted_at__gt))
            
        if deleted_at__gte is not None:
            if isinstance(deleted_at__gte, datetime):
                _query_params.append(
                    (
                        'deleted_at__gte',
                        deleted_at__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__gte', deleted_at__gte))
            
        if deleted_at__lt is not None:
            if isinstance(deleted_at__lt, datetime):
                _query_params.append(
                    (
                        'deleted_at__lt',
                        deleted_at__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__lt', deleted_at__lt))
            
        if deleted_at__lte is not None:
            if isinstance(deleted_at__lte, datetime):
                _query_params.append(
                    (
                        'deleted_at__lte',
                        deleted_at__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__lte', deleted_at__lte))
            
        if deleted_at__in is not None:
            if isinstance(deleted_at__in, datetime):
                _query_params.append(
                    (
                        'deleted_at__in',
                        deleted_at__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__in', deleted_at__in))
            
        if deleted_at__nin is not None:
            if isinstance(deleted_at__nin, datetime):
                _query_params.append(
                    (
                        'deleted_at__nin',
                        deleted_at__nin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__nin', deleted_at__nin))
            
        if deleted_at__notin is not None:
            if isinstance(deleted_at__notin, datetime):
                _query_params.append(
                    (
                        'deleted_at__notin',
                        deleted_at__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__notin', deleted_at__notin))
            
        if deleted_at__isnull is not None:
            
            _query_params.append(('deleted_at__isnull', deleted_at__isnull))
            
        if deleted_at__nisnull is not None:
            
            _query_params.append(('deleted_at__nisnull', deleted_at__nisnull))
            
        if deleted_at__isnotnull is not None:
            
            _query_params.append(('deleted_at__isnotnull', deleted_at__isnotnull))
            
        if deleted_at__l is not None:
            
            _query_params.append(('deleted_at__l', deleted_at__l))
            
        if deleted_at__like is not None:
            
            _query_params.append(('deleted_at__like', deleted_at__like))
            
        if deleted_at__nl is not None:
            
            _query_params.append(('deleted_at__nl', deleted_at__nl))
            
        if deleted_at__nlike is not None:
            
            _query_params.append(('deleted_at__nlike', deleted_at__nlike))
            
        if deleted_at__notlike is not None:
            
            _query_params.append(('deleted_at__notlike', deleted_at__notlike))
            
        if deleted_at__il is not None:
            
            _query_params.append(('deleted_at__il', deleted_at__il))
            
        if deleted_at__ilike is not None:
            
            _query_params.append(('deleted_at__ilike', deleted_at__ilike))
            
        if deleted_at__nil is not None:
            
            _query_params.append(('deleted_at__nil', deleted_at__nil))
            
        if deleted_at__nilike is not None:
            
            _query_params.append(('deleted_at__nilike', deleted_at__nilike))
            
        if deleted_at__notilike is not None:
            
            _query_params.append(('deleted_at__notilike', deleted_at__notilike))
            
        if deleted_at__desc is not None:
            
            _query_params.append(('deleted_at__desc', deleted_at__desc))
            
        if deleted_at__asc is not None:
            
            _query_params.append(('deleted_at__asc', deleted_at__asc))
            
        if name__eq is not None:
            
            _query_params.append(('name__eq', name__eq))
            
        if name__ne is not None:
            
            _query_params.append(('name__ne', name__ne))
            
        if name__gt is not None:
            
            _query_params.append(('name__gt', name__gt))
            
        if name__gte is not None:
            
            _query_params.append(('name__gte', name__gte))
            
        if name__lt is not None:
            
            _query_params.append(('name__lt', name__lt))
            
        if name__lte is not None:
            
            _query_params.append(('name__lte', name__lte))
            
        if name__in is not None:
            
            _query_params.append(('name__in', name__in))
            
        if name__nin is not None:
            
            _query_params.append(('name__nin', name__nin))
            
        if name__notin is not None:
            
            _query_params.append(('name__notin', name__notin))
            
        if name__isnull is not None:
            
            _query_params.append(('name__isnull', name__isnull))
            
        if name__nisnull is not None:
            
            _query_params.append(('name__nisnull', name__nisnull))
            
        if name__isnotnull is not None:
            
            _query_params.append(('name__isnotnull', name__isnotnull))
            
        if name__l is not None:
            
            _query_params.append(('name__l', name__l))
            
        if name__like is not None:
            
            _query_params.append(('name__like', name__like))
            
        if name__nl is not None:
            
            _query_params.append(('name__nl', name__nl))
            
        if name__nlike is not None:
            
            _query_params.append(('name__nlike', name__nlike))
            
        if name__notlike is not None:
            
            _query_params.append(('name__notlike', name__notlike))
            
        if name__il is not None:
            
            _query_params.append(('name__il', name__il))
            
        if name__ilike is not None:
            
            _query_params.append(('name__ilike', name__ilike))
            
        if name__nil is not None:
            
            _query_params.append(('name__nil', name__nil))
            
        if name__nilike is not None:
            
            _query_params.append(('name__nilike', name__nilike))
            
        if name__notilike is not None:
            
            _query_params.append(('name__notilike', name__notilike))
            
        if name__desc is not None:
            
            _query_params.append(('name__desc', name__desc))
            
        if name__asc is not None:
            
            _query_params.append(('name__asc', name__asc))
            
        if stream_url__eq is not None:
            
            _query_params.append(('stream_url__eq', stream_url__eq))
            
        if stream_url__ne is not None:
            
            _query_params.append(('stream_url__ne', stream_url__ne))
            
        if stream_url__gt is not None:
            
            _query_params.append(('stream_url__gt', stream_url__gt))
            
        if stream_url__gte is not None:
            
            _query_params.append(('stream_url__gte', stream_url__gte))
            
        if stream_url__lt is not None:
            
            _query_params.append(('stream_url__lt', stream_url__lt))
            
        if stream_url__lte is not None:
            
            _query_params.append(('stream_url__lte', stream_url__lte))
            
        if stream_url__in is not None:
            
            _query_params.append(('stream_url__in', stream_url__in))
            
        if stream_url__nin is not None:
            
            _query_params.append(('stream_url__nin', stream_url__nin))
            
        if stream_url__notin is not None:
            
            _query_params.append(('stream_url__notin', stream_url__notin))
            
        if stream_url__isnull is not None:
            
            _query_params.append(('stream_url__isnull', stream_url__isnull))
            
        if stream_url__nisnull is not None:
            
            _query_params.append(('stream_url__nisnull', stream_url__nisnull))
            
        if stream_url__isnotnull is not None:
            
            _query_params.append(('stream_url__isnotnull', stream_url__isnotnull))
            
        if stream_url__l is not None:
            
            _query_params.append(('stream_url__l', stream_url__l))
            
        if stream_url__like is not None:
            
            _query_params.append(('stream_url__like', stream_url__like))
            
        if stream_url__nl is not None:
            
            _query_params.append(('stream_url__nl', stream_url__nl))
            
        if stream_url__nlike is not None:
            
            _query_params.append(('stream_url__nlike', stream_url__nlike))
            
        if stream_url__notlike is not None:
            
            _query_params.append(('stream_url__notlike', stream_url__notlike))
            
        if stream_url__il is not None:
            
            _query_params.append(('stream_url__il', stream_url__il))
            
        if stream_url__ilike is not None:
            
            _query_params.append(('stream_url__ilike', stream_url__ilike))
            
        if stream_url__nil is not None:
            
            _query_params.append(('stream_url__nil', stream_url__nil))
            
        if stream_url__nilike is not None:
            
            _query_params.append(('stream_url__nilike', stream_url__nilike))
            
        if stream_url__notilike is not None:
            
            _query_params.append(('stream_url__notilike', stream_url__notilike))
            
        if stream_url__desc is not None:
            
            _query_params.append(('stream_url__desc', stream_url__desc))
            
        if stream_url__asc is not None:
            
            _query_params.append(('stream_url__asc', stream_url__asc))
            
        if last_seen__eq is not None:
            if isinstance(last_seen__eq, datetime):
                _query_params.append(
                    (
                        'last_seen__eq',
                        last_seen__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__eq', last_seen__eq))
            
        if last_seen__ne is not None:
            if isinstance(last_seen__ne, datetime):
                _query_params.append(
                    (
                        'last_seen__ne',
                        last_seen__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__ne', last_seen__ne))
            
        if last_seen__gt is not None:
            if isinstance(last_seen__gt, datetime):
                _query_params.append(
                    (
                        'last_seen__gt',
                        last_seen__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__gt', last_seen__gt))
            
        if last_seen__gte is not None:
            if isinstance(last_seen__gte, datetime):
                _query_params.append(
                    (
                        'last_seen__gte',
                        last_seen__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__gte', last_seen__gte))
            
        if last_seen__lt is not None:
            if isinstance(last_seen__lt, datetime):
                _query_params.append(
                    (
                        'last_seen__lt',
                        last_seen__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__lt', last_seen__lt))
            
        if last_seen__lte is not None:
            if isinstance(last_seen__lte, datetime):
                _query_params.append(
                    (
                        'last_seen__lte',
                        last_seen__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__lte', last_seen__lte))
            
        if last_seen__in is not None:
            if isinstance(last_seen__in, datetime):
                _query_params.append(
                    (
                        'last_seen__in',
                        last_seen__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__in', last_seen__in))
            
        if last_seen__nin is not None:
            if isinstance(last_seen__nin, datetime):
                _query_params.append(
                    (
                        'last_seen__nin',
                        last_seen__nin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__nin', last_seen__nin))
            
        if last_seen__notin is not None:
            if isinstance(last_seen__notin, datetime):
                _query_params.append(
                    (
                        'last_seen__notin',
                        last_seen__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__notin', last_seen__notin))
            
        if last_seen__isnull is not None:
            
            _query_params.append(('last_seen__isnull', last_seen__isnull))
            
        if last_seen__nisnull is not None:
            
            _query_params.append(('last_seen__nisnull', last_seen__nisnull))
            
        if last_seen__isnotnull is not None:
            
            _query_params.append(('last_seen__isnotnull', last_seen__isnotnull))
            
        if last_seen__l is not None:
            
            _query_params.append(('last_seen__l', last_seen__l))
            
        if last_seen__like is not None:
            
            _query_params.append(('last_seen__like', last_seen__like))
            
        if last_seen__nl is not None:
            
            _query_params.append(('last_seen__nl', last_seen__nl))
            
        if last_seen__nlike is not None:
            
            _query_params.append(('last_seen__nlike', last_seen__nlike))
            
        if last_seen__notlike is not None:
            
            _query_params.append(('last_seen__notlike', last_seen__notlike))
            
        if last_seen__il is not None:
            
            _query_params.append(('last_seen__il', last_seen__il))
            
        if last_seen__ilike is not None:
            
            _query_params.append(('last_seen__ilike', last_seen__ilike))
            
        if last_seen__nil is not None:
            
            _query_params.append(('last_seen__nil', last_seen__nil))
            
        if last_seen__nilike is not None:
            
            _query_params.append(('last_seen__nilike', last_seen__nilike))
            
        if last_seen__notilike is not None:
            
            _query_params.append(('last_seen__notilike', last_seen__notilike))
            
        if last_seen__desc is not None:
            
            _query_params.append(('last_seen__desc', last_seen__desc))
            
        if last_seen__asc is not None:
            
            _query_params.append(('last_seen__asc', last_seen__asc))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/cameras',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_camera(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCameras200Response:
        """patch_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_camera_with_http_info(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCameras200Response]:
        """patch_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_camera_without_preload_content(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_camera_serialize(
        self,
        primary_key,
        camera,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if primary_key is not None:
            _path_params['primaryKey'] = primary_key
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if camera is not None:
            _body_params = camera


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/cameras/{primaryKey}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_cameras(
        self,
        camera: List[Camera],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCameras200Response:
        """post_cameras


        :param camera: (required)
        :type camera: List[Camera]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_cameras_serialize(
            camera=camera,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_cameras_with_http_info(
        self,
        camera: List[Camera],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCameras200Response]:
        """post_cameras


        :param camera: (required)
        :type camera: List[Camera]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_cameras_serialize(
            camera=camera,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_cameras_without_preload_content(
        self,
        camera: List[Camera],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_cameras


        :param camera: (required)
        :type camera: List[Camera]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_cameras_serialize(
            camera=camera,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_cameras_serialize(
        self,
        camera,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'Camera': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if camera is not None:
            _body_params = camera


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/cameras',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_camera(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCameras200Response:
        """put_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_camera_with_http_info(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCameras200Response]:
        """put_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_camera_without_preload_content(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_camera_serialize(
        self,
        primary_key,
        camera,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if primary_key is not None:
            _path_params['primaryKey'] = primary_key
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if camera is not None:
            _body_params = camera


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/cameras/{primaryKey}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


