# coding: utf-8

"""
    Djangolang

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictInt, StrictStr
from typing import Any, List, Optional
from typing_extensions import Annotated
from openapi_client.models.camera import Camera
from openapi_client.models.get_cameras200_response import GetCameras200Response

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class CameraApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def delete_camera(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """delete_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_camera_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_camera_with_http_info(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """delete_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_camera_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_camera_without_preload_content(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_camera_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_camera_serialize(
        self,
        primary_key,
        depth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if primary_key is not None:
            _path_params['primaryKey'] = primary_key
        # process the query parameters
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/cameras/{primaryKey}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_camera(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCameras200Response:
        """get_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_camera_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_camera_with_http_info(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCameras200Response]:
        """get_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_camera_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_camera_without_preload_content(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_camera_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_camera_serialize(
        self,
        primary_key,
        depth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if primary_key is not None:
            _path_params['primaryKey'] = primary_key
        # process the query parameters
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/cameras/{primaryKey}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_cameras(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="SQL LIMIT operator")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="SQL OFFSET operator")] = None,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        id__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        id__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        id__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        id__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        created_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        created_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        created_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        created_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        created_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        created_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        created_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        created_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        updated_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        updated_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        updated_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        updated_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        updated_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        updated_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        updated_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        updated_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        deleted_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        deleted_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        deleted_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        deleted_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        deleted_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        deleted_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        deleted_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        deleted_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        name__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        name__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        name__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        name__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        name__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        name__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        name__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        name__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        name__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        name__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        name__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        name__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        name__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        name__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_url__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        stream_url__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        stream_url__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        stream_url__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        stream_url__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        stream_url__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        stream_url__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        stream_url__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        stream_url__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_url__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        last_seen__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        last_seen__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        last_seen__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        last_seen__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        last_seen__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        last_seen__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        last_seen__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        last_seen__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        last_seen__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        last_seen__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        segment_producer_claimed_until__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        segment_producer_claimed_until__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        segment_producer_claimed_until__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        segment_producer_claimed_until__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        stream_producer_claimed_until__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        stream_producer_claimed_until__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        stream_producer_claimed_until__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        stream_producer_claimed_until__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCameras200Response:
        """get_cameras


        :param limit: SQL LIMIT operator
        :type limit: int
        :param offset: SQL OFFSET operator
        :type offset: int
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param id__eq: SQL = comparison
        :type id__eq: str
        :param id__ne: SQL != comparison
        :type id__ne: str
        :param id__gt: SQL > comparison, may not work with all column types
        :type id__gt: str
        :param id__gte: SQL >= comparison, may not work with all column types
        :type id__gte: str
        :param id__lt: SQL < comparison, may not work with all column types
        :type id__lt: str
        :param id__lte: SQL <= comparison, may not work with all column types
        :type id__lte: str
        :param id__in: SQL IN comparison, permits comma-separated values
        :type id__in: str
        :param id__notin: SQL NOT IN comparison, permits comma-separated values
        :type id__notin: str
        :param id__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type id__isnull: str
        :param id__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type id__isnotnull: str
        :param id__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type id__isfalse: str
        :param id__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type id__istrue: str
        :param id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__like: str
        :param id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notlike: str
        :param id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__ilike: str
        :param id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notilike: str
        :param id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type id__desc: str
        :param id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type id__asc: str
        :param created_at__eq: SQL = comparison
        :type created_at__eq: datetime
        :param created_at__ne: SQL != comparison
        :type created_at__ne: datetime
        :param created_at__gt: SQL > comparison, may not work with all column types
        :type created_at__gt: datetime
        :param created_at__gte: SQL >= comparison, may not work with all column types
        :type created_at__gte: datetime
        :param created_at__lt: SQL < comparison, may not work with all column types
        :type created_at__lt: datetime
        :param created_at__lte: SQL <= comparison, may not work with all column types
        :type created_at__lte: datetime
        :param created_at__in: SQL IN comparison, permits comma-separated values
        :type created_at__in: datetime
        :param created_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type created_at__notin: datetime
        :param created_at__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type created_at__isnull: str
        :param created_at__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type created_at__isnotnull: str
        :param created_at__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type created_at__isfalse: str
        :param created_at__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type created_at__istrue: str
        :param created_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__like: str
        :param created_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notlike: str
        :param created_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__ilike: str
        :param created_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notilike: str
        :param created_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type created_at__desc: str
        :param created_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type created_at__asc: str
        :param updated_at__eq: SQL = comparison
        :type updated_at__eq: datetime
        :param updated_at__ne: SQL != comparison
        :type updated_at__ne: datetime
        :param updated_at__gt: SQL > comparison, may not work with all column types
        :type updated_at__gt: datetime
        :param updated_at__gte: SQL >= comparison, may not work with all column types
        :type updated_at__gte: datetime
        :param updated_at__lt: SQL < comparison, may not work with all column types
        :type updated_at__lt: datetime
        :param updated_at__lte: SQL <= comparison, may not work with all column types
        :type updated_at__lte: datetime
        :param updated_at__in: SQL IN comparison, permits comma-separated values
        :type updated_at__in: datetime
        :param updated_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type updated_at__notin: datetime
        :param updated_at__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type updated_at__isnull: str
        :param updated_at__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type updated_at__isnotnull: str
        :param updated_at__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type updated_at__isfalse: str
        :param updated_at__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type updated_at__istrue: str
        :param updated_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__like: str
        :param updated_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notlike: str
        :param updated_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__ilike: str
        :param updated_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notilike: str
        :param updated_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type updated_at__desc: str
        :param updated_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type updated_at__asc: str
        :param deleted_at__eq: SQL = comparison
        :type deleted_at__eq: datetime
        :param deleted_at__ne: SQL != comparison
        :type deleted_at__ne: datetime
        :param deleted_at__gt: SQL > comparison, may not work with all column types
        :type deleted_at__gt: datetime
        :param deleted_at__gte: SQL >= comparison, may not work with all column types
        :type deleted_at__gte: datetime
        :param deleted_at__lt: SQL < comparison, may not work with all column types
        :type deleted_at__lt: datetime
        :param deleted_at__lte: SQL <= comparison, may not work with all column types
        :type deleted_at__lte: datetime
        :param deleted_at__in: SQL IN comparison, permits comma-separated values
        :type deleted_at__in: datetime
        :param deleted_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type deleted_at__notin: datetime
        :param deleted_at__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__isnull: str
        :param deleted_at__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__isnotnull: str
        :param deleted_at__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__isfalse: str
        :param deleted_at__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__istrue: str
        :param deleted_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__like: str
        :param deleted_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notlike: str
        :param deleted_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__ilike: str
        :param deleted_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notilike: str
        :param deleted_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__desc: str
        :param deleted_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__asc: str
        :param name__eq: SQL = comparison
        :type name__eq: str
        :param name__ne: SQL != comparison
        :type name__ne: str
        :param name__gt: SQL > comparison, may not work with all column types
        :type name__gt: str
        :param name__gte: SQL >= comparison, may not work with all column types
        :type name__gte: str
        :param name__lt: SQL < comparison, may not work with all column types
        :type name__lt: str
        :param name__lte: SQL <= comparison, may not work with all column types
        :type name__lte: str
        :param name__in: SQL IN comparison, permits comma-separated values
        :type name__in: str
        :param name__notin: SQL NOT IN comparison, permits comma-separated values
        :type name__notin: str
        :param name__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type name__isnull: str
        :param name__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type name__isnotnull: str
        :param name__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type name__isfalse: str
        :param name__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type name__istrue: str
        :param name__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__like: str
        :param name__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__notlike: str
        :param name__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__ilike: str
        :param name__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__notilike: str
        :param name__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type name__desc: str
        :param name__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type name__asc: str
        :param stream_url__eq: SQL = comparison
        :type stream_url__eq: str
        :param stream_url__ne: SQL != comparison
        :type stream_url__ne: str
        :param stream_url__gt: SQL > comparison, may not work with all column types
        :type stream_url__gt: str
        :param stream_url__gte: SQL >= comparison, may not work with all column types
        :type stream_url__gte: str
        :param stream_url__lt: SQL < comparison, may not work with all column types
        :type stream_url__lt: str
        :param stream_url__lte: SQL <= comparison, may not work with all column types
        :type stream_url__lte: str
        :param stream_url__in: SQL IN comparison, permits comma-separated values
        :type stream_url__in: str
        :param stream_url__notin: SQL NOT IN comparison, permits comma-separated values
        :type stream_url__notin: str
        :param stream_url__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type stream_url__isnull: str
        :param stream_url__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type stream_url__isnotnull: str
        :param stream_url__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type stream_url__isfalse: str
        :param stream_url__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type stream_url__istrue: str
        :param stream_url__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__like: str
        :param stream_url__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__notlike: str
        :param stream_url__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__ilike: str
        :param stream_url__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__notilike: str
        :param stream_url__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type stream_url__desc: str
        :param stream_url__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type stream_url__asc: str
        :param last_seen__eq: SQL = comparison
        :type last_seen__eq: datetime
        :param last_seen__ne: SQL != comparison
        :type last_seen__ne: datetime
        :param last_seen__gt: SQL > comparison, may not work with all column types
        :type last_seen__gt: datetime
        :param last_seen__gte: SQL >= comparison, may not work with all column types
        :type last_seen__gte: datetime
        :param last_seen__lt: SQL < comparison, may not work with all column types
        :type last_seen__lt: datetime
        :param last_seen__lte: SQL <= comparison, may not work with all column types
        :type last_seen__lte: datetime
        :param last_seen__in: SQL IN comparison, permits comma-separated values
        :type last_seen__in: datetime
        :param last_seen__notin: SQL NOT IN comparison, permits comma-separated values
        :type last_seen__notin: datetime
        :param last_seen__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type last_seen__isnull: str
        :param last_seen__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type last_seen__isnotnull: str
        :param last_seen__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type last_seen__isfalse: str
        :param last_seen__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type last_seen__istrue: str
        :param last_seen__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__like: str
        :param last_seen__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__notlike: str
        :param last_seen__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__ilike: str
        :param last_seen__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__notilike: str
        :param last_seen__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type last_seen__desc: str
        :param last_seen__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type last_seen__asc: str
        :param segment_producer_claimed_until__eq: SQL = comparison
        :type segment_producer_claimed_until__eq: datetime
        :param segment_producer_claimed_until__ne: SQL != comparison
        :type segment_producer_claimed_until__ne: datetime
        :param segment_producer_claimed_until__gt: SQL > comparison, may not work with all column types
        :type segment_producer_claimed_until__gt: datetime
        :param segment_producer_claimed_until__gte: SQL >= comparison, may not work with all column types
        :type segment_producer_claimed_until__gte: datetime
        :param segment_producer_claimed_until__lt: SQL < comparison, may not work with all column types
        :type segment_producer_claimed_until__lt: datetime
        :param segment_producer_claimed_until__lte: SQL <= comparison, may not work with all column types
        :type segment_producer_claimed_until__lte: datetime
        :param segment_producer_claimed_until__in: SQL IN comparison, permits comma-separated values
        :type segment_producer_claimed_until__in: datetime
        :param segment_producer_claimed_until__notin: SQL NOT IN comparison, permits comma-separated values
        :type segment_producer_claimed_until__notin: datetime
        :param segment_producer_claimed_until__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__isnull: str
        :param segment_producer_claimed_until__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__isnotnull: str
        :param segment_producer_claimed_until__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__isfalse: str
        :param segment_producer_claimed_until__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__istrue: str
        :param segment_producer_claimed_until__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__like: str
        :param segment_producer_claimed_until__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__notlike: str
        :param segment_producer_claimed_until__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__ilike: str
        :param segment_producer_claimed_until__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__notilike: str
        :param segment_producer_claimed_until__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__desc: str
        :param segment_producer_claimed_until__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__asc: str
        :param stream_producer_claimed_until__eq: SQL = comparison
        :type stream_producer_claimed_until__eq: datetime
        :param stream_producer_claimed_until__ne: SQL != comparison
        :type stream_producer_claimed_until__ne: datetime
        :param stream_producer_claimed_until__gt: SQL > comparison, may not work with all column types
        :type stream_producer_claimed_until__gt: datetime
        :param stream_producer_claimed_until__gte: SQL >= comparison, may not work with all column types
        :type stream_producer_claimed_until__gte: datetime
        :param stream_producer_claimed_until__lt: SQL < comparison, may not work with all column types
        :type stream_producer_claimed_until__lt: datetime
        :param stream_producer_claimed_until__lte: SQL <= comparison, may not work with all column types
        :type stream_producer_claimed_until__lte: datetime
        :param stream_producer_claimed_until__in: SQL IN comparison, permits comma-separated values
        :type stream_producer_claimed_until__in: datetime
        :param stream_producer_claimed_until__notin: SQL NOT IN comparison, permits comma-separated values
        :type stream_producer_claimed_until__notin: datetime
        :param stream_producer_claimed_until__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__isnull: str
        :param stream_producer_claimed_until__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__isnotnull: str
        :param stream_producer_claimed_until__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__isfalse: str
        :param stream_producer_claimed_until__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__istrue: str
        :param stream_producer_claimed_until__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__like: str
        :param stream_producer_claimed_until__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__notlike: str
        :param stream_producer_claimed_until__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__ilike: str
        :param stream_producer_claimed_until__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__notilike: str
        :param stream_producer_claimed_until__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__desc: str
        :param stream_producer_claimed_until__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__asc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_cameras_serialize(
            limit=limit,
            offset=offset,
            depth=depth,
            id__eq=id__eq,
            id__ne=id__ne,
            id__gt=id__gt,
            id__gte=id__gte,
            id__lt=id__lt,
            id__lte=id__lte,
            id__in=id__in,
            id__notin=id__notin,
            id__isnull=id__isnull,
            id__isnotnull=id__isnotnull,
            id__isfalse=id__isfalse,
            id__istrue=id__istrue,
            id__like=id__like,
            id__notlike=id__notlike,
            id__ilike=id__ilike,
            id__notilike=id__notilike,
            id__desc=id__desc,
            id__asc=id__asc,
            created_at__eq=created_at__eq,
            created_at__ne=created_at__ne,
            created_at__gt=created_at__gt,
            created_at__gte=created_at__gte,
            created_at__lt=created_at__lt,
            created_at__lte=created_at__lte,
            created_at__in=created_at__in,
            created_at__notin=created_at__notin,
            created_at__isnull=created_at__isnull,
            created_at__isnotnull=created_at__isnotnull,
            created_at__isfalse=created_at__isfalse,
            created_at__istrue=created_at__istrue,
            created_at__like=created_at__like,
            created_at__notlike=created_at__notlike,
            created_at__ilike=created_at__ilike,
            created_at__notilike=created_at__notilike,
            created_at__desc=created_at__desc,
            created_at__asc=created_at__asc,
            updated_at__eq=updated_at__eq,
            updated_at__ne=updated_at__ne,
            updated_at__gt=updated_at__gt,
            updated_at__gte=updated_at__gte,
            updated_at__lt=updated_at__lt,
            updated_at__lte=updated_at__lte,
            updated_at__in=updated_at__in,
            updated_at__notin=updated_at__notin,
            updated_at__isnull=updated_at__isnull,
            updated_at__isnotnull=updated_at__isnotnull,
            updated_at__isfalse=updated_at__isfalse,
            updated_at__istrue=updated_at__istrue,
            updated_at__like=updated_at__like,
            updated_at__notlike=updated_at__notlike,
            updated_at__ilike=updated_at__ilike,
            updated_at__notilike=updated_at__notilike,
            updated_at__desc=updated_at__desc,
            updated_at__asc=updated_at__asc,
            deleted_at__eq=deleted_at__eq,
            deleted_at__ne=deleted_at__ne,
            deleted_at__gt=deleted_at__gt,
            deleted_at__gte=deleted_at__gte,
            deleted_at__lt=deleted_at__lt,
            deleted_at__lte=deleted_at__lte,
            deleted_at__in=deleted_at__in,
            deleted_at__notin=deleted_at__notin,
            deleted_at__isnull=deleted_at__isnull,
            deleted_at__isnotnull=deleted_at__isnotnull,
            deleted_at__isfalse=deleted_at__isfalse,
            deleted_at__istrue=deleted_at__istrue,
            deleted_at__like=deleted_at__like,
            deleted_at__notlike=deleted_at__notlike,
            deleted_at__ilike=deleted_at__ilike,
            deleted_at__notilike=deleted_at__notilike,
            deleted_at__desc=deleted_at__desc,
            deleted_at__asc=deleted_at__asc,
            name__eq=name__eq,
            name__ne=name__ne,
            name__gt=name__gt,
            name__gte=name__gte,
            name__lt=name__lt,
            name__lte=name__lte,
            name__in=name__in,
            name__notin=name__notin,
            name__isnull=name__isnull,
            name__isnotnull=name__isnotnull,
            name__isfalse=name__isfalse,
            name__istrue=name__istrue,
            name__like=name__like,
            name__notlike=name__notlike,
            name__ilike=name__ilike,
            name__notilike=name__notilike,
            name__desc=name__desc,
            name__asc=name__asc,
            stream_url__eq=stream_url__eq,
            stream_url__ne=stream_url__ne,
            stream_url__gt=stream_url__gt,
            stream_url__gte=stream_url__gte,
            stream_url__lt=stream_url__lt,
            stream_url__lte=stream_url__lte,
            stream_url__in=stream_url__in,
            stream_url__notin=stream_url__notin,
            stream_url__isnull=stream_url__isnull,
            stream_url__isnotnull=stream_url__isnotnull,
            stream_url__isfalse=stream_url__isfalse,
            stream_url__istrue=stream_url__istrue,
            stream_url__like=stream_url__like,
            stream_url__notlike=stream_url__notlike,
            stream_url__ilike=stream_url__ilike,
            stream_url__notilike=stream_url__notilike,
            stream_url__desc=stream_url__desc,
            stream_url__asc=stream_url__asc,
            last_seen__eq=last_seen__eq,
            last_seen__ne=last_seen__ne,
            last_seen__gt=last_seen__gt,
            last_seen__gte=last_seen__gte,
            last_seen__lt=last_seen__lt,
            last_seen__lte=last_seen__lte,
            last_seen__in=last_seen__in,
            last_seen__notin=last_seen__notin,
            last_seen__isnull=last_seen__isnull,
            last_seen__isnotnull=last_seen__isnotnull,
            last_seen__isfalse=last_seen__isfalse,
            last_seen__istrue=last_seen__istrue,
            last_seen__like=last_seen__like,
            last_seen__notlike=last_seen__notlike,
            last_seen__ilike=last_seen__ilike,
            last_seen__notilike=last_seen__notilike,
            last_seen__desc=last_seen__desc,
            last_seen__asc=last_seen__asc,
            segment_producer_claimed_until__eq=segment_producer_claimed_until__eq,
            segment_producer_claimed_until__ne=segment_producer_claimed_until__ne,
            segment_producer_claimed_until__gt=segment_producer_claimed_until__gt,
            segment_producer_claimed_until__gte=segment_producer_claimed_until__gte,
            segment_producer_claimed_until__lt=segment_producer_claimed_until__lt,
            segment_producer_claimed_until__lte=segment_producer_claimed_until__lte,
            segment_producer_claimed_until__in=segment_producer_claimed_until__in,
            segment_producer_claimed_until__notin=segment_producer_claimed_until__notin,
            segment_producer_claimed_until__isnull=segment_producer_claimed_until__isnull,
            segment_producer_claimed_until__isnotnull=segment_producer_claimed_until__isnotnull,
            segment_producer_claimed_until__isfalse=segment_producer_claimed_until__isfalse,
            segment_producer_claimed_until__istrue=segment_producer_claimed_until__istrue,
            segment_producer_claimed_until__like=segment_producer_claimed_until__like,
            segment_producer_claimed_until__notlike=segment_producer_claimed_until__notlike,
            segment_producer_claimed_until__ilike=segment_producer_claimed_until__ilike,
            segment_producer_claimed_until__notilike=segment_producer_claimed_until__notilike,
            segment_producer_claimed_until__desc=segment_producer_claimed_until__desc,
            segment_producer_claimed_until__asc=segment_producer_claimed_until__asc,
            stream_producer_claimed_until__eq=stream_producer_claimed_until__eq,
            stream_producer_claimed_until__ne=stream_producer_claimed_until__ne,
            stream_producer_claimed_until__gt=stream_producer_claimed_until__gt,
            stream_producer_claimed_until__gte=stream_producer_claimed_until__gte,
            stream_producer_claimed_until__lt=stream_producer_claimed_until__lt,
            stream_producer_claimed_until__lte=stream_producer_claimed_until__lte,
            stream_producer_claimed_until__in=stream_producer_claimed_until__in,
            stream_producer_claimed_until__notin=stream_producer_claimed_until__notin,
            stream_producer_claimed_until__isnull=stream_producer_claimed_until__isnull,
            stream_producer_claimed_until__isnotnull=stream_producer_claimed_until__isnotnull,
            stream_producer_claimed_until__isfalse=stream_producer_claimed_until__isfalse,
            stream_producer_claimed_until__istrue=stream_producer_claimed_until__istrue,
            stream_producer_claimed_until__like=stream_producer_claimed_until__like,
            stream_producer_claimed_until__notlike=stream_producer_claimed_until__notlike,
            stream_producer_claimed_until__ilike=stream_producer_claimed_until__ilike,
            stream_producer_claimed_until__notilike=stream_producer_claimed_until__notilike,
            stream_producer_claimed_until__desc=stream_producer_claimed_until__desc,
            stream_producer_claimed_until__asc=stream_producer_claimed_until__asc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_cameras_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="SQL LIMIT operator")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="SQL OFFSET operator")] = None,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        id__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        id__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        id__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        id__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        created_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        created_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        created_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        created_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        created_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        created_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        created_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        created_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        updated_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        updated_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        updated_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        updated_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        updated_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        updated_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        updated_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        updated_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        deleted_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        deleted_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        deleted_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        deleted_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        deleted_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        deleted_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        deleted_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        deleted_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        name__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        name__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        name__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        name__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        name__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        name__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        name__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        name__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        name__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        name__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        name__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        name__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        name__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        name__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_url__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        stream_url__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        stream_url__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        stream_url__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        stream_url__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        stream_url__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        stream_url__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        stream_url__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        stream_url__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_url__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        last_seen__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        last_seen__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        last_seen__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        last_seen__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        last_seen__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        last_seen__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        last_seen__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        last_seen__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        last_seen__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        last_seen__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        segment_producer_claimed_until__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        segment_producer_claimed_until__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        segment_producer_claimed_until__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        segment_producer_claimed_until__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        stream_producer_claimed_until__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        stream_producer_claimed_until__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        stream_producer_claimed_until__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        stream_producer_claimed_until__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCameras200Response]:
        """get_cameras


        :param limit: SQL LIMIT operator
        :type limit: int
        :param offset: SQL OFFSET operator
        :type offset: int
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param id__eq: SQL = comparison
        :type id__eq: str
        :param id__ne: SQL != comparison
        :type id__ne: str
        :param id__gt: SQL > comparison, may not work with all column types
        :type id__gt: str
        :param id__gte: SQL >= comparison, may not work with all column types
        :type id__gte: str
        :param id__lt: SQL < comparison, may not work with all column types
        :type id__lt: str
        :param id__lte: SQL <= comparison, may not work with all column types
        :type id__lte: str
        :param id__in: SQL IN comparison, permits comma-separated values
        :type id__in: str
        :param id__notin: SQL NOT IN comparison, permits comma-separated values
        :type id__notin: str
        :param id__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type id__isnull: str
        :param id__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type id__isnotnull: str
        :param id__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type id__isfalse: str
        :param id__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type id__istrue: str
        :param id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__like: str
        :param id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notlike: str
        :param id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__ilike: str
        :param id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notilike: str
        :param id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type id__desc: str
        :param id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type id__asc: str
        :param created_at__eq: SQL = comparison
        :type created_at__eq: datetime
        :param created_at__ne: SQL != comparison
        :type created_at__ne: datetime
        :param created_at__gt: SQL > comparison, may not work with all column types
        :type created_at__gt: datetime
        :param created_at__gte: SQL >= comparison, may not work with all column types
        :type created_at__gte: datetime
        :param created_at__lt: SQL < comparison, may not work with all column types
        :type created_at__lt: datetime
        :param created_at__lte: SQL <= comparison, may not work with all column types
        :type created_at__lte: datetime
        :param created_at__in: SQL IN comparison, permits comma-separated values
        :type created_at__in: datetime
        :param created_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type created_at__notin: datetime
        :param created_at__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type created_at__isnull: str
        :param created_at__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type created_at__isnotnull: str
        :param created_at__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type created_at__isfalse: str
        :param created_at__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type created_at__istrue: str
        :param created_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__like: str
        :param created_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notlike: str
        :param created_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__ilike: str
        :param created_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notilike: str
        :param created_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type created_at__desc: str
        :param created_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type created_at__asc: str
        :param updated_at__eq: SQL = comparison
        :type updated_at__eq: datetime
        :param updated_at__ne: SQL != comparison
        :type updated_at__ne: datetime
        :param updated_at__gt: SQL > comparison, may not work with all column types
        :type updated_at__gt: datetime
        :param updated_at__gte: SQL >= comparison, may not work with all column types
        :type updated_at__gte: datetime
        :param updated_at__lt: SQL < comparison, may not work with all column types
        :type updated_at__lt: datetime
        :param updated_at__lte: SQL <= comparison, may not work with all column types
        :type updated_at__lte: datetime
        :param updated_at__in: SQL IN comparison, permits comma-separated values
        :type updated_at__in: datetime
        :param updated_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type updated_at__notin: datetime
        :param updated_at__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type updated_at__isnull: str
        :param updated_at__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type updated_at__isnotnull: str
        :param updated_at__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type updated_at__isfalse: str
        :param updated_at__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type updated_at__istrue: str
        :param updated_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__like: str
        :param updated_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notlike: str
        :param updated_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__ilike: str
        :param updated_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notilike: str
        :param updated_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type updated_at__desc: str
        :param updated_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type updated_at__asc: str
        :param deleted_at__eq: SQL = comparison
        :type deleted_at__eq: datetime
        :param deleted_at__ne: SQL != comparison
        :type deleted_at__ne: datetime
        :param deleted_at__gt: SQL > comparison, may not work with all column types
        :type deleted_at__gt: datetime
        :param deleted_at__gte: SQL >= comparison, may not work with all column types
        :type deleted_at__gte: datetime
        :param deleted_at__lt: SQL < comparison, may not work with all column types
        :type deleted_at__lt: datetime
        :param deleted_at__lte: SQL <= comparison, may not work with all column types
        :type deleted_at__lte: datetime
        :param deleted_at__in: SQL IN comparison, permits comma-separated values
        :type deleted_at__in: datetime
        :param deleted_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type deleted_at__notin: datetime
        :param deleted_at__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__isnull: str
        :param deleted_at__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__isnotnull: str
        :param deleted_at__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__isfalse: str
        :param deleted_at__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__istrue: str
        :param deleted_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__like: str
        :param deleted_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notlike: str
        :param deleted_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__ilike: str
        :param deleted_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notilike: str
        :param deleted_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__desc: str
        :param deleted_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__asc: str
        :param name__eq: SQL = comparison
        :type name__eq: str
        :param name__ne: SQL != comparison
        :type name__ne: str
        :param name__gt: SQL > comparison, may not work with all column types
        :type name__gt: str
        :param name__gte: SQL >= comparison, may not work with all column types
        :type name__gte: str
        :param name__lt: SQL < comparison, may not work with all column types
        :type name__lt: str
        :param name__lte: SQL <= comparison, may not work with all column types
        :type name__lte: str
        :param name__in: SQL IN comparison, permits comma-separated values
        :type name__in: str
        :param name__notin: SQL NOT IN comparison, permits comma-separated values
        :type name__notin: str
        :param name__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type name__isnull: str
        :param name__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type name__isnotnull: str
        :param name__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type name__isfalse: str
        :param name__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type name__istrue: str
        :param name__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__like: str
        :param name__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__notlike: str
        :param name__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__ilike: str
        :param name__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__notilike: str
        :param name__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type name__desc: str
        :param name__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type name__asc: str
        :param stream_url__eq: SQL = comparison
        :type stream_url__eq: str
        :param stream_url__ne: SQL != comparison
        :type stream_url__ne: str
        :param stream_url__gt: SQL > comparison, may not work with all column types
        :type stream_url__gt: str
        :param stream_url__gte: SQL >= comparison, may not work with all column types
        :type stream_url__gte: str
        :param stream_url__lt: SQL < comparison, may not work with all column types
        :type stream_url__lt: str
        :param stream_url__lte: SQL <= comparison, may not work with all column types
        :type stream_url__lte: str
        :param stream_url__in: SQL IN comparison, permits comma-separated values
        :type stream_url__in: str
        :param stream_url__notin: SQL NOT IN comparison, permits comma-separated values
        :type stream_url__notin: str
        :param stream_url__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type stream_url__isnull: str
        :param stream_url__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type stream_url__isnotnull: str
        :param stream_url__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type stream_url__isfalse: str
        :param stream_url__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type stream_url__istrue: str
        :param stream_url__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__like: str
        :param stream_url__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__notlike: str
        :param stream_url__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__ilike: str
        :param stream_url__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__notilike: str
        :param stream_url__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type stream_url__desc: str
        :param stream_url__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type stream_url__asc: str
        :param last_seen__eq: SQL = comparison
        :type last_seen__eq: datetime
        :param last_seen__ne: SQL != comparison
        :type last_seen__ne: datetime
        :param last_seen__gt: SQL > comparison, may not work with all column types
        :type last_seen__gt: datetime
        :param last_seen__gte: SQL >= comparison, may not work with all column types
        :type last_seen__gte: datetime
        :param last_seen__lt: SQL < comparison, may not work with all column types
        :type last_seen__lt: datetime
        :param last_seen__lte: SQL <= comparison, may not work with all column types
        :type last_seen__lte: datetime
        :param last_seen__in: SQL IN comparison, permits comma-separated values
        :type last_seen__in: datetime
        :param last_seen__notin: SQL NOT IN comparison, permits comma-separated values
        :type last_seen__notin: datetime
        :param last_seen__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type last_seen__isnull: str
        :param last_seen__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type last_seen__isnotnull: str
        :param last_seen__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type last_seen__isfalse: str
        :param last_seen__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type last_seen__istrue: str
        :param last_seen__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__like: str
        :param last_seen__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__notlike: str
        :param last_seen__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__ilike: str
        :param last_seen__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__notilike: str
        :param last_seen__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type last_seen__desc: str
        :param last_seen__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type last_seen__asc: str
        :param segment_producer_claimed_until__eq: SQL = comparison
        :type segment_producer_claimed_until__eq: datetime
        :param segment_producer_claimed_until__ne: SQL != comparison
        :type segment_producer_claimed_until__ne: datetime
        :param segment_producer_claimed_until__gt: SQL > comparison, may not work with all column types
        :type segment_producer_claimed_until__gt: datetime
        :param segment_producer_claimed_until__gte: SQL >= comparison, may not work with all column types
        :type segment_producer_claimed_until__gte: datetime
        :param segment_producer_claimed_until__lt: SQL < comparison, may not work with all column types
        :type segment_producer_claimed_until__lt: datetime
        :param segment_producer_claimed_until__lte: SQL <= comparison, may not work with all column types
        :type segment_producer_claimed_until__lte: datetime
        :param segment_producer_claimed_until__in: SQL IN comparison, permits comma-separated values
        :type segment_producer_claimed_until__in: datetime
        :param segment_producer_claimed_until__notin: SQL NOT IN comparison, permits comma-separated values
        :type segment_producer_claimed_until__notin: datetime
        :param segment_producer_claimed_until__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__isnull: str
        :param segment_producer_claimed_until__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__isnotnull: str
        :param segment_producer_claimed_until__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__isfalse: str
        :param segment_producer_claimed_until__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__istrue: str
        :param segment_producer_claimed_until__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__like: str
        :param segment_producer_claimed_until__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__notlike: str
        :param segment_producer_claimed_until__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__ilike: str
        :param segment_producer_claimed_until__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__notilike: str
        :param segment_producer_claimed_until__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__desc: str
        :param segment_producer_claimed_until__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__asc: str
        :param stream_producer_claimed_until__eq: SQL = comparison
        :type stream_producer_claimed_until__eq: datetime
        :param stream_producer_claimed_until__ne: SQL != comparison
        :type stream_producer_claimed_until__ne: datetime
        :param stream_producer_claimed_until__gt: SQL > comparison, may not work with all column types
        :type stream_producer_claimed_until__gt: datetime
        :param stream_producer_claimed_until__gte: SQL >= comparison, may not work with all column types
        :type stream_producer_claimed_until__gte: datetime
        :param stream_producer_claimed_until__lt: SQL < comparison, may not work with all column types
        :type stream_producer_claimed_until__lt: datetime
        :param stream_producer_claimed_until__lte: SQL <= comparison, may not work with all column types
        :type stream_producer_claimed_until__lte: datetime
        :param stream_producer_claimed_until__in: SQL IN comparison, permits comma-separated values
        :type stream_producer_claimed_until__in: datetime
        :param stream_producer_claimed_until__notin: SQL NOT IN comparison, permits comma-separated values
        :type stream_producer_claimed_until__notin: datetime
        :param stream_producer_claimed_until__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__isnull: str
        :param stream_producer_claimed_until__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__isnotnull: str
        :param stream_producer_claimed_until__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__isfalse: str
        :param stream_producer_claimed_until__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__istrue: str
        :param stream_producer_claimed_until__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__like: str
        :param stream_producer_claimed_until__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__notlike: str
        :param stream_producer_claimed_until__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__ilike: str
        :param stream_producer_claimed_until__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__notilike: str
        :param stream_producer_claimed_until__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__desc: str
        :param stream_producer_claimed_until__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__asc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_cameras_serialize(
            limit=limit,
            offset=offset,
            depth=depth,
            id__eq=id__eq,
            id__ne=id__ne,
            id__gt=id__gt,
            id__gte=id__gte,
            id__lt=id__lt,
            id__lte=id__lte,
            id__in=id__in,
            id__notin=id__notin,
            id__isnull=id__isnull,
            id__isnotnull=id__isnotnull,
            id__isfalse=id__isfalse,
            id__istrue=id__istrue,
            id__like=id__like,
            id__notlike=id__notlike,
            id__ilike=id__ilike,
            id__notilike=id__notilike,
            id__desc=id__desc,
            id__asc=id__asc,
            created_at__eq=created_at__eq,
            created_at__ne=created_at__ne,
            created_at__gt=created_at__gt,
            created_at__gte=created_at__gte,
            created_at__lt=created_at__lt,
            created_at__lte=created_at__lte,
            created_at__in=created_at__in,
            created_at__notin=created_at__notin,
            created_at__isnull=created_at__isnull,
            created_at__isnotnull=created_at__isnotnull,
            created_at__isfalse=created_at__isfalse,
            created_at__istrue=created_at__istrue,
            created_at__like=created_at__like,
            created_at__notlike=created_at__notlike,
            created_at__ilike=created_at__ilike,
            created_at__notilike=created_at__notilike,
            created_at__desc=created_at__desc,
            created_at__asc=created_at__asc,
            updated_at__eq=updated_at__eq,
            updated_at__ne=updated_at__ne,
            updated_at__gt=updated_at__gt,
            updated_at__gte=updated_at__gte,
            updated_at__lt=updated_at__lt,
            updated_at__lte=updated_at__lte,
            updated_at__in=updated_at__in,
            updated_at__notin=updated_at__notin,
            updated_at__isnull=updated_at__isnull,
            updated_at__isnotnull=updated_at__isnotnull,
            updated_at__isfalse=updated_at__isfalse,
            updated_at__istrue=updated_at__istrue,
            updated_at__like=updated_at__like,
            updated_at__notlike=updated_at__notlike,
            updated_at__ilike=updated_at__ilike,
            updated_at__notilike=updated_at__notilike,
            updated_at__desc=updated_at__desc,
            updated_at__asc=updated_at__asc,
            deleted_at__eq=deleted_at__eq,
            deleted_at__ne=deleted_at__ne,
            deleted_at__gt=deleted_at__gt,
            deleted_at__gte=deleted_at__gte,
            deleted_at__lt=deleted_at__lt,
            deleted_at__lte=deleted_at__lte,
            deleted_at__in=deleted_at__in,
            deleted_at__notin=deleted_at__notin,
            deleted_at__isnull=deleted_at__isnull,
            deleted_at__isnotnull=deleted_at__isnotnull,
            deleted_at__isfalse=deleted_at__isfalse,
            deleted_at__istrue=deleted_at__istrue,
            deleted_at__like=deleted_at__like,
            deleted_at__notlike=deleted_at__notlike,
            deleted_at__ilike=deleted_at__ilike,
            deleted_at__notilike=deleted_at__notilike,
            deleted_at__desc=deleted_at__desc,
            deleted_at__asc=deleted_at__asc,
            name__eq=name__eq,
            name__ne=name__ne,
            name__gt=name__gt,
            name__gte=name__gte,
            name__lt=name__lt,
            name__lte=name__lte,
            name__in=name__in,
            name__notin=name__notin,
            name__isnull=name__isnull,
            name__isnotnull=name__isnotnull,
            name__isfalse=name__isfalse,
            name__istrue=name__istrue,
            name__like=name__like,
            name__notlike=name__notlike,
            name__ilike=name__ilike,
            name__notilike=name__notilike,
            name__desc=name__desc,
            name__asc=name__asc,
            stream_url__eq=stream_url__eq,
            stream_url__ne=stream_url__ne,
            stream_url__gt=stream_url__gt,
            stream_url__gte=stream_url__gte,
            stream_url__lt=stream_url__lt,
            stream_url__lte=stream_url__lte,
            stream_url__in=stream_url__in,
            stream_url__notin=stream_url__notin,
            stream_url__isnull=stream_url__isnull,
            stream_url__isnotnull=stream_url__isnotnull,
            stream_url__isfalse=stream_url__isfalse,
            stream_url__istrue=stream_url__istrue,
            stream_url__like=stream_url__like,
            stream_url__notlike=stream_url__notlike,
            stream_url__ilike=stream_url__ilike,
            stream_url__notilike=stream_url__notilike,
            stream_url__desc=stream_url__desc,
            stream_url__asc=stream_url__asc,
            last_seen__eq=last_seen__eq,
            last_seen__ne=last_seen__ne,
            last_seen__gt=last_seen__gt,
            last_seen__gte=last_seen__gte,
            last_seen__lt=last_seen__lt,
            last_seen__lte=last_seen__lte,
            last_seen__in=last_seen__in,
            last_seen__notin=last_seen__notin,
            last_seen__isnull=last_seen__isnull,
            last_seen__isnotnull=last_seen__isnotnull,
            last_seen__isfalse=last_seen__isfalse,
            last_seen__istrue=last_seen__istrue,
            last_seen__like=last_seen__like,
            last_seen__notlike=last_seen__notlike,
            last_seen__ilike=last_seen__ilike,
            last_seen__notilike=last_seen__notilike,
            last_seen__desc=last_seen__desc,
            last_seen__asc=last_seen__asc,
            segment_producer_claimed_until__eq=segment_producer_claimed_until__eq,
            segment_producer_claimed_until__ne=segment_producer_claimed_until__ne,
            segment_producer_claimed_until__gt=segment_producer_claimed_until__gt,
            segment_producer_claimed_until__gte=segment_producer_claimed_until__gte,
            segment_producer_claimed_until__lt=segment_producer_claimed_until__lt,
            segment_producer_claimed_until__lte=segment_producer_claimed_until__lte,
            segment_producer_claimed_until__in=segment_producer_claimed_until__in,
            segment_producer_claimed_until__notin=segment_producer_claimed_until__notin,
            segment_producer_claimed_until__isnull=segment_producer_claimed_until__isnull,
            segment_producer_claimed_until__isnotnull=segment_producer_claimed_until__isnotnull,
            segment_producer_claimed_until__isfalse=segment_producer_claimed_until__isfalse,
            segment_producer_claimed_until__istrue=segment_producer_claimed_until__istrue,
            segment_producer_claimed_until__like=segment_producer_claimed_until__like,
            segment_producer_claimed_until__notlike=segment_producer_claimed_until__notlike,
            segment_producer_claimed_until__ilike=segment_producer_claimed_until__ilike,
            segment_producer_claimed_until__notilike=segment_producer_claimed_until__notilike,
            segment_producer_claimed_until__desc=segment_producer_claimed_until__desc,
            segment_producer_claimed_until__asc=segment_producer_claimed_until__asc,
            stream_producer_claimed_until__eq=stream_producer_claimed_until__eq,
            stream_producer_claimed_until__ne=stream_producer_claimed_until__ne,
            stream_producer_claimed_until__gt=stream_producer_claimed_until__gt,
            stream_producer_claimed_until__gte=stream_producer_claimed_until__gte,
            stream_producer_claimed_until__lt=stream_producer_claimed_until__lt,
            stream_producer_claimed_until__lte=stream_producer_claimed_until__lte,
            stream_producer_claimed_until__in=stream_producer_claimed_until__in,
            stream_producer_claimed_until__notin=stream_producer_claimed_until__notin,
            stream_producer_claimed_until__isnull=stream_producer_claimed_until__isnull,
            stream_producer_claimed_until__isnotnull=stream_producer_claimed_until__isnotnull,
            stream_producer_claimed_until__isfalse=stream_producer_claimed_until__isfalse,
            stream_producer_claimed_until__istrue=stream_producer_claimed_until__istrue,
            stream_producer_claimed_until__like=stream_producer_claimed_until__like,
            stream_producer_claimed_until__notlike=stream_producer_claimed_until__notlike,
            stream_producer_claimed_until__ilike=stream_producer_claimed_until__ilike,
            stream_producer_claimed_until__notilike=stream_producer_claimed_until__notilike,
            stream_producer_claimed_until__desc=stream_producer_claimed_until__desc,
            stream_producer_claimed_until__asc=stream_producer_claimed_until__asc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_cameras_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="SQL LIMIT operator")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="SQL OFFSET operator")] = None,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        id__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        id__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        id__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        id__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        created_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        created_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        created_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        created_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        created_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        created_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        created_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        created_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        created_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        updated_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        updated_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        updated_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        updated_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        updated_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        updated_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        updated_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        updated_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        updated_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        deleted_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        deleted_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        deleted_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        deleted_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        deleted_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        deleted_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        deleted_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        deleted_at__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        name__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        name__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        name__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        name__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        name__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        name__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        name__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        name__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        name__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        name__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        name__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        name__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        name__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        name__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        name__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_url__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        stream_url__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        stream_url__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        stream_url__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        stream_url__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        stream_url__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        stream_url__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        stream_url__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        stream_url__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_url__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_url__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_url__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        last_seen__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        last_seen__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        last_seen__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        last_seen__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        last_seen__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        last_seen__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        last_seen__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        last_seen__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        last_seen__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        last_seen__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        last_seen__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        last_seen__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        segment_producer_claimed_until__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        segment_producer_claimed_until__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        segment_producer_claimed_until__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        segment_producer_claimed_until__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        segment_producer_claimed_until__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        segment_producer_claimed_until__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        segment_producer_claimed_until__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        stream_producer_claimed_until__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        stream_producer_claimed_until__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        stream_producer_claimed_until__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        stream_producer_claimed_until__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        stream_producer_claimed_until__isnull: Annotated[Optional[StrictStr], Field(description="SQL IS null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__isnotnull: Annotated[Optional[StrictStr], Field(description="SQL IS NOT null comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__isfalse: Annotated[Optional[StrictStr], Field(description="SQL IS false comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__istrue: Annotated[Optional[StrictStr], Field(description="SQL IS true comparison, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        stream_producer_claimed_until__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        stream_producer_claimed_until__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_cameras


        :param limit: SQL LIMIT operator
        :type limit: int
        :param offset: SQL OFFSET operator
        :type offset: int
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param id__eq: SQL = comparison
        :type id__eq: str
        :param id__ne: SQL != comparison
        :type id__ne: str
        :param id__gt: SQL > comparison, may not work with all column types
        :type id__gt: str
        :param id__gte: SQL >= comparison, may not work with all column types
        :type id__gte: str
        :param id__lt: SQL < comparison, may not work with all column types
        :type id__lt: str
        :param id__lte: SQL <= comparison, may not work with all column types
        :type id__lte: str
        :param id__in: SQL IN comparison, permits comma-separated values
        :type id__in: str
        :param id__notin: SQL NOT IN comparison, permits comma-separated values
        :type id__notin: str
        :param id__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type id__isnull: str
        :param id__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type id__isnotnull: str
        :param id__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type id__isfalse: str
        :param id__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type id__istrue: str
        :param id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__like: str
        :param id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notlike: str
        :param id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__ilike: str
        :param id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notilike: str
        :param id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type id__desc: str
        :param id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type id__asc: str
        :param created_at__eq: SQL = comparison
        :type created_at__eq: datetime
        :param created_at__ne: SQL != comparison
        :type created_at__ne: datetime
        :param created_at__gt: SQL > comparison, may not work with all column types
        :type created_at__gt: datetime
        :param created_at__gte: SQL >= comparison, may not work with all column types
        :type created_at__gte: datetime
        :param created_at__lt: SQL < comparison, may not work with all column types
        :type created_at__lt: datetime
        :param created_at__lte: SQL <= comparison, may not work with all column types
        :type created_at__lte: datetime
        :param created_at__in: SQL IN comparison, permits comma-separated values
        :type created_at__in: datetime
        :param created_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type created_at__notin: datetime
        :param created_at__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type created_at__isnull: str
        :param created_at__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type created_at__isnotnull: str
        :param created_at__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type created_at__isfalse: str
        :param created_at__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type created_at__istrue: str
        :param created_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__like: str
        :param created_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notlike: str
        :param created_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__ilike: str
        :param created_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notilike: str
        :param created_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type created_at__desc: str
        :param created_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type created_at__asc: str
        :param updated_at__eq: SQL = comparison
        :type updated_at__eq: datetime
        :param updated_at__ne: SQL != comparison
        :type updated_at__ne: datetime
        :param updated_at__gt: SQL > comparison, may not work with all column types
        :type updated_at__gt: datetime
        :param updated_at__gte: SQL >= comparison, may not work with all column types
        :type updated_at__gte: datetime
        :param updated_at__lt: SQL < comparison, may not work with all column types
        :type updated_at__lt: datetime
        :param updated_at__lte: SQL <= comparison, may not work with all column types
        :type updated_at__lte: datetime
        :param updated_at__in: SQL IN comparison, permits comma-separated values
        :type updated_at__in: datetime
        :param updated_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type updated_at__notin: datetime
        :param updated_at__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type updated_at__isnull: str
        :param updated_at__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type updated_at__isnotnull: str
        :param updated_at__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type updated_at__isfalse: str
        :param updated_at__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type updated_at__istrue: str
        :param updated_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__like: str
        :param updated_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notlike: str
        :param updated_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__ilike: str
        :param updated_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notilike: str
        :param updated_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type updated_at__desc: str
        :param updated_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type updated_at__asc: str
        :param deleted_at__eq: SQL = comparison
        :type deleted_at__eq: datetime
        :param deleted_at__ne: SQL != comparison
        :type deleted_at__ne: datetime
        :param deleted_at__gt: SQL > comparison, may not work with all column types
        :type deleted_at__gt: datetime
        :param deleted_at__gte: SQL >= comparison, may not work with all column types
        :type deleted_at__gte: datetime
        :param deleted_at__lt: SQL < comparison, may not work with all column types
        :type deleted_at__lt: datetime
        :param deleted_at__lte: SQL <= comparison, may not work with all column types
        :type deleted_at__lte: datetime
        :param deleted_at__in: SQL IN comparison, permits comma-separated values
        :type deleted_at__in: datetime
        :param deleted_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type deleted_at__notin: datetime
        :param deleted_at__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__isnull: str
        :param deleted_at__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__isnotnull: str
        :param deleted_at__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__isfalse: str
        :param deleted_at__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type deleted_at__istrue: str
        :param deleted_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__like: str
        :param deleted_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notlike: str
        :param deleted_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__ilike: str
        :param deleted_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notilike: str
        :param deleted_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__desc: str
        :param deleted_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__asc: str
        :param name__eq: SQL = comparison
        :type name__eq: str
        :param name__ne: SQL != comparison
        :type name__ne: str
        :param name__gt: SQL > comparison, may not work with all column types
        :type name__gt: str
        :param name__gte: SQL >= comparison, may not work with all column types
        :type name__gte: str
        :param name__lt: SQL < comparison, may not work with all column types
        :type name__lt: str
        :param name__lte: SQL <= comparison, may not work with all column types
        :type name__lte: str
        :param name__in: SQL IN comparison, permits comma-separated values
        :type name__in: str
        :param name__notin: SQL NOT IN comparison, permits comma-separated values
        :type name__notin: str
        :param name__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type name__isnull: str
        :param name__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type name__isnotnull: str
        :param name__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type name__isfalse: str
        :param name__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type name__istrue: str
        :param name__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__like: str
        :param name__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__notlike: str
        :param name__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__ilike: str
        :param name__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type name__notilike: str
        :param name__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type name__desc: str
        :param name__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type name__asc: str
        :param stream_url__eq: SQL = comparison
        :type stream_url__eq: str
        :param stream_url__ne: SQL != comparison
        :type stream_url__ne: str
        :param stream_url__gt: SQL > comparison, may not work with all column types
        :type stream_url__gt: str
        :param stream_url__gte: SQL >= comparison, may not work with all column types
        :type stream_url__gte: str
        :param stream_url__lt: SQL < comparison, may not work with all column types
        :type stream_url__lt: str
        :param stream_url__lte: SQL <= comparison, may not work with all column types
        :type stream_url__lte: str
        :param stream_url__in: SQL IN comparison, permits comma-separated values
        :type stream_url__in: str
        :param stream_url__notin: SQL NOT IN comparison, permits comma-separated values
        :type stream_url__notin: str
        :param stream_url__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type stream_url__isnull: str
        :param stream_url__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type stream_url__isnotnull: str
        :param stream_url__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type stream_url__isfalse: str
        :param stream_url__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type stream_url__istrue: str
        :param stream_url__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__like: str
        :param stream_url__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__notlike: str
        :param stream_url__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__ilike: str
        :param stream_url__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_url__notilike: str
        :param stream_url__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type stream_url__desc: str
        :param stream_url__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type stream_url__asc: str
        :param last_seen__eq: SQL = comparison
        :type last_seen__eq: datetime
        :param last_seen__ne: SQL != comparison
        :type last_seen__ne: datetime
        :param last_seen__gt: SQL > comparison, may not work with all column types
        :type last_seen__gt: datetime
        :param last_seen__gte: SQL >= comparison, may not work with all column types
        :type last_seen__gte: datetime
        :param last_seen__lt: SQL < comparison, may not work with all column types
        :type last_seen__lt: datetime
        :param last_seen__lte: SQL <= comparison, may not work with all column types
        :type last_seen__lte: datetime
        :param last_seen__in: SQL IN comparison, permits comma-separated values
        :type last_seen__in: datetime
        :param last_seen__notin: SQL NOT IN comparison, permits comma-separated values
        :type last_seen__notin: datetime
        :param last_seen__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type last_seen__isnull: str
        :param last_seen__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type last_seen__isnotnull: str
        :param last_seen__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type last_seen__isfalse: str
        :param last_seen__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type last_seen__istrue: str
        :param last_seen__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__like: str
        :param last_seen__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__notlike: str
        :param last_seen__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__ilike: str
        :param last_seen__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type last_seen__notilike: str
        :param last_seen__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type last_seen__desc: str
        :param last_seen__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type last_seen__asc: str
        :param segment_producer_claimed_until__eq: SQL = comparison
        :type segment_producer_claimed_until__eq: datetime
        :param segment_producer_claimed_until__ne: SQL != comparison
        :type segment_producer_claimed_until__ne: datetime
        :param segment_producer_claimed_until__gt: SQL > comparison, may not work with all column types
        :type segment_producer_claimed_until__gt: datetime
        :param segment_producer_claimed_until__gte: SQL >= comparison, may not work with all column types
        :type segment_producer_claimed_until__gte: datetime
        :param segment_producer_claimed_until__lt: SQL < comparison, may not work with all column types
        :type segment_producer_claimed_until__lt: datetime
        :param segment_producer_claimed_until__lte: SQL <= comparison, may not work with all column types
        :type segment_producer_claimed_until__lte: datetime
        :param segment_producer_claimed_until__in: SQL IN comparison, permits comma-separated values
        :type segment_producer_claimed_until__in: datetime
        :param segment_producer_claimed_until__notin: SQL NOT IN comparison, permits comma-separated values
        :type segment_producer_claimed_until__notin: datetime
        :param segment_producer_claimed_until__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__isnull: str
        :param segment_producer_claimed_until__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__isnotnull: str
        :param segment_producer_claimed_until__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__isfalse: str
        :param segment_producer_claimed_until__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__istrue: str
        :param segment_producer_claimed_until__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__like: str
        :param segment_producer_claimed_until__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__notlike: str
        :param segment_producer_claimed_until__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__ilike: str
        :param segment_producer_claimed_until__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type segment_producer_claimed_until__notilike: str
        :param segment_producer_claimed_until__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__desc: str
        :param segment_producer_claimed_until__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type segment_producer_claimed_until__asc: str
        :param stream_producer_claimed_until__eq: SQL = comparison
        :type stream_producer_claimed_until__eq: datetime
        :param stream_producer_claimed_until__ne: SQL != comparison
        :type stream_producer_claimed_until__ne: datetime
        :param stream_producer_claimed_until__gt: SQL > comparison, may not work with all column types
        :type stream_producer_claimed_until__gt: datetime
        :param stream_producer_claimed_until__gte: SQL >= comparison, may not work with all column types
        :type stream_producer_claimed_until__gte: datetime
        :param stream_producer_claimed_until__lt: SQL < comparison, may not work with all column types
        :type stream_producer_claimed_until__lt: datetime
        :param stream_producer_claimed_until__lte: SQL <= comparison, may not work with all column types
        :type stream_producer_claimed_until__lte: datetime
        :param stream_producer_claimed_until__in: SQL IN comparison, permits comma-separated values
        :type stream_producer_claimed_until__in: datetime
        :param stream_producer_claimed_until__notin: SQL NOT IN comparison, permits comma-separated values
        :type stream_producer_claimed_until__notin: datetime
        :param stream_producer_claimed_until__isnull: SQL IS null comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__isnull: str
        :param stream_producer_claimed_until__isnotnull: SQL IS NOT null comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__isnotnull: str
        :param stream_producer_claimed_until__isfalse: SQL IS false comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__isfalse: str
        :param stream_producer_claimed_until__istrue: SQL IS true comparison, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__istrue: str
        :param stream_producer_claimed_until__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__like: str
        :param stream_producer_claimed_until__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__notlike: str
        :param stream_producer_claimed_until__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__ilike: str
        :param stream_producer_claimed_until__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type stream_producer_claimed_until__notilike: str
        :param stream_producer_claimed_until__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__desc: str
        :param stream_producer_claimed_until__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type stream_producer_claimed_until__asc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_cameras_serialize(
            limit=limit,
            offset=offset,
            depth=depth,
            id__eq=id__eq,
            id__ne=id__ne,
            id__gt=id__gt,
            id__gte=id__gte,
            id__lt=id__lt,
            id__lte=id__lte,
            id__in=id__in,
            id__notin=id__notin,
            id__isnull=id__isnull,
            id__isnotnull=id__isnotnull,
            id__isfalse=id__isfalse,
            id__istrue=id__istrue,
            id__like=id__like,
            id__notlike=id__notlike,
            id__ilike=id__ilike,
            id__notilike=id__notilike,
            id__desc=id__desc,
            id__asc=id__asc,
            created_at__eq=created_at__eq,
            created_at__ne=created_at__ne,
            created_at__gt=created_at__gt,
            created_at__gte=created_at__gte,
            created_at__lt=created_at__lt,
            created_at__lte=created_at__lte,
            created_at__in=created_at__in,
            created_at__notin=created_at__notin,
            created_at__isnull=created_at__isnull,
            created_at__isnotnull=created_at__isnotnull,
            created_at__isfalse=created_at__isfalse,
            created_at__istrue=created_at__istrue,
            created_at__like=created_at__like,
            created_at__notlike=created_at__notlike,
            created_at__ilike=created_at__ilike,
            created_at__notilike=created_at__notilike,
            created_at__desc=created_at__desc,
            created_at__asc=created_at__asc,
            updated_at__eq=updated_at__eq,
            updated_at__ne=updated_at__ne,
            updated_at__gt=updated_at__gt,
            updated_at__gte=updated_at__gte,
            updated_at__lt=updated_at__lt,
            updated_at__lte=updated_at__lte,
            updated_at__in=updated_at__in,
            updated_at__notin=updated_at__notin,
            updated_at__isnull=updated_at__isnull,
            updated_at__isnotnull=updated_at__isnotnull,
            updated_at__isfalse=updated_at__isfalse,
            updated_at__istrue=updated_at__istrue,
            updated_at__like=updated_at__like,
            updated_at__notlike=updated_at__notlike,
            updated_at__ilike=updated_at__ilike,
            updated_at__notilike=updated_at__notilike,
            updated_at__desc=updated_at__desc,
            updated_at__asc=updated_at__asc,
            deleted_at__eq=deleted_at__eq,
            deleted_at__ne=deleted_at__ne,
            deleted_at__gt=deleted_at__gt,
            deleted_at__gte=deleted_at__gte,
            deleted_at__lt=deleted_at__lt,
            deleted_at__lte=deleted_at__lte,
            deleted_at__in=deleted_at__in,
            deleted_at__notin=deleted_at__notin,
            deleted_at__isnull=deleted_at__isnull,
            deleted_at__isnotnull=deleted_at__isnotnull,
            deleted_at__isfalse=deleted_at__isfalse,
            deleted_at__istrue=deleted_at__istrue,
            deleted_at__like=deleted_at__like,
            deleted_at__notlike=deleted_at__notlike,
            deleted_at__ilike=deleted_at__ilike,
            deleted_at__notilike=deleted_at__notilike,
            deleted_at__desc=deleted_at__desc,
            deleted_at__asc=deleted_at__asc,
            name__eq=name__eq,
            name__ne=name__ne,
            name__gt=name__gt,
            name__gte=name__gte,
            name__lt=name__lt,
            name__lte=name__lte,
            name__in=name__in,
            name__notin=name__notin,
            name__isnull=name__isnull,
            name__isnotnull=name__isnotnull,
            name__isfalse=name__isfalse,
            name__istrue=name__istrue,
            name__like=name__like,
            name__notlike=name__notlike,
            name__ilike=name__ilike,
            name__notilike=name__notilike,
            name__desc=name__desc,
            name__asc=name__asc,
            stream_url__eq=stream_url__eq,
            stream_url__ne=stream_url__ne,
            stream_url__gt=stream_url__gt,
            stream_url__gte=stream_url__gte,
            stream_url__lt=stream_url__lt,
            stream_url__lte=stream_url__lte,
            stream_url__in=stream_url__in,
            stream_url__notin=stream_url__notin,
            stream_url__isnull=stream_url__isnull,
            stream_url__isnotnull=stream_url__isnotnull,
            stream_url__isfalse=stream_url__isfalse,
            stream_url__istrue=stream_url__istrue,
            stream_url__like=stream_url__like,
            stream_url__notlike=stream_url__notlike,
            stream_url__ilike=stream_url__ilike,
            stream_url__notilike=stream_url__notilike,
            stream_url__desc=stream_url__desc,
            stream_url__asc=stream_url__asc,
            last_seen__eq=last_seen__eq,
            last_seen__ne=last_seen__ne,
            last_seen__gt=last_seen__gt,
            last_seen__gte=last_seen__gte,
            last_seen__lt=last_seen__lt,
            last_seen__lte=last_seen__lte,
            last_seen__in=last_seen__in,
            last_seen__notin=last_seen__notin,
            last_seen__isnull=last_seen__isnull,
            last_seen__isnotnull=last_seen__isnotnull,
            last_seen__isfalse=last_seen__isfalse,
            last_seen__istrue=last_seen__istrue,
            last_seen__like=last_seen__like,
            last_seen__notlike=last_seen__notlike,
            last_seen__ilike=last_seen__ilike,
            last_seen__notilike=last_seen__notilike,
            last_seen__desc=last_seen__desc,
            last_seen__asc=last_seen__asc,
            segment_producer_claimed_until__eq=segment_producer_claimed_until__eq,
            segment_producer_claimed_until__ne=segment_producer_claimed_until__ne,
            segment_producer_claimed_until__gt=segment_producer_claimed_until__gt,
            segment_producer_claimed_until__gte=segment_producer_claimed_until__gte,
            segment_producer_claimed_until__lt=segment_producer_claimed_until__lt,
            segment_producer_claimed_until__lte=segment_producer_claimed_until__lte,
            segment_producer_claimed_until__in=segment_producer_claimed_until__in,
            segment_producer_claimed_until__notin=segment_producer_claimed_until__notin,
            segment_producer_claimed_until__isnull=segment_producer_claimed_until__isnull,
            segment_producer_claimed_until__isnotnull=segment_producer_claimed_until__isnotnull,
            segment_producer_claimed_until__isfalse=segment_producer_claimed_until__isfalse,
            segment_producer_claimed_until__istrue=segment_producer_claimed_until__istrue,
            segment_producer_claimed_until__like=segment_producer_claimed_until__like,
            segment_producer_claimed_until__notlike=segment_producer_claimed_until__notlike,
            segment_producer_claimed_until__ilike=segment_producer_claimed_until__ilike,
            segment_producer_claimed_until__notilike=segment_producer_claimed_until__notilike,
            segment_producer_claimed_until__desc=segment_producer_claimed_until__desc,
            segment_producer_claimed_until__asc=segment_producer_claimed_until__asc,
            stream_producer_claimed_until__eq=stream_producer_claimed_until__eq,
            stream_producer_claimed_until__ne=stream_producer_claimed_until__ne,
            stream_producer_claimed_until__gt=stream_producer_claimed_until__gt,
            stream_producer_claimed_until__gte=stream_producer_claimed_until__gte,
            stream_producer_claimed_until__lt=stream_producer_claimed_until__lt,
            stream_producer_claimed_until__lte=stream_producer_claimed_until__lte,
            stream_producer_claimed_until__in=stream_producer_claimed_until__in,
            stream_producer_claimed_until__notin=stream_producer_claimed_until__notin,
            stream_producer_claimed_until__isnull=stream_producer_claimed_until__isnull,
            stream_producer_claimed_until__isnotnull=stream_producer_claimed_until__isnotnull,
            stream_producer_claimed_until__isfalse=stream_producer_claimed_until__isfalse,
            stream_producer_claimed_until__istrue=stream_producer_claimed_until__istrue,
            stream_producer_claimed_until__like=stream_producer_claimed_until__like,
            stream_producer_claimed_until__notlike=stream_producer_claimed_until__notlike,
            stream_producer_claimed_until__ilike=stream_producer_claimed_until__ilike,
            stream_producer_claimed_until__notilike=stream_producer_claimed_until__notilike,
            stream_producer_claimed_until__desc=stream_producer_claimed_until__desc,
            stream_producer_claimed_until__asc=stream_producer_claimed_until__asc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_cameras_serialize(
        self,
        limit,
        offset,
        depth,
        id__eq,
        id__ne,
        id__gt,
        id__gte,
        id__lt,
        id__lte,
        id__in,
        id__notin,
        id__isnull,
        id__isnotnull,
        id__isfalse,
        id__istrue,
        id__like,
        id__notlike,
        id__ilike,
        id__notilike,
        id__desc,
        id__asc,
        created_at__eq,
        created_at__ne,
        created_at__gt,
        created_at__gte,
        created_at__lt,
        created_at__lte,
        created_at__in,
        created_at__notin,
        created_at__isnull,
        created_at__isnotnull,
        created_at__isfalse,
        created_at__istrue,
        created_at__like,
        created_at__notlike,
        created_at__ilike,
        created_at__notilike,
        created_at__desc,
        created_at__asc,
        updated_at__eq,
        updated_at__ne,
        updated_at__gt,
        updated_at__gte,
        updated_at__lt,
        updated_at__lte,
        updated_at__in,
        updated_at__notin,
        updated_at__isnull,
        updated_at__isnotnull,
        updated_at__isfalse,
        updated_at__istrue,
        updated_at__like,
        updated_at__notlike,
        updated_at__ilike,
        updated_at__notilike,
        updated_at__desc,
        updated_at__asc,
        deleted_at__eq,
        deleted_at__ne,
        deleted_at__gt,
        deleted_at__gte,
        deleted_at__lt,
        deleted_at__lte,
        deleted_at__in,
        deleted_at__notin,
        deleted_at__isnull,
        deleted_at__isnotnull,
        deleted_at__isfalse,
        deleted_at__istrue,
        deleted_at__like,
        deleted_at__notlike,
        deleted_at__ilike,
        deleted_at__notilike,
        deleted_at__desc,
        deleted_at__asc,
        name__eq,
        name__ne,
        name__gt,
        name__gte,
        name__lt,
        name__lte,
        name__in,
        name__notin,
        name__isnull,
        name__isnotnull,
        name__isfalse,
        name__istrue,
        name__like,
        name__notlike,
        name__ilike,
        name__notilike,
        name__desc,
        name__asc,
        stream_url__eq,
        stream_url__ne,
        stream_url__gt,
        stream_url__gte,
        stream_url__lt,
        stream_url__lte,
        stream_url__in,
        stream_url__notin,
        stream_url__isnull,
        stream_url__isnotnull,
        stream_url__isfalse,
        stream_url__istrue,
        stream_url__like,
        stream_url__notlike,
        stream_url__ilike,
        stream_url__notilike,
        stream_url__desc,
        stream_url__asc,
        last_seen__eq,
        last_seen__ne,
        last_seen__gt,
        last_seen__gte,
        last_seen__lt,
        last_seen__lte,
        last_seen__in,
        last_seen__notin,
        last_seen__isnull,
        last_seen__isnotnull,
        last_seen__isfalse,
        last_seen__istrue,
        last_seen__like,
        last_seen__notlike,
        last_seen__ilike,
        last_seen__notilike,
        last_seen__desc,
        last_seen__asc,
        segment_producer_claimed_until__eq,
        segment_producer_claimed_until__ne,
        segment_producer_claimed_until__gt,
        segment_producer_claimed_until__gte,
        segment_producer_claimed_until__lt,
        segment_producer_claimed_until__lte,
        segment_producer_claimed_until__in,
        segment_producer_claimed_until__notin,
        segment_producer_claimed_until__isnull,
        segment_producer_claimed_until__isnotnull,
        segment_producer_claimed_until__isfalse,
        segment_producer_claimed_until__istrue,
        segment_producer_claimed_until__like,
        segment_producer_claimed_until__notlike,
        segment_producer_claimed_until__ilike,
        segment_producer_claimed_until__notilike,
        segment_producer_claimed_until__desc,
        segment_producer_claimed_until__asc,
        stream_producer_claimed_until__eq,
        stream_producer_claimed_until__ne,
        stream_producer_claimed_until__gt,
        stream_producer_claimed_until__gte,
        stream_producer_claimed_until__lt,
        stream_producer_claimed_until__lte,
        stream_producer_claimed_until__in,
        stream_producer_claimed_until__notin,
        stream_producer_claimed_until__isnull,
        stream_producer_claimed_until__isnotnull,
        stream_producer_claimed_until__isfalse,
        stream_producer_claimed_until__istrue,
        stream_producer_claimed_until__like,
        stream_producer_claimed_until__notlike,
        stream_producer_claimed_until__ilike,
        stream_producer_claimed_until__notilike,
        stream_producer_claimed_until__desc,
        stream_producer_claimed_until__asc,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if id__eq is not None:
            
            _query_params.append(('id__eq', id__eq))
            
        if id__ne is not None:
            
            _query_params.append(('id__ne', id__ne))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__in is not None:
            
            _query_params.append(('id__in', id__in))
            
        if id__notin is not None:
            
            _query_params.append(('id__notin', id__notin))
            
        if id__isnull is not None:
            
            _query_params.append(('id__isnull', id__isnull))
            
        if id__isnotnull is not None:
            
            _query_params.append(('id__isnotnull', id__isnotnull))
            
        if id__isfalse is not None:
            
            _query_params.append(('id__isfalse', id__isfalse))
            
        if id__istrue is not None:
            
            _query_params.append(('id__istrue', id__istrue))
            
        if id__like is not None:
            
            _query_params.append(('id__like', id__like))
            
        if id__notlike is not None:
            
            _query_params.append(('id__notlike', id__notlike))
            
        if id__ilike is not None:
            
            _query_params.append(('id__ilike', id__ilike))
            
        if id__notilike is not None:
            
            _query_params.append(('id__notilike', id__notilike))
            
        if id__desc is not None:
            
            _query_params.append(('id__desc', id__desc))
            
        if id__asc is not None:
            
            _query_params.append(('id__asc', id__asc))
            
        if created_at__eq is not None:
            if isinstance(created_at__eq, datetime):
                _query_params.append(
                    (
                        'created_at__eq',
                        created_at__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__eq', created_at__eq))
            
        if created_at__ne is not None:
            if isinstance(created_at__ne, datetime):
                _query_params.append(
                    (
                        'created_at__ne',
                        created_at__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__ne', created_at__ne))
            
        if created_at__gt is not None:
            if isinstance(created_at__gt, datetime):
                _query_params.append(
                    (
                        'created_at__gt',
                        created_at__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__gt', created_at__gt))
            
        if created_at__gte is not None:
            if isinstance(created_at__gte, datetime):
                _query_params.append(
                    (
                        'created_at__gte',
                        created_at__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__gte', created_at__gte))
            
        if created_at__lt is not None:
            if isinstance(created_at__lt, datetime):
                _query_params.append(
                    (
                        'created_at__lt',
                        created_at__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__lt', created_at__lt))
            
        if created_at__lte is not None:
            if isinstance(created_at__lte, datetime):
                _query_params.append(
                    (
                        'created_at__lte',
                        created_at__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__lte', created_at__lte))
            
        if created_at__in is not None:
            if isinstance(created_at__in, datetime):
                _query_params.append(
                    (
                        'created_at__in',
                        created_at__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__in', created_at__in))
            
        if created_at__notin is not None:
            if isinstance(created_at__notin, datetime):
                _query_params.append(
                    (
                        'created_at__notin',
                        created_at__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__notin', created_at__notin))
            
        if created_at__isnull is not None:
            
            _query_params.append(('created_at__isnull', created_at__isnull))
            
        if created_at__isnotnull is not None:
            
            _query_params.append(('created_at__isnotnull', created_at__isnotnull))
            
        if created_at__isfalse is not None:
            
            _query_params.append(('created_at__isfalse', created_at__isfalse))
            
        if created_at__istrue is not None:
            
            _query_params.append(('created_at__istrue', created_at__istrue))
            
        if created_at__like is not None:
            
            _query_params.append(('created_at__like', created_at__like))
            
        if created_at__notlike is not None:
            
            _query_params.append(('created_at__notlike', created_at__notlike))
            
        if created_at__ilike is not None:
            
            _query_params.append(('created_at__ilike', created_at__ilike))
            
        if created_at__notilike is not None:
            
            _query_params.append(('created_at__notilike', created_at__notilike))
            
        if created_at__desc is not None:
            
            _query_params.append(('created_at__desc', created_at__desc))
            
        if created_at__asc is not None:
            
            _query_params.append(('created_at__asc', created_at__asc))
            
        if updated_at__eq is not None:
            if isinstance(updated_at__eq, datetime):
                _query_params.append(
                    (
                        'updated_at__eq',
                        updated_at__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__eq', updated_at__eq))
            
        if updated_at__ne is not None:
            if isinstance(updated_at__ne, datetime):
                _query_params.append(
                    (
                        'updated_at__ne',
                        updated_at__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__ne', updated_at__ne))
            
        if updated_at__gt is not None:
            if isinstance(updated_at__gt, datetime):
                _query_params.append(
                    (
                        'updated_at__gt',
                        updated_at__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__gt', updated_at__gt))
            
        if updated_at__gte is not None:
            if isinstance(updated_at__gte, datetime):
                _query_params.append(
                    (
                        'updated_at__gte',
                        updated_at__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__gte', updated_at__gte))
            
        if updated_at__lt is not None:
            if isinstance(updated_at__lt, datetime):
                _query_params.append(
                    (
                        'updated_at__lt',
                        updated_at__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__lt', updated_at__lt))
            
        if updated_at__lte is not None:
            if isinstance(updated_at__lte, datetime):
                _query_params.append(
                    (
                        'updated_at__lte',
                        updated_at__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__lte', updated_at__lte))
            
        if updated_at__in is not None:
            if isinstance(updated_at__in, datetime):
                _query_params.append(
                    (
                        'updated_at__in',
                        updated_at__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__in', updated_at__in))
            
        if updated_at__notin is not None:
            if isinstance(updated_at__notin, datetime):
                _query_params.append(
                    (
                        'updated_at__notin',
                        updated_at__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__notin', updated_at__notin))
            
        if updated_at__isnull is not None:
            
            _query_params.append(('updated_at__isnull', updated_at__isnull))
            
        if updated_at__isnotnull is not None:
            
            _query_params.append(('updated_at__isnotnull', updated_at__isnotnull))
            
        if updated_at__isfalse is not None:
            
            _query_params.append(('updated_at__isfalse', updated_at__isfalse))
            
        if updated_at__istrue is not None:
            
            _query_params.append(('updated_at__istrue', updated_at__istrue))
            
        if updated_at__like is not None:
            
            _query_params.append(('updated_at__like', updated_at__like))
            
        if updated_at__notlike is not None:
            
            _query_params.append(('updated_at__notlike', updated_at__notlike))
            
        if updated_at__ilike is not None:
            
            _query_params.append(('updated_at__ilike', updated_at__ilike))
            
        if updated_at__notilike is not None:
            
            _query_params.append(('updated_at__notilike', updated_at__notilike))
            
        if updated_at__desc is not None:
            
            _query_params.append(('updated_at__desc', updated_at__desc))
            
        if updated_at__asc is not None:
            
            _query_params.append(('updated_at__asc', updated_at__asc))
            
        if deleted_at__eq is not None:
            if isinstance(deleted_at__eq, datetime):
                _query_params.append(
                    (
                        'deleted_at__eq',
                        deleted_at__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__eq', deleted_at__eq))
            
        if deleted_at__ne is not None:
            if isinstance(deleted_at__ne, datetime):
                _query_params.append(
                    (
                        'deleted_at__ne',
                        deleted_at__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__ne', deleted_at__ne))
            
        if deleted_at__gt is not None:
            if isinstance(deleted_at__gt, datetime):
                _query_params.append(
                    (
                        'deleted_at__gt',
                        deleted_at__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__gt', deleted_at__gt))
            
        if deleted_at__gte is not None:
            if isinstance(deleted_at__gte, datetime):
                _query_params.append(
                    (
                        'deleted_at__gte',
                        deleted_at__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__gte', deleted_at__gte))
            
        if deleted_at__lt is not None:
            if isinstance(deleted_at__lt, datetime):
                _query_params.append(
                    (
                        'deleted_at__lt',
                        deleted_at__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__lt', deleted_at__lt))
            
        if deleted_at__lte is not None:
            if isinstance(deleted_at__lte, datetime):
                _query_params.append(
                    (
                        'deleted_at__lte',
                        deleted_at__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__lte', deleted_at__lte))
            
        if deleted_at__in is not None:
            if isinstance(deleted_at__in, datetime):
                _query_params.append(
                    (
                        'deleted_at__in',
                        deleted_at__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__in', deleted_at__in))
            
        if deleted_at__notin is not None:
            if isinstance(deleted_at__notin, datetime):
                _query_params.append(
                    (
                        'deleted_at__notin',
                        deleted_at__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__notin', deleted_at__notin))
            
        if deleted_at__isnull is not None:
            
            _query_params.append(('deleted_at__isnull', deleted_at__isnull))
            
        if deleted_at__isnotnull is not None:
            
            _query_params.append(('deleted_at__isnotnull', deleted_at__isnotnull))
            
        if deleted_at__isfalse is not None:
            
            _query_params.append(('deleted_at__isfalse', deleted_at__isfalse))
            
        if deleted_at__istrue is not None:
            
            _query_params.append(('deleted_at__istrue', deleted_at__istrue))
            
        if deleted_at__like is not None:
            
            _query_params.append(('deleted_at__like', deleted_at__like))
            
        if deleted_at__notlike is not None:
            
            _query_params.append(('deleted_at__notlike', deleted_at__notlike))
            
        if deleted_at__ilike is not None:
            
            _query_params.append(('deleted_at__ilike', deleted_at__ilike))
            
        if deleted_at__notilike is not None:
            
            _query_params.append(('deleted_at__notilike', deleted_at__notilike))
            
        if deleted_at__desc is not None:
            
            _query_params.append(('deleted_at__desc', deleted_at__desc))
            
        if deleted_at__asc is not None:
            
            _query_params.append(('deleted_at__asc', deleted_at__asc))
            
        if name__eq is not None:
            
            _query_params.append(('name__eq', name__eq))
            
        if name__ne is not None:
            
            _query_params.append(('name__ne', name__ne))
            
        if name__gt is not None:
            
            _query_params.append(('name__gt', name__gt))
            
        if name__gte is not None:
            
            _query_params.append(('name__gte', name__gte))
            
        if name__lt is not None:
            
            _query_params.append(('name__lt', name__lt))
            
        if name__lte is not None:
            
            _query_params.append(('name__lte', name__lte))
            
        if name__in is not None:
            
            _query_params.append(('name__in', name__in))
            
        if name__notin is not None:
            
            _query_params.append(('name__notin', name__notin))
            
        if name__isnull is not None:
            
            _query_params.append(('name__isnull', name__isnull))
            
        if name__isnotnull is not None:
            
            _query_params.append(('name__isnotnull', name__isnotnull))
            
        if name__isfalse is not None:
            
            _query_params.append(('name__isfalse', name__isfalse))
            
        if name__istrue is not None:
            
            _query_params.append(('name__istrue', name__istrue))
            
        if name__like is not None:
            
            _query_params.append(('name__like', name__like))
            
        if name__notlike is not None:
            
            _query_params.append(('name__notlike', name__notlike))
            
        if name__ilike is not None:
            
            _query_params.append(('name__ilike', name__ilike))
            
        if name__notilike is not None:
            
            _query_params.append(('name__notilike', name__notilike))
            
        if name__desc is not None:
            
            _query_params.append(('name__desc', name__desc))
            
        if name__asc is not None:
            
            _query_params.append(('name__asc', name__asc))
            
        if stream_url__eq is not None:
            
            _query_params.append(('stream_url__eq', stream_url__eq))
            
        if stream_url__ne is not None:
            
            _query_params.append(('stream_url__ne', stream_url__ne))
            
        if stream_url__gt is not None:
            
            _query_params.append(('stream_url__gt', stream_url__gt))
            
        if stream_url__gte is not None:
            
            _query_params.append(('stream_url__gte', stream_url__gte))
            
        if stream_url__lt is not None:
            
            _query_params.append(('stream_url__lt', stream_url__lt))
            
        if stream_url__lte is not None:
            
            _query_params.append(('stream_url__lte', stream_url__lte))
            
        if stream_url__in is not None:
            
            _query_params.append(('stream_url__in', stream_url__in))
            
        if stream_url__notin is not None:
            
            _query_params.append(('stream_url__notin', stream_url__notin))
            
        if stream_url__isnull is not None:
            
            _query_params.append(('stream_url__isnull', stream_url__isnull))
            
        if stream_url__isnotnull is not None:
            
            _query_params.append(('stream_url__isnotnull', stream_url__isnotnull))
            
        if stream_url__isfalse is not None:
            
            _query_params.append(('stream_url__isfalse', stream_url__isfalse))
            
        if stream_url__istrue is not None:
            
            _query_params.append(('stream_url__istrue', stream_url__istrue))
            
        if stream_url__like is not None:
            
            _query_params.append(('stream_url__like', stream_url__like))
            
        if stream_url__notlike is not None:
            
            _query_params.append(('stream_url__notlike', stream_url__notlike))
            
        if stream_url__ilike is not None:
            
            _query_params.append(('stream_url__ilike', stream_url__ilike))
            
        if stream_url__notilike is not None:
            
            _query_params.append(('stream_url__notilike', stream_url__notilike))
            
        if stream_url__desc is not None:
            
            _query_params.append(('stream_url__desc', stream_url__desc))
            
        if stream_url__asc is not None:
            
            _query_params.append(('stream_url__asc', stream_url__asc))
            
        if last_seen__eq is not None:
            if isinstance(last_seen__eq, datetime):
                _query_params.append(
                    (
                        'last_seen__eq',
                        last_seen__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__eq', last_seen__eq))
            
        if last_seen__ne is not None:
            if isinstance(last_seen__ne, datetime):
                _query_params.append(
                    (
                        'last_seen__ne',
                        last_seen__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__ne', last_seen__ne))
            
        if last_seen__gt is not None:
            if isinstance(last_seen__gt, datetime):
                _query_params.append(
                    (
                        'last_seen__gt',
                        last_seen__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__gt', last_seen__gt))
            
        if last_seen__gte is not None:
            if isinstance(last_seen__gte, datetime):
                _query_params.append(
                    (
                        'last_seen__gte',
                        last_seen__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__gte', last_seen__gte))
            
        if last_seen__lt is not None:
            if isinstance(last_seen__lt, datetime):
                _query_params.append(
                    (
                        'last_seen__lt',
                        last_seen__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__lt', last_seen__lt))
            
        if last_seen__lte is not None:
            if isinstance(last_seen__lte, datetime):
                _query_params.append(
                    (
                        'last_seen__lte',
                        last_seen__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__lte', last_seen__lte))
            
        if last_seen__in is not None:
            if isinstance(last_seen__in, datetime):
                _query_params.append(
                    (
                        'last_seen__in',
                        last_seen__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__in', last_seen__in))
            
        if last_seen__notin is not None:
            if isinstance(last_seen__notin, datetime):
                _query_params.append(
                    (
                        'last_seen__notin',
                        last_seen__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('last_seen__notin', last_seen__notin))
            
        if last_seen__isnull is not None:
            
            _query_params.append(('last_seen__isnull', last_seen__isnull))
            
        if last_seen__isnotnull is not None:
            
            _query_params.append(('last_seen__isnotnull', last_seen__isnotnull))
            
        if last_seen__isfalse is not None:
            
            _query_params.append(('last_seen__isfalse', last_seen__isfalse))
            
        if last_seen__istrue is not None:
            
            _query_params.append(('last_seen__istrue', last_seen__istrue))
            
        if last_seen__like is not None:
            
            _query_params.append(('last_seen__like', last_seen__like))
            
        if last_seen__notlike is not None:
            
            _query_params.append(('last_seen__notlike', last_seen__notlike))
            
        if last_seen__ilike is not None:
            
            _query_params.append(('last_seen__ilike', last_seen__ilike))
            
        if last_seen__notilike is not None:
            
            _query_params.append(('last_seen__notilike', last_seen__notilike))
            
        if last_seen__desc is not None:
            
            _query_params.append(('last_seen__desc', last_seen__desc))
            
        if last_seen__asc is not None:
            
            _query_params.append(('last_seen__asc', last_seen__asc))
            
        if segment_producer_claimed_until__eq is not None:
            if isinstance(segment_producer_claimed_until__eq, datetime):
                _query_params.append(
                    (
                        'segment_producer_claimed_until__eq',
                        segment_producer_claimed_until__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('segment_producer_claimed_until__eq', segment_producer_claimed_until__eq))
            
        if segment_producer_claimed_until__ne is not None:
            if isinstance(segment_producer_claimed_until__ne, datetime):
                _query_params.append(
                    (
                        'segment_producer_claimed_until__ne',
                        segment_producer_claimed_until__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('segment_producer_claimed_until__ne', segment_producer_claimed_until__ne))
            
        if segment_producer_claimed_until__gt is not None:
            if isinstance(segment_producer_claimed_until__gt, datetime):
                _query_params.append(
                    (
                        'segment_producer_claimed_until__gt',
                        segment_producer_claimed_until__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('segment_producer_claimed_until__gt', segment_producer_claimed_until__gt))
            
        if segment_producer_claimed_until__gte is not None:
            if isinstance(segment_producer_claimed_until__gte, datetime):
                _query_params.append(
                    (
                        'segment_producer_claimed_until__gte',
                        segment_producer_claimed_until__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('segment_producer_claimed_until__gte', segment_producer_claimed_until__gte))
            
        if segment_producer_claimed_until__lt is not None:
            if isinstance(segment_producer_claimed_until__lt, datetime):
                _query_params.append(
                    (
                        'segment_producer_claimed_until__lt',
                        segment_producer_claimed_until__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('segment_producer_claimed_until__lt', segment_producer_claimed_until__lt))
            
        if segment_producer_claimed_until__lte is not None:
            if isinstance(segment_producer_claimed_until__lte, datetime):
                _query_params.append(
                    (
                        'segment_producer_claimed_until__lte',
                        segment_producer_claimed_until__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('segment_producer_claimed_until__lte', segment_producer_claimed_until__lte))
            
        if segment_producer_claimed_until__in is not None:
            if isinstance(segment_producer_claimed_until__in, datetime):
                _query_params.append(
                    (
                        'segment_producer_claimed_until__in',
                        segment_producer_claimed_until__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('segment_producer_claimed_until__in', segment_producer_claimed_until__in))
            
        if segment_producer_claimed_until__notin is not None:
            if isinstance(segment_producer_claimed_until__notin, datetime):
                _query_params.append(
                    (
                        'segment_producer_claimed_until__notin',
                        segment_producer_claimed_until__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('segment_producer_claimed_until__notin', segment_producer_claimed_until__notin))
            
        if segment_producer_claimed_until__isnull is not None:
            
            _query_params.append(('segment_producer_claimed_until__isnull', segment_producer_claimed_until__isnull))
            
        if segment_producer_claimed_until__isnotnull is not None:
            
            _query_params.append(('segment_producer_claimed_until__isnotnull', segment_producer_claimed_until__isnotnull))
            
        if segment_producer_claimed_until__isfalse is not None:
            
            _query_params.append(('segment_producer_claimed_until__isfalse', segment_producer_claimed_until__isfalse))
            
        if segment_producer_claimed_until__istrue is not None:
            
            _query_params.append(('segment_producer_claimed_until__istrue', segment_producer_claimed_until__istrue))
            
        if segment_producer_claimed_until__like is not None:
            
            _query_params.append(('segment_producer_claimed_until__like', segment_producer_claimed_until__like))
            
        if segment_producer_claimed_until__notlike is not None:
            
            _query_params.append(('segment_producer_claimed_until__notlike', segment_producer_claimed_until__notlike))
            
        if segment_producer_claimed_until__ilike is not None:
            
            _query_params.append(('segment_producer_claimed_until__ilike', segment_producer_claimed_until__ilike))
            
        if segment_producer_claimed_until__notilike is not None:
            
            _query_params.append(('segment_producer_claimed_until__notilike', segment_producer_claimed_until__notilike))
            
        if segment_producer_claimed_until__desc is not None:
            
            _query_params.append(('segment_producer_claimed_until__desc', segment_producer_claimed_until__desc))
            
        if segment_producer_claimed_until__asc is not None:
            
            _query_params.append(('segment_producer_claimed_until__asc', segment_producer_claimed_until__asc))
            
        if stream_producer_claimed_until__eq is not None:
            if isinstance(stream_producer_claimed_until__eq, datetime):
                _query_params.append(
                    (
                        'stream_producer_claimed_until__eq',
                        stream_producer_claimed_until__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('stream_producer_claimed_until__eq', stream_producer_claimed_until__eq))
            
        if stream_producer_claimed_until__ne is not None:
            if isinstance(stream_producer_claimed_until__ne, datetime):
                _query_params.append(
                    (
                        'stream_producer_claimed_until__ne',
                        stream_producer_claimed_until__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('stream_producer_claimed_until__ne', stream_producer_claimed_until__ne))
            
        if stream_producer_claimed_until__gt is not None:
            if isinstance(stream_producer_claimed_until__gt, datetime):
                _query_params.append(
                    (
                        'stream_producer_claimed_until__gt',
                        stream_producer_claimed_until__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('stream_producer_claimed_until__gt', stream_producer_claimed_until__gt))
            
        if stream_producer_claimed_until__gte is not None:
            if isinstance(stream_producer_claimed_until__gte, datetime):
                _query_params.append(
                    (
                        'stream_producer_claimed_until__gte',
                        stream_producer_claimed_until__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('stream_producer_claimed_until__gte', stream_producer_claimed_until__gte))
            
        if stream_producer_claimed_until__lt is not None:
            if isinstance(stream_producer_claimed_until__lt, datetime):
                _query_params.append(
                    (
                        'stream_producer_claimed_until__lt',
                        stream_producer_claimed_until__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('stream_producer_claimed_until__lt', stream_producer_claimed_until__lt))
            
        if stream_producer_claimed_until__lte is not None:
            if isinstance(stream_producer_claimed_until__lte, datetime):
                _query_params.append(
                    (
                        'stream_producer_claimed_until__lte',
                        stream_producer_claimed_until__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('stream_producer_claimed_until__lte', stream_producer_claimed_until__lte))
            
        if stream_producer_claimed_until__in is not None:
            if isinstance(stream_producer_claimed_until__in, datetime):
                _query_params.append(
                    (
                        'stream_producer_claimed_until__in',
                        stream_producer_claimed_until__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('stream_producer_claimed_until__in', stream_producer_claimed_until__in))
            
        if stream_producer_claimed_until__notin is not None:
            if isinstance(stream_producer_claimed_until__notin, datetime):
                _query_params.append(
                    (
                        'stream_producer_claimed_until__notin',
                        stream_producer_claimed_until__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('stream_producer_claimed_until__notin', stream_producer_claimed_until__notin))
            
        if stream_producer_claimed_until__isnull is not None:
            
            _query_params.append(('stream_producer_claimed_until__isnull', stream_producer_claimed_until__isnull))
            
        if stream_producer_claimed_until__isnotnull is not None:
            
            _query_params.append(('stream_producer_claimed_until__isnotnull', stream_producer_claimed_until__isnotnull))
            
        if stream_producer_claimed_until__isfalse is not None:
            
            _query_params.append(('stream_producer_claimed_until__isfalse', stream_producer_claimed_until__isfalse))
            
        if stream_producer_claimed_until__istrue is not None:
            
            _query_params.append(('stream_producer_claimed_until__istrue', stream_producer_claimed_until__istrue))
            
        if stream_producer_claimed_until__like is not None:
            
            _query_params.append(('stream_producer_claimed_until__like', stream_producer_claimed_until__like))
            
        if stream_producer_claimed_until__notlike is not None:
            
            _query_params.append(('stream_producer_claimed_until__notlike', stream_producer_claimed_until__notlike))
            
        if stream_producer_claimed_until__ilike is not None:
            
            _query_params.append(('stream_producer_claimed_until__ilike', stream_producer_claimed_until__ilike))
            
        if stream_producer_claimed_until__notilike is not None:
            
            _query_params.append(('stream_producer_claimed_until__notilike', stream_producer_claimed_until__notilike))
            
        if stream_producer_claimed_until__desc is not None:
            
            _query_params.append(('stream_producer_claimed_until__desc', stream_producer_claimed_until__desc))
            
        if stream_producer_claimed_until__asc is not None:
            
            _query_params.append(('stream_producer_claimed_until__asc', stream_producer_claimed_until__asc))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/cameras',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_camera(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCameras200Response:
        """patch_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_camera_with_http_info(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCameras200Response]:
        """patch_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_camera_without_preload_content(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_camera_serialize(
        self,
        primary_key,
        camera,
        depth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if primary_key is not None:
            _path_params['primaryKey'] = primary_key
        # process the query parameters
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if camera is not None:
            _body_params = camera


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/cameras/{primaryKey}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_cameras(
        self,
        camera: List[Camera],
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCameras200Response:
        """post_cameras


        :param camera: (required)
        :type camera: List[Camera]
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_cameras_serialize(
            camera=camera,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_cameras_with_http_info(
        self,
        camera: List[Camera],
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCameras200Response]:
        """post_cameras


        :param camera: (required)
        :type camera: List[Camera]
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_cameras_serialize(
            camera=camera,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_cameras_without_preload_content(
        self,
        camera: List[Camera],
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_cameras


        :param camera: (required)
        :type camera: List[Camera]
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_cameras_serialize(
            camera=camera,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_cameras_serialize(
        self,
        camera,
        depth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'Camera': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if camera is not None:
            _body_params = camera


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/cameras',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_camera(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCameras200Response:
        """put_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_camera_with_http_info(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCameras200Response]:
        """put_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_camera_without_preload_content(
        self,
        primary_key: Annotated[Any, Field(description="Primary key for Camera")],
        camera: Camera,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_camera


        :param primary_key: Primary key for Camera (required)
        :type primary_key: object
        :param camera: (required)
        :type camera: Camera
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_camera_serialize(
            primary_key=primary_key,
            camera=camera,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCameras200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_camera_serialize(
        self,
        primary_key,
        camera,
        depth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if primary_key is not None:
            _path_params['primaryKey'] = primary_key
        # process the query parameters
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if camera is not None:
            _body_params = camera


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/cameras/{primaryKey}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


