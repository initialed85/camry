# coding: utf-8

"""
    Djangolang

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictFloat, StrictInt, StrictStr
from typing import Any, List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.detection import Detection
from openapi_client.models.response_with_generic_of_detection import ResponseWithGenericOfDetection

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class DetectionApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def delete_detection(
        self,
        primary_key: Annotated[StrictStr, Field(description="Path parameter primaryKey")],
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """delete_detection


        :param primary_key: Path parameter primaryKey (required)
        :type primary_key: str
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_detection_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_detection_with_http_info(
        self,
        primary_key: Annotated[StrictStr, Field(description="Path parameter primaryKey")],
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """delete_detection


        :param primary_key: Path parameter primaryKey (required)
        :type primary_key: str
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_detection_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_detection_without_preload_content(
        self,
        primary_key: Annotated[StrictStr, Field(description="Path parameter primaryKey")],
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_detection


        :param primary_key: Path parameter primaryKey (required)
        :type primary_key: str
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_detection_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_detection_serialize(
        self,
        primary_key,
        depth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if primary_key is not None:
            _path_params['primaryKey'] = primary_key
        # process the query parameters
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/detections/{primaryKey}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_detection(
        self,
        primary_key: Annotated[StrictStr, Field(description="Path parameter primaryKey")],
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ResponseWithGenericOfDetection:
        """get_detection


        :param primary_key: Path parameter primaryKey (required)
        :type primary_key: str
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_detection_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_detection_with_http_info(
        self,
        primary_key: Annotated[StrictStr, Field(description="Path parameter primaryKey")],
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ResponseWithGenericOfDetection]:
        """get_detection


        :param primary_key: Path parameter primaryKey (required)
        :type primary_key: str
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_detection_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_detection_without_preload_content(
        self,
        primary_key: Annotated[StrictStr, Field(description="Path parameter primaryKey")],
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_detection


        :param primary_key: Path parameter primaryKey (required)
        :type primary_key: str
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_detection_serialize(
            primary_key=primary_key,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_detection_serialize(
        self,
        primary_key,
        depth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if primary_key is not None:
            _path_params['primaryKey'] = primary_key
        # process the query parameters
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/detections/{primaryKey}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_detections(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="SQL LIMIT operator")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="SQL OFFSET operator")] = None,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        video__load: Annotated[Optional[StrictStr], Field(description="load the given directly related object, value is ignored (presence of key is sufficient)")] = None,
        camera__load: Annotated[Optional[StrictStr], Field(description="load the given directly related object, value is ignored (presence of key is sufficient)")] = None,
        id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        id__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        id__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        created_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        created_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        created_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        created_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        created_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        created_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        created_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        created_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        created_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        created_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        updated_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        updated_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        updated_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        updated_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        updated_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        updated_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        updated_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        updated_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        updated_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        updated_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        deleted_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        deleted_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        deleted_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        deleted_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        deleted_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        deleted_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        deleted_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        deleted_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        deleted_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        deleted_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        seen_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        seen_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        seen_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        seen_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        seen_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        seen_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        seen_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        seen_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        seen_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        seen_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        seen_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        seen_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        class_id__eq: Annotated[Optional[StrictInt], Field(description="SQL = comparison")] = None,
        class_id__ne: Annotated[Optional[StrictInt], Field(description="SQL != comparison")] = None,
        class_id__gt: Annotated[Optional[StrictInt], Field(description="SQL > comparison, may not work with all column types")] = None,
        class_id__gte: Annotated[Optional[StrictInt], Field(description="SQL >= comparison, may not work with all column types")] = None,
        class_id__lt: Annotated[Optional[StrictInt], Field(description="SQL < comparison, may not work with all column types")] = None,
        class_id__lte: Annotated[Optional[StrictInt], Field(description="SQL <= comparison, may not work with all column types")] = None,
        class_id__in: Annotated[Optional[StrictInt], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        class_id__notin: Annotated[Optional[StrictInt], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        class_id__contains: Annotated[Optional[StrictInt], Field(description="SQL @> comparison")] = None,
        class_id__notcontains: Annotated[Optional[StrictInt], Field(description="SQL NOT @> comparison")] = None,
        class_id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        class_id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        class_name__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        class_name__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        class_name__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        class_name__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        class_name__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        class_name__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        class_name__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        class_name__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        class_name__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        class_name__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        class_name__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        class_name__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        score__eq: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL = comparison")] = None,
        score__ne: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL != comparison")] = None,
        score__gt: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL > comparison, may not work with all column types")] = None,
        score__gte: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL >= comparison, may not work with all column types")] = None,
        score__lt: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL < comparison, may not work with all column types")] = None,
        score__lte: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL <= comparison, may not work with all column types")] = None,
        score__in: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        score__notin: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        score__contains: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL @> comparison")] = None,
        score__notcontains: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL NOT @> comparison")] = None,
        score__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        score__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        centroid__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        centroid__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        centroid__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        centroid__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        bounding_box__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        bounding_box__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        bounding_box__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        bounding_box__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        video_id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        video_id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        video_id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        video_id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        video_id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        video_id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        video_id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        video_id__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        video_id__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        video_id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id_object__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        video_id_object__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        video_id_object__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id_object__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        camera_id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        camera_id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        camera_id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        camera_id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        camera_id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        camera_id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        camera_id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        camera_id__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        camera_id__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        camera_id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id_object__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        camera_id_object__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        camera_id_object__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id_object__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ResponseWithGenericOfDetection:
        """get_detections


        :param limit: SQL LIMIT operator
        :type limit: int
        :param offset: SQL OFFSET operator
        :type offset: int
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param video__load: load the given directly related object, value is ignored (presence of key is sufficient)
        :type video__load: str
        :param camera__load: load the given directly related object, value is ignored (presence of key is sufficient)
        :type camera__load: str
        :param id__eq: SQL = comparison
        :type id__eq: str
        :param id__ne: SQL != comparison
        :type id__ne: str
        :param id__gt: SQL > comparison, may not work with all column types
        :type id__gt: str
        :param id__gte: SQL >= comparison, may not work with all column types
        :type id__gte: str
        :param id__lt: SQL < comparison, may not work with all column types
        :type id__lt: str
        :param id__lte: SQL <= comparison, may not work with all column types
        :type id__lte: str
        :param id__in: SQL IN comparison, permits comma-separated values
        :type id__in: str
        :param id__notin: SQL NOT IN comparison, permits comma-separated values
        :type id__notin: str
        :param id__contains: SQL @> comparison
        :type id__contains: str
        :param id__notcontains: SQL NOT @> comparison
        :type id__notcontains: str
        :param id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__like: str
        :param id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notlike: str
        :param id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__ilike: str
        :param id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notilike: str
        :param id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type id__desc: str
        :param id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type id__asc: str
        :param created_at__eq: SQL = comparison
        :type created_at__eq: datetime
        :param created_at__ne: SQL != comparison
        :type created_at__ne: datetime
        :param created_at__gt: SQL > comparison, may not work with all column types
        :type created_at__gt: datetime
        :param created_at__gte: SQL >= comparison, may not work with all column types
        :type created_at__gte: datetime
        :param created_at__lt: SQL < comparison, may not work with all column types
        :type created_at__lt: datetime
        :param created_at__lte: SQL <= comparison, may not work with all column types
        :type created_at__lte: datetime
        :param created_at__in: SQL IN comparison, permits comma-separated values
        :type created_at__in: datetime
        :param created_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type created_at__notin: datetime
        :param created_at__contains: SQL @> comparison
        :type created_at__contains: datetime
        :param created_at__notcontains: SQL NOT @> comparison
        :type created_at__notcontains: datetime
        :param created_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__like: datetime
        :param created_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notlike: datetime
        :param created_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__ilike: datetime
        :param created_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notilike: datetime
        :param created_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type created_at__desc: str
        :param created_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type created_at__asc: str
        :param updated_at__eq: SQL = comparison
        :type updated_at__eq: datetime
        :param updated_at__ne: SQL != comparison
        :type updated_at__ne: datetime
        :param updated_at__gt: SQL > comparison, may not work with all column types
        :type updated_at__gt: datetime
        :param updated_at__gte: SQL >= comparison, may not work with all column types
        :type updated_at__gte: datetime
        :param updated_at__lt: SQL < comparison, may not work with all column types
        :type updated_at__lt: datetime
        :param updated_at__lte: SQL <= comparison, may not work with all column types
        :type updated_at__lte: datetime
        :param updated_at__in: SQL IN comparison, permits comma-separated values
        :type updated_at__in: datetime
        :param updated_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type updated_at__notin: datetime
        :param updated_at__contains: SQL @> comparison
        :type updated_at__contains: datetime
        :param updated_at__notcontains: SQL NOT @> comparison
        :type updated_at__notcontains: datetime
        :param updated_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__like: datetime
        :param updated_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notlike: datetime
        :param updated_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__ilike: datetime
        :param updated_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notilike: datetime
        :param updated_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type updated_at__desc: str
        :param updated_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type updated_at__asc: str
        :param deleted_at__eq: SQL = comparison
        :type deleted_at__eq: datetime
        :param deleted_at__ne: SQL != comparison
        :type deleted_at__ne: datetime
        :param deleted_at__gt: SQL > comparison, may not work with all column types
        :type deleted_at__gt: datetime
        :param deleted_at__gte: SQL >= comparison, may not work with all column types
        :type deleted_at__gte: datetime
        :param deleted_at__lt: SQL < comparison, may not work with all column types
        :type deleted_at__lt: datetime
        :param deleted_at__lte: SQL <= comparison, may not work with all column types
        :type deleted_at__lte: datetime
        :param deleted_at__in: SQL IN comparison, permits comma-separated values
        :type deleted_at__in: datetime
        :param deleted_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type deleted_at__notin: datetime
        :param deleted_at__contains: SQL @> comparison
        :type deleted_at__contains: datetime
        :param deleted_at__notcontains: SQL NOT @> comparison
        :type deleted_at__notcontains: datetime
        :param deleted_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__like: datetime
        :param deleted_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notlike: datetime
        :param deleted_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__ilike: datetime
        :param deleted_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notilike: datetime
        :param deleted_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__desc: str
        :param deleted_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__asc: str
        :param seen_at__eq: SQL = comparison
        :type seen_at__eq: datetime
        :param seen_at__ne: SQL != comparison
        :type seen_at__ne: datetime
        :param seen_at__gt: SQL > comparison, may not work with all column types
        :type seen_at__gt: datetime
        :param seen_at__gte: SQL >= comparison, may not work with all column types
        :type seen_at__gte: datetime
        :param seen_at__lt: SQL < comparison, may not work with all column types
        :type seen_at__lt: datetime
        :param seen_at__lte: SQL <= comparison, may not work with all column types
        :type seen_at__lte: datetime
        :param seen_at__in: SQL IN comparison, permits comma-separated values
        :type seen_at__in: datetime
        :param seen_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type seen_at__notin: datetime
        :param seen_at__contains: SQL @> comparison
        :type seen_at__contains: datetime
        :param seen_at__notcontains: SQL NOT @> comparison
        :type seen_at__notcontains: datetime
        :param seen_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__like: datetime
        :param seen_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__notlike: datetime
        :param seen_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__ilike: datetime
        :param seen_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__notilike: datetime
        :param seen_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type seen_at__desc: str
        :param seen_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type seen_at__asc: str
        :param class_id__eq: SQL = comparison
        :type class_id__eq: int
        :param class_id__ne: SQL != comparison
        :type class_id__ne: int
        :param class_id__gt: SQL > comparison, may not work with all column types
        :type class_id__gt: int
        :param class_id__gte: SQL >= comparison, may not work with all column types
        :type class_id__gte: int
        :param class_id__lt: SQL < comparison, may not work with all column types
        :type class_id__lt: int
        :param class_id__lte: SQL <= comparison, may not work with all column types
        :type class_id__lte: int
        :param class_id__in: SQL IN comparison, permits comma-separated values
        :type class_id__in: int
        :param class_id__notin: SQL NOT IN comparison, permits comma-separated values
        :type class_id__notin: int
        :param class_id__contains: SQL @> comparison
        :type class_id__contains: int
        :param class_id__notcontains: SQL NOT @> comparison
        :type class_id__notcontains: int
        :param class_id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type class_id__desc: str
        :param class_id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type class_id__asc: str
        :param class_name__eq: SQL = comparison
        :type class_name__eq: str
        :param class_name__ne: SQL != comparison
        :type class_name__ne: str
        :param class_name__gt: SQL > comparison, may not work with all column types
        :type class_name__gt: str
        :param class_name__gte: SQL >= comparison, may not work with all column types
        :type class_name__gte: str
        :param class_name__lt: SQL < comparison, may not work with all column types
        :type class_name__lt: str
        :param class_name__lte: SQL <= comparison, may not work with all column types
        :type class_name__lte: str
        :param class_name__in: SQL IN comparison, permits comma-separated values
        :type class_name__in: str
        :param class_name__notin: SQL NOT IN comparison, permits comma-separated values
        :type class_name__notin: str
        :param class_name__contains: SQL @> comparison
        :type class_name__contains: str
        :param class_name__notcontains: SQL NOT @> comparison
        :type class_name__notcontains: str
        :param class_name__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__like: str
        :param class_name__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__notlike: str
        :param class_name__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__ilike: str
        :param class_name__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__notilike: str
        :param class_name__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type class_name__desc: str
        :param class_name__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type class_name__asc: str
        :param score__eq: SQL = comparison
        :type score__eq: float
        :param score__ne: SQL != comparison
        :type score__ne: float
        :param score__gt: SQL > comparison, may not work with all column types
        :type score__gt: float
        :param score__gte: SQL >= comparison, may not work with all column types
        :type score__gte: float
        :param score__lt: SQL < comparison, may not work with all column types
        :type score__lt: float
        :param score__lte: SQL <= comparison, may not work with all column types
        :type score__lte: float
        :param score__in: SQL IN comparison, permits comma-separated values
        :type score__in: float
        :param score__notin: SQL NOT IN comparison, permits comma-separated values
        :type score__notin: float
        :param score__contains: SQL @> comparison
        :type score__contains: float
        :param score__notcontains: SQL NOT @> comparison
        :type score__notcontains: float
        :param score__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type score__desc: str
        :param score__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type score__asc: str
        :param centroid__contains: SQL @> comparison
        :type centroid__contains: object
        :param centroid__notcontains: SQL NOT @> comparison
        :type centroid__notcontains: object
        :param centroid__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type centroid__desc: str
        :param centroid__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type centroid__asc: str
        :param bounding_box__contains: SQL @> comparison
        :type bounding_box__contains: object
        :param bounding_box__notcontains: SQL NOT @> comparison
        :type bounding_box__notcontains: object
        :param bounding_box__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type bounding_box__desc: str
        :param bounding_box__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type bounding_box__asc: str
        :param video_id__eq: SQL = comparison
        :type video_id__eq: str
        :param video_id__ne: SQL != comparison
        :type video_id__ne: str
        :param video_id__gt: SQL > comparison, may not work with all column types
        :type video_id__gt: str
        :param video_id__gte: SQL >= comparison, may not work with all column types
        :type video_id__gte: str
        :param video_id__lt: SQL < comparison, may not work with all column types
        :type video_id__lt: str
        :param video_id__lte: SQL <= comparison, may not work with all column types
        :type video_id__lte: str
        :param video_id__in: SQL IN comparison, permits comma-separated values
        :type video_id__in: str
        :param video_id__notin: SQL NOT IN comparison, permits comma-separated values
        :type video_id__notin: str
        :param video_id__contains: SQL @> comparison
        :type video_id__contains: str
        :param video_id__notcontains: SQL NOT @> comparison
        :type video_id__notcontains: str
        :param video_id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__like: str
        :param video_id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__notlike: str
        :param video_id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__ilike: str
        :param video_id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__notilike: str
        :param video_id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type video_id__desc: str
        :param video_id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type video_id__asc: str
        :param video_id_object__contains: SQL @> comparison
        :type video_id_object__contains: object
        :param video_id_object__notcontains: SQL NOT @> comparison
        :type video_id_object__notcontains: object
        :param video_id_object__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type video_id_object__desc: str
        :param video_id_object__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type video_id_object__asc: str
        :param camera_id__eq: SQL = comparison
        :type camera_id__eq: str
        :param camera_id__ne: SQL != comparison
        :type camera_id__ne: str
        :param camera_id__gt: SQL > comparison, may not work with all column types
        :type camera_id__gt: str
        :param camera_id__gte: SQL >= comparison, may not work with all column types
        :type camera_id__gte: str
        :param camera_id__lt: SQL < comparison, may not work with all column types
        :type camera_id__lt: str
        :param camera_id__lte: SQL <= comparison, may not work with all column types
        :type camera_id__lte: str
        :param camera_id__in: SQL IN comparison, permits comma-separated values
        :type camera_id__in: str
        :param camera_id__notin: SQL NOT IN comparison, permits comma-separated values
        :type camera_id__notin: str
        :param camera_id__contains: SQL @> comparison
        :type camera_id__contains: str
        :param camera_id__notcontains: SQL NOT @> comparison
        :type camera_id__notcontains: str
        :param camera_id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__like: str
        :param camera_id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__notlike: str
        :param camera_id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__ilike: str
        :param camera_id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__notilike: str
        :param camera_id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type camera_id__desc: str
        :param camera_id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type camera_id__asc: str
        :param camera_id_object__contains: SQL @> comparison
        :type camera_id_object__contains: object
        :param camera_id_object__notcontains: SQL NOT @> comparison
        :type camera_id_object__notcontains: object
        :param camera_id_object__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type camera_id_object__desc: str
        :param camera_id_object__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type camera_id_object__asc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_detections_serialize(
            limit=limit,
            offset=offset,
            depth=depth,
            video__load=video__load,
            camera__load=camera__load,
            id__eq=id__eq,
            id__ne=id__ne,
            id__gt=id__gt,
            id__gte=id__gte,
            id__lt=id__lt,
            id__lte=id__lte,
            id__in=id__in,
            id__notin=id__notin,
            id__contains=id__contains,
            id__notcontains=id__notcontains,
            id__like=id__like,
            id__notlike=id__notlike,
            id__ilike=id__ilike,
            id__notilike=id__notilike,
            id__desc=id__desc,
            id__asc=id__asc,
            created_at__eq=created_at__eq,
            created_at__ne=created_at__ne,
            created_at__gt=created_at__gt,
            created_at__gte=created_at__gte,
            created_at__lt=created_at__lt,
            created_at__lte=created_at__lte,
            created_at__in=created_at__in,
            created_at__notin=created_at__notin,
            created_at__contains=created_at__contains,
            created_at__notcontains=created_at__notcontains,
            created_at__like=created_at__like,
            created_at__notlike=created_at__notlike,
            created_at__ilike=created_at__ilike,
            created_at__notilike=created_at__notilike,
            created_at__desc=created_at__desc,
            created_at__asc=created_at__asc,
            updated_at__eq=updated_at__eq,
            updated_at__ne=updated_at__ne,
            updated_at__gt=updated_at__gt,
            updated_at__gte=updated_at__gte,
            updated_at__lt=updated_at__lt,
            updated_at__lte=updated_at__lte,
            updated_at__in=updated_at__in,
            updated_at__notin=updated_at__notin,
            updated_at__contains=updated_at__contains,
            updated_at__notcontains=updated_at__notcontains,
            updated_at__like=updated_at__like,
            updated_at__notlike=updated_at__notlike,
            updated_at__ilike=updated_at__ilike,
            updated_at__notilike=updated_at__notilike,
            updated_at__desc=updated_at__desc,
            updated_at__asc=updated_at__asc,
            deleted_at__eq=deleted_at__eq,
            deleted_at__ne=deleted_at__ne,
            deleted_at__gt=deleted_at__gt,
            deleted_at__gte=deleted_at__gte,
            deleted_at__lt=deleted_at__lt,
            deleted_at__lte=deleted_at__lte,
            deleted_at__in=deleted_at__in,
            deleted_at__notin=deleted_at__notin,
            deleted_at__contains=deleted_at__contains,
            deleted_at__notcontains=deleted_at__notcontains,
            deleted_at__like=deleted_at__like,
            deleted_at__notlike=deleted_at__notlike,
            deleted_at__ilike=deleted_at__ilike,
            deleted_at__notilike=deleted_at__notilike,
            deleted_at__desc=deleted_at__desc,
            deleted_at__asc=deleted_at__asc,
            seen_at__eq=seen_at__eq,
            seen_at__ne=seen_at__ne,
            seen_at__gt=seen_at__gt,
            seen_at__gte=seen_at__gte,
            seen_at__lt=seen_at__lt,
            seen_at__lte=seen_at__lte,
            seen_at__in=seen_at__in,
            seen_at__notin=seen_at__notin,
            seen_at__contains=seen_at__contains,
            seen_at__notcontains=seen_at__notcontains,
            seen_at__like=seen_at__like,
            seen_at__notlike=seen_at__notlike,
            seen_at__ilike=seen_at__ilike,
            seen_at__notilike=seen_at__notilike,
            seen_at__desc=seen_at__desc,
            seen_at__asc=seen_at__asc,
            class_id__eq=class_id__eq,
            class_id__ne=class_id__ne,
            class_id__gt=class_id__gt,
            class_id__gte=class_id__gte,
            class_id__lt=class_id__lt,
            class_id__lte=class_id__lte,
            class_id__in=class_id__in,
            class_id__notin=class_id__notin,
            class_id__contains=class_id__contains,
            class_id__notcontains=class_id__notcontains,
            class_id__desc=class_id__desc,
            class_id__asc=class_id__asc,
            class_name__eq=class_name__eq,
            class_name__ne=class_name__ne,
            class_name__gt=class_name__gt,
            class_name__gte=class_name__gte,
            class_name__lt=class_name__lt,
            class_name__lte=class_name__lte,
            class_name__in=class_name__in,
            class_name__notin=class_name__notin,
            class_name__contains=class_name__contains,
            class_name__notcontains=class_name__notcontains,
            class_name__like=class_name__like,
            class_name__notlike=class_name__notlike,
            class_name__ilike=class_name__ilike,
            class_name__notilike=class_name__notilike,
            class_name__desc=class_name__desc,
            class_name__asc=class_name__asc,
            score__eq=score__eq,
            score__ne=score__ne,
            score__gt=score__gt,
            score__gte=score__gte,
            score__lt=score__lt,
            score__lte=score__lte,
            score__in=score__in,
            score__notin=score__notin,
            score__contains=score__contains,
            score__notcontains=score__notcontains,
            score__desc=score__desc,
            score__asc=score__asc,
            centroid__contains=centroid__contains,
            centroid__notcontains=centroid__notcontains,
            centroid__desc=centroid__desc,
            centroid__asc=centroid__asc,
            bounding_box__contains=bounding_box__contains,
            bounding_box__notcontains=bounding_box__notcontains,
            bounding_box__desc=bounding_box__desc,
            bounding_box__asc=bounding_box__asc,
            video_id__eq=video_id__eq,
            video_id__ne=video_id__ne,
            video_id__gt=video_id__gt,
            video_id__gte=video_id__gte,
            video_id__lt=video_id__lt,
            video_id__lte=video_id__lte,
            video_id__in=video_id__in,
            video_id__notin=video_id__notin,
            video_id__contains=video_id__contains,
            video_id__notcontains=video_id__notcontains,
            video_id__like=video_id__like,
            video_id__notlike=video_id__notlike,
            video_id__ilike=video_id__ilike,
            video_id__notilike=video_id__notilike,
            video_id__desc=video_id__desc,
            video_id__asc=video_id__asc,
            video_id_object__contains=video_id_object__contains,
            video_id_object__notcontains=video_id_object__notcontains,
            video_id_object__desc=video_id_object__desc,
            video_id_object__asc=video_id_object__asc,
            camera_id__eq=camera_id__eq,
            camera_id__ne=camera_id__ne,
            camera_id__gt=camera_id__gt,
            camera_id__gte=camera_id__gte,
            camera_id__lt=camera_id__lt,
            camera_id__lte=camera_id__lte,
            camera_id__in=camera_id__in,
            camera_id__notin=camera_id__notin,
            camera_id__contains=camera_id__contains,
            camera_id__notcontains=camera_id__notcontains,
            camera_id__like=camera_id__like,
            camera_id__notlike=camera_id__notlike,
            camera_id__ilike=camera_id__ilike,
            camera_id__notilike=camera_id__notilike,
            camera_id__desc=camera_id__desc,
            camera_id__asc=camera_id__asc,
            camera_id_object__contains=camera_id_object__contains,
            camera_id_object__notcontains=camera_id_object__notcontains,
            camera_id_object__desc=camera_id_object__desc,
            camera_id_object__asc=camera_id_object__asc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_detections_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="SQL LIMIT operator")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="SQL OFFSET operator")] = None,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        video__load: Annotated[Optional[StrictStr], Field(description="load the given directly related object, value is ignored (presence of key is sufficient)")] = None,
        camera__load: Annotated[Optional[StrictStr], Field(description="load the given directly related object, value is ignored (presence of key is sufficient)")] = None,
        id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        id__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        id__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        created_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        created_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        created_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        created_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        created_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        created_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        created_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        created_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        created_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        created_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        updated_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        updated_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        updated_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        updated_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        updated_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        updated_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        updated_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        updated_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        updated_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        updated_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        deleted_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        deleted_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        deleted_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        deleted_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        deleted_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        deleted_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        deleted_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        deleted_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        deleted_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        deleted_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        seen_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        seen_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        seen_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        seen_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        seen_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        seen_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        seen_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        seen_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        seen_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        seen_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        seen_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        seen_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        class_id__eq: Annotated[Optional[StrictInt], Field(description="SQL = comparison")] = None,
        class_id__ne: Annotated[Optional[StrictInt], Field(description="SQL != comparison")] = None,
        class_id__gt: Annotated[Optional[StrictInt], Field(description="SQL > comparison, may not work with all column types")] = None,
        class_id__gte: Annotated[Optional[StrictInt], Field(description="SQL >= comparison, may not work with all column types")] = None,
        class_id__lt: Annotated[Optional[StrictInt], Field(description="SQL < comparison, may not work with all column types")] = None,
        class_id__lte: Annotated[Optional[StrictInt], Field(description="SQL <= comparison, may not work with all column types")] = None,
        class_id__in: Annotated[Optional[StrictInt], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        class_id__notin: Annotated[Optional[StrictInt], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        class_id__contains: Annotated[Optional[StrictInt], Field(description="SQL @> comparison")] = None,
        class_id__notcontains: Annotated[Optional[StrictInt], Field(description="SQL NOT @> comparison")] = None,
        class_id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        class_id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        class_name__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        class_name__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        class_name__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        class_name__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        class_name__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        class_name__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        class_name__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        class_name__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        class_name__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        class_name__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        class_name__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        class_name__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        score__eq: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL = comparison")] = None,
        score__ne: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL != comparison")] = None,
        score__gt: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL > comparison, may not work with all column types")] = None,
        score__gte: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL >= comparison, may not work with all column types")] = None,
        score__lt: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL < comparison, may not work with all column types")] = None,
        score__lte: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL <= comparison, may not work with all column types")] = None,
        score__in: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        score__notin: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        score__contains: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL @> comparison")] = None,
        score__notcontains: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL NOT @> comparison")] = None,
        score__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        score__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        centroid__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        centroid__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        centroid__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        centroid__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        bounding_box__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        bounding_box__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        bounding_box__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        bounding_box__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        video_id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        video_id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        video_id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        video_id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        video_id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        video_id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        video_id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        video_id__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        video_id__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        video_id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id_object__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        video_id_object__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        video_id_object__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id_object__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        camera_id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        camera_id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        camera_id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        camera_id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        camera_id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        camera_id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        camera_id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        camera_id__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        camera_id__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        camera_id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id_object__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        camera_id_object__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        camera_id_object__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id_object__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ResponseWithGenericOfDetection]:
        """get_detections


        :param limit: SQL LIMIT operator
        :type limit: int
        :param offset: SQL OFFSET operator
        :type offset: int
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param video__load: load the given directly related object, value is ignored (presence of key is sufficient)
        :type video__load: str
        :param camera__load: load the given directly related object, value is ignored (presence of key is sufficient)
        :type camera__load: str
        :param id__eq: SQL = comparison
        :type id__eq: str
        :param id__ne: SQL != comparison
        :type id__ne: str
        :param id__gt: SQL > comparison, may not work with all column types
        :type id__gt: str
        :param id__gte: SQL >= comparison, may not work with all column types
        :type id__gte: str
        :param id__lt: SQL < comparison, may not work with all column types
        :type id__lt: str
        :param id__lte: SQL <= comparison, may not work with all column types
        :type id__lte: str
        :param id__in: SQL IN comparison, permits comma-separated values
        :type id__in: str
        :param id__notin: SQL NOT IN comparison, permits comma-separated values
        :type id__notin: str
        :param id__contains: SQL @> comparison
        :type id__contains: str
        :param id__notcontains: SQL NOT @> comparison
        :type id__notcontains: str
        :param id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__like: str
        :param id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notlike: str
        :param id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__ilike: str
        :param id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notilike: str
        :param id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type id__desc: str
        :param id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type id__asc: str
        :param created_at__eq: SQL = comparison
        :type created_at__eq: datetime
        :param created_at__ne: SQL != comparison
        :type created_at__ne: datetime
        :param created_at__gt: SQL > comparison, may not work with all column types
        :type created_at__gt: datetime
        :param created_at__gte: SQL >= comparison, may not work with all column types
        :type created_at__gte: datetime
        :param created_at__lt: SQL < comparison, may not work with all column types
        :type created_at__lt: datetime
        :param created_at__lte: SQL <= comparison, may not work with all column types
        :type created_at__lte: datetime
        :param created_at__in: SQL IN comparison, permits comma-separated values
        :type created_at__in: datetime
        :param created_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type created_at__notin: datetime
        :param created_at__contains: SQL @> comparison
        :type created_at__contains: datetime
        :param created_at__notcontains: SQL NOT @> comparison
        :type created_at__notcontains: datetime
        :param created_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__like: datetime
        :param created_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notlike: datetime
        :param created_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__ilike: datetime
        :param created_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notilike: datetime
        :param created_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type created_at__desc: str
        :param created_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type created_at__asc: str
        :param updated_at__eq: SQL = comparison
        :type updated_at__eq: datetime
        :param updated_at__ne: SQL != comparison
        :type updated_at__ne: datetime
        :param updated_at__gt: SQL > comparison, may not work with all column types
        :type updated_at__gt: datetime
        :param updated_at__gte: SQL >= comparison, may not work with all column types
        :type updated_at__gte: datetime
        :param updated_at__lt: SQL < comparison, may not work with all column types
        :type updated_at__lt: datetime
        :param updated_at__lte: SQL <= comparison, may not work with all column types
        :type updated_at__lte: datetime
        :param updated_at__in: SQL IN comparison, permits comma-separated values
        :type updated_at__in: datetime
        :param updated_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type updated_at__notin: datetime
        :param updated_at__contains: SQL @> comparison
        :type updated_at__contains: datetime
        :param updated_at__notcontains: SQL NOT @> comparison
        :type updated_at__notcontains: datetime
        :param updated_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__like: datetime
        :param updated_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notlike: datetime
        :param updated_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__ilike: datetime
        :param updated_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notilike: datetime
        :param updated_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type updated_at__desc: str
        :param updated_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type updated_at__asc: str
        :param deleted_at__eq: SQL = comparison
        :type deleted_at__eq: datetime
        :param deleted_at__ne: SQL != comparison
        :type deleted_at__ne: datetime
        :param deleted_at__gt: SQL > comparison, may not work with all column types
        :type deleted_at__gt: datetime
        :param deleted_at__gte: SQL >= comparison, may not work with all column types
        :type deleted_at__gte: datetime
        :param deleted_at__lt: SQL < comparison, may not work with all column types
        :type deleted_at__lt: datetime
        :param deleted_at__lte: SQL <= comparison, may not work with all column types
        :type deleted_at__lte: datetime
        :param deleted_at__in: SQL IN comparison, permits comma-separated values
        :type deleted_at__in: datetime
        :param deleted_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type deleted_at__notin: datetime
        :param deleted_at__contains: SQL @> comparison
        :type deleted_at__contains: datetime
        :param deleted_at__notcontains: SQL NOT @> comparison
        :type deleted_at__notcontains: datetime
        :param deleted_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__like: datetime
        :param deleted_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notlike: datetime
        :param deleted_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__ilike: datetime
        :param deleted_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notilike: datetime
        :param deleted_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__desc: str
        :param deleted_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__asc: str
        :param seen_at__eq: SQL = comparison
        :type seen_at__eq: datetime
        :param seen_at__ne: SQL != comparison
        :type seen_at__ne: datetime
        :param seen_at__gt: SQL > comparison, may not work with all column types
        :type seen_at__gt: datetime
        :param seen_at__gte: SQL >= comparison, may not work with all column types
        :type seen_at__gte: datetime
        :param seen_at__lt: SQL < comparison, may not work with all column types
        :type seen_at__lt: datetime
        :param seen_at__lte: SQL <= comparison, may not work with all column types
        :type seen_at__lte: datetime
        :param seen_at__in: SQL IN comparison, permits comma-separated values
        :type seen_at__in: datetime
        :param seen_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type seen_at__notin: datetime
        :param seen_at__contains: SQL @> comparison
        :type seen_at__contains: datetime
        :param seen_at__notcontains: SQL NOT @> comparison
        :type seen_at__notcontains: datetime
        :param seen_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__like: datetime
        :param seen_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__notlike: datetime
        :param seen_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__ilike: datetime
        :param seen_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__notilike: datetime
        :param seen_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type seen_at__desc: str
        :param seen_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type seen_at__asc: str
        :param class_id__eq: SQL = comparison
        :type class_id__eq: int
        :param class_id__ne: SQL != comparison
        :type class_id__ne: int
        :param class_id__gt: SQL > comparison, may not work with all column types
        :type class_id__gt: int
        :param class_id__gte: SQL >= comparison, may not work with all column types
        :type class_id__gte: int
        :param class_id__lt: SQL < comparison, may not work with all column types
        :type class_id__lt: int
        :param class_id__lte: SQL <= comparison, may not work with all column types
        :type class_id__lte: int
        :param class_id__in: SQL IN comparison, permits comma-separated values
        :type class_id__in: int
        :param class_id__notin: SQL NOT IN comparison, permits comma-separated values
        :type class_id__notin: int
        :param class_id__contains: SQL @> comparison
        :type class_id__contains: int
        :param class_id__notcontains: SQL NOT @> comparison
        :type class_id__notcontains: int
        :param class_id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type class_id__desc: str
        :param class_id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type class_id__asc: str
        :param class_name__eq: SQL = comparison
        :type class_name__eq: str
        :param class_name__ne: SQL != comparison
        :type class_name__ne: str
        :param class_name__gt: SQL > comparison, may not work with all column types
        :type class_name__gt: str
        :param class_name__gte: SQL >= comparison, may not work with all column types
        :type class_name__gte: str
        :param class_name__lt: SQL < comparison, may not work with all column types
        :type class_name__lt: str
        :param class_name__lte: SQL <= comparison, may not work with all column types
        :type class_name__lte: str
        :param class_name__in: SQL IN comparison, permits comma-separated values
        :type class_name__in: str
        :param class_name__notin: SQL NOT IN comparison, permits comma-separated values
        :type class_name__notin: str
        :param class_name__contains: SQL @> comparison
        :type class_name__contains: str
        :param class_name__notcontains: SQL NOT @> comparison
        :type class_name__notcontains: str
        :param class_name__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__like: str
        :param class_name__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__notlike: str
        :param class_name__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__ilike: str
        :param class_name__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__notilike: str
        :param class_name__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type class_name__desc: str
        :param class_name__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type class_name__asc: str
        :param score__eq: SQL = comparison
        :type score__eq: float
        :param score__ne: SQL != comparison
        :type score__ne: float
        :param score__gt: SQL > comparison, may not work with all column types
        :type score__gt: float
        :param score__gte: SQL >= comparison, may not work with all column types
        :type score__gte: float
        :param score__lt: SQL < comparison, may not work with all column types
        :type score__lt: float
        :param score__lte: SQL <= comparison, may not work with all column types
        :type score__lte: float
        :param score__in: SQL IN comparison, permits comma-separated values
        :type score__in: float
        :param score__notin: SQL NOT IN comparison, permits comma-separated values
        :type score__notin: float
        :param score__contains: SQL @> comparison
        :type score__contains: float
        :param score__notcontains: SQL NOT @> comparison
        :type score__notcontains: float
        :param score__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type score__desc: str
        :param score__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type score__asc: str
        :param centroid__contains: SQL @> comparison
        :type centroid__contains: object
        :param centroid__notcontains: SQL NOT @> comparison
        :type centroid__notcontains: object
        :param centroid__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type centroid__desc: str
        :param centroid__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type centroid__asc: str
        :param bounding_box__contains: SQL @> comparison
        :type bounding_box__contains: object
        :param bounding_box__notcontains: SQL NOT @> comparison
        :type bounding_box__notcontains: object
        :param bounding_box__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type bounding_box__desc: str
        :param bounding_box__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type bounding_box__asc: str
        :param video_id__eq: SQL = comparison
        :type video_id__eq: str
        :param video_id__ne: SQL != comparison
        :type video_id__ne: str
        :param video_id__gt: SQL > comparison, may not work with all column types
        :type video_id__gt: str
        :param video_id__gte: SQL >= comparison, may not work with all column types
        :type video_id__gte: str
        :param video_id__lt: SQL < comparison, may not work with all column types
        :type video_id__lt: str
        :param video_id__lte: SQL <= comparison, may not work with all column types
        :type video_id__lte: str
        :param video_id__in: SQL IN comparison, permits comma-separated values
        :type video_id__in: str
        :param video_id__notin: SQL NOT IN comparison, permits comma-separated values
        :type video_id__notin: str
        :param video_id__contains: SQL @> comparison
        :type video_id__contains: str
        :param video_id__notcontains: SQL NOT @> comparison
        :type video_id__notcontains: str
        :param video_id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__like: str
        :param video_id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__notlike: str
        :param video_id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__ilike: str
        :param video_id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__notilike: str
        :param video_id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type video_id__desc: str
        :param video_id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type video_id__asc: str
        :param video_id_object__contains: SQL @> comparison
        :type video_id_object__contains: object
        :param video_id_object__notcontains: SQL NOT @> comparison
        :type video_id_object__notcontains: object
        :param video_id_object__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type video_id_object__desc: str
        :param video_id_object__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type video_id_object__asc: str
        :param camera_id__eq: SQL = comparison
        :type camera_id__eq: str
        :param camera_id__ne: SQL != comparison
        :type camera_id__ne: str
        :param camera_id__gt: SQL > comparison, may not work with all column types
        :type camera_id__gt: str
        :param camera_id__gte: SQL >= comparison, may not work with all column types
        :type camera_id__gte: str
        :param camera_id__lt: SQL < comparison, may not work with all column types
        :type camera_id__lt: str
        :param camera_id__lte: SQL <= comparison, may not work with all column types
        :type camera_id__lte: str
        :param camera_id__in: SQL IN comparison, permits comma-separated values
        :type camera_id__in: str
        :param camera_id__notin: SQL NOT IN comparison, permits comma-separated values
        :type camera_id__notin: str
        :param camera_id__contains: SQL @> comparison
        :type camera_id__contains: str
        :param camera_id__notcontains: SQL NOT @> comparison
        :type camera_id__notcontains: str
        :param camera_id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__like: str
        :param camera_id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__notlike: str
        :param camera_id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__ilike: str
        :param camera_id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__notilike: str
        :param camera_id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type camera_id__desc: str
        :param camera_id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type camera_id__asc: str
        :param camera_id_object__contains: SQL @> comparison
        :type camera_id_object__contains: object
        :param camera_id_object__notcontains: SQL NOT @> comparison
        :type camera_id_object__notcontains: object
        :param camera_id_object__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type camera_id_object__desc: str
        :param camera_id_object__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type camera_id_object__asc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_detections_serialize(
            limit=limit,
            offset=offset,
            depth=depth,
            video__load=video__load,
            camera__load=camera__load,
            id__eq=id__eq,
            id__ne=id__ne,
            id__gt=id__gt,
            id__gte=id__gte,
            id__lt=id__lt,
            id__lte=id__lte,
            id__in=id__in,
            id__notin=id__notin,
            id__contains=id__contains,
            id__notcontains=id__notcontains,
            id__like=id__like,
            id__notlike=id__notlike,
            id__ilike=id__ilike,
            id__notilike=id__notilike,
            id__desc=id__desc,
            id__asc=id__asc,
            created_at__eq=created_at__eq,
            created_at__ne=created_at__ne,
            created_at__gt=created_at__gt,
            created_at__gte=created_at__gte,
            created_at__lt=created_at__lt,
            created_at__lte=created_at__lte,
            created_at__in=created_at__in,
            created_at__notin=created_at__notin,
            created_at__contains=created_at__contains,
            created_at__notcontains=created_at__notcontains,
            created_at__like=created_at__like,
            created_at__notlike=created_at__notlike,
            created_at__ilike=created_at__ilike,
            created_at__notilike=created_at__notilike,
            created_at__desc=created_at__desc,
            created_at__asc=created_at__asc,
            updated_at__eq=updated_at__eq,
            updated_at__ne=updated_at__ne,
            updated_at__gt=updated_at__gt,
            updated_at__gte=updated_at__gte,
            updated_at__lt=updated_at__lt,
            updated_at__lte=updated_at__lte,
            updated_at__in=updated_at__in,
            updated_at__notin=updated_at__notin,
            updated_at__contains=updated_at__contains,
            updated_at__notcontains=updated_at__notcontains,
            updated_at__like=updated_at__like,
            updated_at__notlike=updated_at__notlike,
            updated_at__ilike=updated_at__ilike,
            updated_at__notilike=updated_at__notilike,
            updated_at__desc=updated_at__desc,
            updated_at__asc=updated_at__asc,
            deleted_at__eq=deleted_at__eq,
            deleted_at__ne=deleted_at__ne,
            deleted_at__gt=deleted_at__gt,
            deleted_at__gte=deleted_at__gte,
            deleted_at__lt=deleted_at__lt,
            deleted_at__lte=deleted_at__lte,
            deleted_at__in=deleted_at__in,
            deleted_at__notin=deleted_at__notin,
            deleted_at__contains=deleted_at__contains,
            deleted_at__notcontains=deleted_at__notcontains,
            deleted_at__like=deleted_at__like,
            deleted_at__notlike=deleted_at__notlike,
            deleted_at__ilike=deleted_at__ilike,
            deleted_at__notilike=deleted_at__notilike,
            deleted_at__desc=deleted_at__desc,
            deleted_at__asc=deleted_at__asc,
            seen_at__eq=seen_at__eq,
            seen_at__ne=seen_at__ne,
            seen_at__gt=seen_at__gt,
            seen_at__gte=seen_at__gte,
            seen_at__lt=seen_at__lt,
            seen_at__lte=seen_at__lte,
            seen_at__in=seen_at__in,
            seen_at__notin=seen_at__notin,
            seen_at__contains=seen_at__contains,
            seen_at__notcontains=seen_at__notcontains,
            seen_at__like=seen_at__like,
            seen_at__notlike=seen_at__notlike,
            seen_at__ilike=seen_at__ilike,
            seen_at__notilike=seen_at__notilike,
            seen_at__desc=seen_at__desc,
            seen_at__asc=seen_at__asc,
            class_id__eq=class_id__eq,
            class_id__ne=class_id__ne,
            class_id__gt=class_id__gt,
            class_id__gte=class_id__gte,
            class_id__lt=class_id__lt,
            class_id__lte=class_id__lte,
            class_id__in=class_id__in,
            class_id__notin=class_id__notin,
            class_id__contains=class_id__contains,
            class_id__notcontains=class_id__notcontains,
            class_id__desc=class_id__desc,
            class_id__asc=class_id__asc,
            class_name__eq=class_name__eq,
            class_name__ne=class_name__ne,
            class_name__gt=class_name__gt,
            class_name__gte=class_name__gte,
            class_name__lt=class_name__lt,
            class_name__lte=class_name__lte,
            class_name__in=class_name__in,
            class_name__notin=class_name__notin,
            class_name__contains=class_name__contains,
            class_name__notcontains=class_name__notcontains,
            class_name__like=class_name__like,
            class_name__notlike=class_name__notlike,
            class_name__ilike=class_name__ilike,
            class_name__notilike=class_name__notilike,
            class_name__desc=class_name__desc,
            class_name__asc=class_name__asc,
            score__eq=score__eq,
            score__ne=score__ne,
            score__gt=score__gt,
            score__gte=score__gte,
            score__lt=score__lt,
            score__lte=score__lte,
            score__in=score__in,
            score__notin=score__notin,
            score__contains=score__contains,
            score__notcontains=score__notcontains,
            score__desc=score__desc,
            score__asc=score__asc,
            centroid__contains=centroid__contains,
            centroid__notcontains=centroid__notcontains,
            centroid__desc=centroid__desc,
            centroid__asc=centroid__asc,
            bounding_box__contains=bounding_box__contains,
            bounding_box__notcontains=bounding_box__notcontains,
            bounding_box__desc=bounding_box__desc,
            bounding_box__asc=bounding_box__asc,
            video_id__eq=video_id__eq,
            video_id__ne=video_id__ne,
            video_id__gt=video_id__gt,
            video_id__gte=video_id__gte,
            video_id__lt=video_id__lt,
            video_id__lte=video_id__lte,
            video_id__in=video_id__in,
            video_id__notin=video_id__notin,
            video_id__contains=video_id__contains,
            video_id__notcontains=video_id__notcontains,
            video_id__like=video_id__like,
            video_id__notlike=video_id__notlike,
            video_id__ilike=video_id__ilike,
            video_id__notilike=video_id__notilike,
            video_id__desc=video_id__desc,
            video_id__asc=video_id__asc,
            video_id_object__contains=video_id_object__contains,
            video_id_object__notcontains=video_id_object__notcontains,
            video_id_object__desc=video_id_object__desc,
            video_id_object__asc=video_id_object__asc,
            camera_id__eq=camera_id__eq,
            camera_id__ne=camera_id__ne,
            camera_id__gt=camera_id__gt,
            camera_id__gte=camera_id__gte,
            camera_id__lt=camera_id__lt,
            camera_id__lte=camera_id__lte,
            camera_id__in=camera_id__in,
            camera_id__notin=camera_id__notin,
            camera_id__contains=camera_id__contains,
            camera_id__notcontains=camera_id__notcontains,
            camera_id__like=camera_id__like,
            camera_id__notlike=camera_id__notlike,
            camera_id__ilike=camera_id__ilike,
            camera_id__notilike=camera_id__notilike,
            camera_id__desc=camera_id__desc,
            camera_id__asc=camera_id__asc,
            camera_id_object__contains=camera_id_object__contains,
            camera_id_object__notcontains=camera_id_object__notcontains,
            camera_id_object__desc=camera_id_object__desc,
            camera_id_object__asc=camera_id_object__asc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_detections_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="SQL LIMIT operator")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="SQL OFFSET operator")] = None,
        depth: Annotated[Optional[StrictInt], Field(description="Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)")] = None,
        video__load: Annotated[Optional[StrictStr], Field(description="load the given directly related object, value is ignored (presence of key is sufficient)")] = None,
        camera__load: Annotated[Optional[StrictStr], Field(description="load the given directly related object, value is ignored (presence of key is sufficient)")] = None,
        id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        id__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        id__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        created_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        created_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        created_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        created_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        created_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        created_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        created_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        created_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        created_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        created_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        created_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        created_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        updated_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        updated_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        updated_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        updated_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        updated_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        updated_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        updated_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        updated_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        updated_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        updated_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        updated_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        updated_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        deleted_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        deleted_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        deleted_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        deleted_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        deleted_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        deleted_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        deleted_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        deleted_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        deleted_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        deleted_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        deleted_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        deleted_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        seen_at__eq: Annotated[Optional[datetime], Field(description="SQL = comparison")] = None,
        seen_at__ne: Annotated[Optional[datetime], Field(description="SQL != comparison")] = None,
        seen_at__gt: Annotated[Optional[datetime], Field(description="SQL > comparison, may not work with all column types")] = None,
        seen_at__gte: Annotated[Optional[datetime], Field(description="SQL >= comparison, may not work with all column types")] = None,
        seen_at__lt: Annotated[Optional[datetime], Field(description="SQL < comparison, may not work with all column types")] = None,
        seen_at__lte: Annotated[Optional[datetime], Field(description="SQL <= comparison, may not work with all column types")] = None,
        seen_at__in: Annotated[Optional[datetime], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        seen_at__notin: Annotated[Optional[datetime], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        seen_at__contains: Annotated[Optional[datetime], Field(description="SQL @> comparison")] = None,
        seen_at__notcontains: Annotated[Optional[datetime], Field(description="SQL NOT @> comparison")] = None,
        seen_at__like: Annotated[Optional[datetime], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__notlike: Annotated[Optional[datetime], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__ilike: Annotated[Optional[datetime], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__notilike: Annotated[Optional[datetime], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        seen_at__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        seen_at__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        class_id__eq: Annotated[Optional[StrictInt], Field(description="SQL = comparison")] = None,
        class_id__ne: Annotated[Optional[StrictInt], Field(description="SQL != comparison")] = None,
        class_id__gt: Annotated[Optional[StrictInt], Field(description="SQL > comparison, may not work with all column types")] = None,
        class_id__gte: Annotated[Optional[StrictInt], Field(description="SQL >= comparison, may not work with all column types")] = None,
        class_id__lt: Annotated[Optional[StrictInt], Field(description="SQL < comparison, may not work with all column types")] = None,
        class_id__lte: Annotated[Optional[StrictInt], Field(description="SQL <= comparison, may not work with all column types")] = None,
        class_id__in: Annotated[Optional[StrictInt], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        class_id__notin: Annotated[Optional[StrictInt], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        class_id__contains: Annotated[Optional[StrictInt], Field(description="SQL @> comparison")] = None,
        class_id__notcontains: Annotated[Optional[StrictInt], Field(description="SQL NOT @> comparison")] = None,
        class_id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        class_id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        class_name__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        class_name__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        class_name__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        class_name__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        class_name__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        class_name__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        class_name__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        class_name__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        class_name__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        class_name__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        class_name__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        class_name__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        class_name__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        score__eq: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL = comparison")] = None,
        score__ne: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL != comparison")] = None,
        score__gt: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL > comparison, may not work with all column types")] = None,
        score__gte: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL >= comparison, may not work with all column types")] = None,
        score__lt: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL < comparison, may not work with all column types")] = None,
        score__lte: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL <= comparison, may not work with all column types")] = None,
        score__in: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        score__notin: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        score__contains: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL @> comparison")] = None,
        score__notcontains: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="SQL NOT @> comparison")] = None,
        score__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        score__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        centroid__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        centroid__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        centroid__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        centroid__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        bounding_box__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        bounding_box__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        bounding_box__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        bounding_box__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        video_id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        video_id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        video_id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        video_id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        video_id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        video_id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        video_id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        video_id__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        video_id__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        video_id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        video_id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id_object__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        video_id_object__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        video_id_object__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        video_id_object__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id__eq: Annotated[Optional[StrictStr], Field(description="SQL = comparison")] = None,
        camera_id__ne: Annotated[Optional[StrictStr], Field(description="SQL != comparison")] = None,
        camera_id__gt: Annotated[Optional[StrictStr], Field(description="SQL > comparison, may not work with all column types")] = None,
        camera_id__gte: Annotated[Optional[StrictStr], Field(description="SQL >= comparison, may not work with all column types")] = None,
        camera_id__lt: Annotated[Optional[StrictStr], Field(description="SQL < comparison, may not work with all column types")] = None,
        camera_id__lte: Annotated[Optional[StrictStr], Field(description="SQL <= comparison, may not work with all column types")] = None,
        camera_id__in: Annotated[Optional[StrictStr], Field(description="SQL IN comparison, permits comma-separated values")] = None,
        camera_id__notin: Annotated[Optional[StrictStr], Field(description="SQL NOT IN comparison, permits comma-separated values")] = None,
        camera_id__contains: Annotated[Optional[StrictStr], Field(description="SQL @> comparison")] = None,
        camera_id__notcontains: Annotated[Optional[StrictStr], Field(description="SQL NOT @> comparison")] = None,
        camera_id__like: Annotated[Optional[StrictStr], Field(description="SQL LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__notlike: Annotated[Optional[StrictStr], Field(description="SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__ilike: Annotated[Optional[StrictStr], Field(description="SQL ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__notilike: Annotated[Optional[StrictStr], Field(description="SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %")] = None,
        camera_id__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id_object__contains: Annotated[Optional[Any], Field(description="SQL @> comparison")] = None,
        camera_id_object__notcontains: Annotated[Optional[Any], Field(description="SQL NOT @> comparison")] = None,
        camera_id_object__desc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)")] = None,
        camera_id_object__asc: Annotated[Optional[StrictStr], Field(description="SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_detections


        :param limit: SQL LIMIT operator
        :type limit: int
        :param offset: SQL OFFSET operator
        :type offset: int
        :param depth: Max recursion depth for loading foreign objects; default = 1  (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc)
        :type depth: int
        :param video__load: load the given directly related object, value is ignored (presence of key is sufficient)
        :type video__load: str
        :param camera__load: load the given directly related object, value is ignored (presence of key is sufficient)
        :type camera__load: str
        :param id__eq: SQL = comparison
        :type id__eq: str
        :param id__ne: SQL != comparison
        :type id__ne: str
        :param id__gt: SQL > comparison, may not work with all column types
        :type id__gt: str
        :param id__gte: SQL >= comparison, may not work with all column types
        :type id__gte: str
        :param id__lt: SQL < comparison, may not work with all column types
        :type id__lt: str
        :param id__lte: SQL <= comparison, may not work with all column types
        :type id__lte: str
        :param id__in: SQL IN comparison, permits comma-separated values
        :type id__in: str
        :param id__notin: SQL NOT IN comparison, permits comma-separated values
        :type id__notin: str
        :param id__contains: SQL @> comparison
        :type id__contains: str
        :param id__notcontains: SQL NOT @> comparison
        :type id__notcontains: str
        :param id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__like: str
        :param id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notlike: str
        :param id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__ilike: str
        :param id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type id__notilike: str
        :param id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type id__desc: str
        :param id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type id__asc: str
        :param created_at__eq: SQL = comparison
        :type created_at__eq: datetime
        :param created_at__ne: SQL != comparison
        :type created_at__ne: datetime
        :param created_at__gt: SQL > comparison, may not work with all column types
        :type created_at__gt: datetime
        :param created_at__gte: SQL >= comparison, may not work with all column types
        :type created_at__gte: datetime
        :param created_at__lt: SQL < comparison, may not work with all column types
        :type created_at__lt: datetime
        :param created_at__lte: SQL <= comparison, may not work with all column types
        :type created_at__lte: datetime
        :param created_at__in: SQL IN comparison, permits comma-separated values
        :type created_at__in: datetime
        :param created_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type created_at__notin: datetime
        :param created_at__contains: SQL @> comparison
        :type created_at__contains: datetime
        :param created_at__notcontains: SQL NOT @> comparison
        :type created_at__notcontains: datetime
        :param created_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__like: datetime
        :param created_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notlike: datetime
        :param created_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__ilike: datetime
        :param created_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type created_at__notilike: datetime
        :param created_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type created_at__desc: str
        :param created_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type created_at__asc: str
        :param updated_at__eq: SQL = comparison
        :type updated_at__eq: datetime
        :param updated_at__ne: SQL != comparison
        :type updated_at__ne: datetime
        :param updated_at__gt: SQL > comparison, may not work with all column types
        :type updated_at__gt: datetime
        :param updated_at__gte: SQL >= comparison, may not work with all column types
        :type updated_at__gte: datetime
        :param updated_at__lt: SQL < comparison, may not work with all column types
        :type updated_at__lt: datetime
        :param updated_at__lte: SQL <= comparison, may not work with all column types
        :type updated_at__lte: datetime
        :param updated_at__in: SQL IN comparison, permits comma-separated values
        :type updated_at__in: datetime
        :param updated_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type updated_at__notin: datetime
        :param updated_at__contains: SQL @> comparison
        :type updated_at__contains: datetime
        :param updated_at__notcontains: SQL NOT @> comparison
        :type updated_at__notcontains: datetime
        :param updated_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__like: datetime
        :param updated_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notlike: datetime
        :param updated_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__ilike: datetime
        :param updated_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type updated_at__notilike: datetime
        :param updated_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type updated_at__desc: str
        :param updated_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type updated_at__asc: str
        :param deleted_at__eq: SQL = comparison
        :type deleted_at__eq: datetime
        :param deleted_at__ne: SQL != comparison
        :type deleted_at__ne: datetime
        :param deleted_at__gt: SQL > comparison, may not work with all column types
        :type deleted_at__gt: datetime
        :param deleted_at__gte: SQL >= comparison, may not work with all column types
        :type deleted_at__gte: datetime
        :param deleted_at__lt: SQL < comparison, may not work with all column types
        :type deleted_at__lt: datetime
        :param deleted_at__lte: SQL <= comparison, may not work with all column types
        :type deleted_at__lte: datetime
        :param deleted_at__in: SQL IN comparison, permits comma-separated values
        :type deleted_at__in: datetime
        :param deleted_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type deleted_at__notin: datetime
        :param deleted_at__contains: SQL @> comparison
        :type deleted_at__contains: datetime
        :param deleted_at__notcontains: SQL NOT @> comparison
        :type deleted_at__notcontains: datetime
        :param deleted_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__like: datetime
        :param deleted_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notlike: datetime
        :param deleted_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__ilike: datetime
        :param deleted_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type deleted_at__notilike: datetime
        :param deleted_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__desc: str
        :param deleted_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type deleted_at__asc: str
        :param seen_at__eq: SQL = comparison
        :type seen_at__eq: datetime
        :param seen_at__ne: SQL != comparison
        :type seen_at__ne: datetime
        :param seen_at__gt: SQL > comparison, may not work with all column types
        :type seen_at__gt: datetime
        :param seen_at__gte: SQL >= comparison, may not work with all column types
        :type seen_at__gte: datetime
        :param seen_at__lt: SQL < comparison, may not work with all column types
        :type seen_at__lt: datetime
        :param seen_at__lte: SQL <= comparison, may not work with all column types
        :type seen_at__lte: datetime
        :param seen_at__in: SQL IN comparison, permits comma-separated values
        :type seen_at__in: datetime
        :param seen_at__notin: SQL NOT IN comparison, permits comma-separated values
        :type seen_at__notin: datetime
        :param seen_at__contains: SQL @> comparison
        :type seen_at__contains: datetime
        :param seen_at__notcontains: SQL NOT @> comparison
        :type seen_at__notcontains: datetime
        :param seen_at__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__like: datetime
        :param seen_at__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__notlike: datetime
        :param seen_at__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__ilike: datetime
        :param seen_at__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type seen_at__notilike: datetime
        :param seen_at__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type seen_at__desc: str
        :param seen_at__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type seen_at__asc: str
        :param class_id__eq: SQL = comparison
        :type class_id__eq: int
        :param class_id__ne: SQL != comparison
        :type class_id__ne: int
        :param class_id__gt: SQL > comparison, may not work with all column types
        :type class_id__gt: int
        :param class_id__gte: SQL >= comparison, may not work with all column types
        :type class_id__gte: int
        :param class_id__lt: SQL < comparison, may not work with all column types
        :type class_id__lt: int
        :param class_id__lte: SQL <= comparison, may not work with all column types
        :type class_id__lte: int
        :param class_id__in: SQL IN comparison, permits comma-separated values
        :type class_id__in: int
        :param class_id__notin: SQL NOT IN comparison, permits comma-separated values
        :type class_id__notin: int
        :param class_id__contains: SQL @> comparison
        :type class_id__contains: int
        :param class_id__notcontains: SQL NOT @> comparison
        :type class_id__notcontains: int
        :param class_id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type class_id__desc: str
        :param class_id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type class_id__asc: str
        :param class_name__eq: SQL = comparison
        :type class_name__eq: str
        :param class_name__ne: SQL != comparison
        :type class_name__ne: str
        :param class_name__gt: SQL > comparison, may not work with all column types
        :type class_name__gt: str
        :param class_name__gte: SQL >= comparison, may not work with all column types
        :type class_name__gte: str
        :param class_name__lt: SQL < comparison, may not work with all column types
        :type class_name__lt: str
        :param class_name__lte: SQL <= comparison, may not work with all column types
        :type class_name__lte: str
        :param class_name__in: SQL IN comparison, permits comma-separated values
        :type class_name__in: str
        :param class_name__notin: SQL NOT IN comparison, permits comma-separated values
        :type class_name__notin: str
        :param class_name__contains: SQL @> comparison
        :type class_name__contains: str
        :param class_name__notcontains: SQL NOT @> comparison
        :type class_name__notcontains: str
        :param class_name__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__like: str
        :param class_name__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__notlike: str
        :param class_name__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__ilike: str
        :param class_name__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type class_name__notilike: str
        :param class_name__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type class_name__desc: str
        :param class_name__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type class_name__asc: str
        :param score__eq: SQL = comparison
        :type score__eq: float
        :param score__ne: SQL != comparison
        :type score__ne: float
        :param score__gt: SQL > comparison, may not work with all column types
        :type score__gt: float
        :param score__gte: SQL >= comparison, may not work with all column types
        :type score__gte: float
        :param score__lt: SQL < comparison, may not work with all column types
        :type score__lt: float
        :param score__lte: SQL <= comparison, may not work with all column types
        :type score__lte: float
        :param score__in: SQL IN comparison, permits comma-separated values
        :type score__in: float
        :param score__notin: SQL NOT IN comparison, permits comma-separated values
        :type score__notin: float
        :param score__contains: SQL @> comparison
        :type score__contains: float
        :param score__notcontains: SQL NOT @> comparison
        :type score__notcontains: float
        :param score__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type score__desc: str
        :param score__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type score__asc: str
        :param centroid__contains: SQL @> comparison
        :type centroid__contains: object
        :param centroid__notcontains: SQL NOT @> comparison
        :type centroid__notcontains: object
        :param centroid__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type centroid__desc: str
        :param centroid__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type centroid__asc: str
        :param bounding_box__contains: SQL @> comparison
        :type bounding_box__contains: object
        :param bounding_box__notcontains: SQL NOT @> comparison
        :type bounding_box__notcontains: object
        :param bounding_box__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type bounding_box__desc: str
        :param bounding_box__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type bounding_box__asc: str
        :param video_id__eq: SQL = comparison
        :type video_id__eq: str
        :param video_id__ne: SQL != comparison
        :type video_id__ne: str
        :param video_id__gt: SQL > comparison, may not work with all column types
        :type video_id__gt: str
        :param video_id__gte: SQL >= comparison, may not work with all column types
        :type video_id__gte: str
        :param video_id__lt: SQL < comparison, may not work with all column types
        :type video_id__lt: str
        :param video_id__lte: SQL <= comparison, may not work with all column types
        :type video_id__lte: str
        :param video_id__in: SQL IN comparison, permits comma-separated values
        :type video_id__in: str
        :param video_id__notin: SQL NOT IN comparison, permits comma-separated values
        :type video_id__notin: str
        :param video_id__contains: SQL @> comparison
        :type video_id__contains: str
        :param video_id__notcontains: SQL NOT @> comparison
        :type video_id__notcontains: str
        :param video_id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__like: str
        :param video_id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__notlike: str
        :param video_id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__ilike: str
        :param video_id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type video_id__notilike: str
        :param video_id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type video_id__desc: str
        :param video_id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type video_id__asc: str
        :param video_id_object__contains: SQL @> comparison
        :type video_id_object__contains: object
        :param video_id_object__notcontains: SQL NOT @> comparison
        :type video_id_object__notcontains: object
        :param video_id_object__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type video_id_object__desc: str
        :param video_id_object__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type video_id_object__asc: str
        :param camera_id__eq: SQL = comparison
        :type camera_id__eq: str
        :param camera_id__ne: SQL != comparison
        :type camera_id__ne: str
        :param camera_id__gt: SQL > comparison, may not work with all column types
        :type camera_id__gt: str
        :param camera_id__gte: SQL >= comparison, may not work with all column types
        :type camera_id__gte: str
        :param camera_id__lt: SQL < comparison, may not work with all column types
        :type camera_id__lt: str
        :param camera_id__lte: SQL <= comparison, may not work with all column types
        :type camera_id__lte: str
        :param camera_id__in: SQL IN comparison, permits comma-separated values
        :type camera_id__in: str
        :param camera_id__notin: SQL NOT IN comparison, permits comma-separated values
        :type camera_id__notin: str
        :param camera_id__contains: SQL @> comparison
        :type camera_id__contains: str
        :param camera_id__notcontains: SQL NOT @> comparison
        :type camera_id__notcontains: str
        :param camera_id__like: SQL LIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__like: str
        :param camera_id__notlike: SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__notlike: str
        :param camera_id__ilike: SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__ilike: str
        :param camera_id__notilike: SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
        :type camera_id__notilike: str
        :param camera_id__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type camera_id__desc: str
        :param camera_id__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type camera_id__asc: str
        :param camera_id_object__contains: SQL @> comparison
        :type camera_id_object__contains: object
        :param camera_id_object__notcontains: SQL NOT @> comparison
        :type camera_id_object__notcontains: object
        :param camera_id_object__desc: SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
        :type camera_id_object__desc: str
        :param camera_id_object__asc: SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
        :type camera_id_object__asc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_detections_serialize(
            limit=limit,
            offset=offset,
            depth=depth,
            video__load=video__load,
            camera__load=camera__load,
            id__eq=id__eq,
            id__ne=id__ne,
            id__gt=id__gt,
            id__gte=id__gte,
            id__lt=id__lt,
            id__lte=id__lte,
            id__in=id__in,
            id__notin=id__notin,
            id__contains=id__contains,
            id__notcontains=id__notcontains,
            id__like=id__like,
            id__notlike=id__notlike,
            id__ilike=id__ilike,
            id__notilike=id__notilike,
            id__desc=id__desc,
            id__asc=id__asc,
            created_at__eq=created_at__eq,
            created_at__ne=created_at__ne,
            created_at__gt=created_at__gt,
            created_at__gte=created_at__gte,
            created_at__lt=created_at__lt,
            created_at__lte=created_at__lte,
            created_at__in=created_at__in,
            created_at__notin=created_at__notin,
            created_at__contains=created_at__contains,
            created_at__notcontains=created_at__notcontains,
            created_at__like=created_at__like,
            created_at__notlike=created_at__notlike,
            created_at__ilike=created_at__ilike,
            created_at__notilike=created_at__notilike,
            created_at__desc=created_at__desc,
            created_at__asc=created_at__asc,
            updated_at__eq=updated_at__eq,
            updated_at__ne=updated_at__ne,
            updated_at__gt=updated_at__gt,
            updated_at__gte=updated_at__gte,
            updated_at__lt=updated_at__lt,
            updated_at__lte=updated_at__lte,
            updated_at__in=updated_at__in,
            updated_at__notin=updated_at__notin,
            updated_at__contains=updated_at__contains,
            updated_at__notcontains=updated_at__notcontains,
            updated_at__like=updated_at__like,
            updated_at__notlike=updated_at__notlike,
            updated_at__ilike=updated_at__ilike,
            updated_at__notilike=updated_at__notilike,
            updated_at__desc=updated_at__desc,
            updated_at__asc=updated_at__asc,
            deleted_at__eq=deleted_at__eq,
            deleted_at__ne=deleted_at__ne,
            deleted_at__gt=deleted_at__gt,
            deleted_at__gte=deleted_at__gte,
            deleted_at__lt=deleted_at__lt,
            deleted_at__lte=deleted_at__lte,
            deleted_at__in=deleted_at__in,
            deleted_at__notin=deleted_at__notin,
            deleted_at__contains=deleted_at__contains,
            deleted_at__notcontains=deleted_at__notcontains,
            deleted_at__like=deleted_at__like,
            deleted_at__notlike=deleted_at__notlike,
            deleted_at__ilike=deleted_at__ilike,
            deleted_at__notilike=deleted_at__notilike,
            deleted_at__desc=deleted_at__desc,
            deleted_at__asc=deleted_at__asc,
            seen_at__eq=seen_at__eq,
            seen_at__ne=seen_at__ne,
            seen_at__gt=seen_at__gt,
            seen_at__gte=seen_at__gte,
            seen_at__lt=seen_at__lt,
            seen_at__lte=seen_at__lte,
            seen_at__in=seen_at__in,
            seen_at__notin=seen_at__notin,
            seen_at__contains=seen_at__contains,
            seen_at__notcontains=seen_at__notcontains,
            seen_at__like=seen_at__like,
            seen_at__notlike=seen_at__notlike,
            seen_at__ilike=seen_at__ilike,
            seen_at__notilike=seen_at__notilike,
            seen_at__desc=seen_at__desc,
            seen_at__asc=seen_at__asc,
            class_id__eq=class_id__eq,
            class_id__ne=class_id__ne,
            class_id__gt=class_id__gt,
            class_id__gte=class_id__gte,
            class_id__lt=class_id__lt,
            class_id__lte=class_id__lte,
            class_id__in=class_id__in,
            class_id__notin=class_id__notin,
            class_id__contains=class_id__contains,
            class_id__notcontains=class_id__notcontains,
            class_id__desc=class_id__desc,
            class_id__asc=class_id__asc,
            class_name__eq=class_name__eq,
            class_name__ne=class_name__ne,
            class_name__gt=class_name__gt,
            class_name__gte=class_name__gte,
            class_name__lt=class_name__lt,
            class_name__lte=class_name__lte,
            class_name__in=class_name__in,
            class_name__notin=class_name__notin,
            class_name__contains=class_name__contains,
            class_name__notcontains=class_name__notcontains,
            class_name__like=class_name__like,
            class_name__notlike=class_name__notlike,
            class_name__ilike=class_name__ilike,
            class_name__notilike=class_name__notilike,
            class_name__desc=class_name__desc,
            class_name__asc=class_name__asc,
            score__eq=score__eq,
            score__ne=score__ne,
            score__gt=score__gt,
            score__gte=score__gte,
            score__lt=score__lt,
            score__lte=score__lte,
            score__in=score__in,
            score__notin=score__notin,
            score__contains=score__contains,
            score__notcontains=score__notcontains,
            score__desc=score__desc,
            score__asc=score__asc,
            centroid__contains=centroid__contains,
            centroid__notcontains=centroid__notcontains,
            centroid__desc=centroid__desc,
            centroid__asc=centroid__asc,
            bounding_box__contains=bounding_box__contains,
            bounding_box__notcontains=bounding_box__notcontains,
            bounding_box__desc=bounding_box__desc,
            bounding_box__asc=bounding_box__asc,
            video_id__eq=video_id__eq,
            video_id__ne=video_id__ne,
            video_id__gt=video_id__gt,
            video_id__gte=video_id__gte,
            video_id__lt=video_id__lt,
            video_id__lte=video_id__lte,
            video_id__in=video_id__in,
            video_id__notin=video_id__notin,
            video_id__contains=video_id__contains,
            video_id__notcontains=video_id__notcontains,
            video_id__like=video_id__like,
            video_id__notlike=video_id__notlike,
            video_id__ilike=video_id__ilike,
            video_id__notilike=video_id__notilike,
            video_id__desc=video_id__desc,
            video_id__asc=video_id__asc,
            video_id_object__contains=video_id_object__contains,
            video_id_object__notcontains=video_id_object__notcontains,
            video_id_object__desc=video_id_object__desc,
            video_id_object__asc=video_id_object__asc,
            camera_id__eq=camera_id__eq,
            camera_id__ne=camera_id__ne,
            camera_id__gt=camera_id__gt,
            camera_id__gte=camera_id__gte,
            camera_id__lt=camera_id__lt,
            camera_id__lte=camera_id__lte,
            camera_id__in=camera_id__in,
            camera_id__notin=camera_id__notin,
            camera_id__contains=camera_id__contains,
            camera_id__notcontains=camera_id__notcontains,
            camera_id__like=camera_id__like,
            camera_id__notlike=camera_id__notlike,
            camera_id__ilike=camera_id__ilike,
            camera_id__notilike=camera_id__notilike,
            camera_id__desc=camera_id__desc,
            camera_id__asc=camera_id__asc,
            camera_id_object__contains=camera_id_object__contains,
            camera_id_object__notcontains=camera_id_object__notcontains,
            camera_id_object__desc=camera_id_object__desc,
            camera_id_object__asc=camera_id_object__asc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_detections_serialize(
        self,
        limit,
        offset,
        depth,
        video__load,
        camera__load,
        id__eq,
        id__ne,
        id__gt,
        id__gte,
        id__lt,
        id__lte,
        id__in,
        id__notin,
        id__contains,
        id__notcontains,
        id__like,
        id__notlike,
        id__ilike,
        id__notilike,
        id__desc,
        id__asc,
        created_at__eq,
        created_at__ne,
        created_at__gt,
        created_at__gte,
        created_at__lt,
        created_at__lte,
        created_at__in,
        created_at__notin,
        created_at__contains,
        created_at__notcontains,
        created_at__like,
        created_at__notlike,
        created_at__ilike,
        created_at__notilike,
        created_at__desc,
        created_at__asc,
        updated_at__eq,
        updated_at__ne,
        updated_at__gt,
        updated_at__gte,
        updated_at__lt,
        updated_at__lte,
        updated_at__in,
        updated_at__notin,
        updated_at__contains,
        updated_at__notcontains,
        updated_at__like,
        updated_at__notlike,
        updated_at__ilike,
        updated_at__notilike,
        updated_at__desc,
        updated_at__asc,
        deleted_at__eq,
        deleted_at__ne,
        deleted_at__gt,
        deleted_at__gte,
        deleted_at__lt,
        deleted_at__lte,
        deleted_at__in,
        deleted_at__notin,
        deleted_at__contains,
        deleted_at__notcontains,
        deleted_at__like,
        deleted_at__notlike,
        deleted_at__ilike,
        deleted_at__notilike,
        deleted_at__desc,
        deleted_at__asc,
        seen_at__eq,
        seen_at__ne,
        seen_at__gt,
        seen_at__gte,
        seen_at__lt,
        seen_at__lte,
        seen_at__in,
        seen_at__notin,
        seen_at__contains,
        seen_at__notcontains,
        seen_at__like,
        seen_at__notlike,
        seen_at__ilike,
        seen_at__notilike,
        seen_at__desc,
        seen_at__asc,
        class_id__eq,
        class_id__ne,
        class_id__gt,
        class_id__gte,
        class_id__lt,
        class_id__lte,
        class_id__in,
        class_id__notin,
        class_id__contains,
        class_id__notcontains,
        class_id__desc,
        class_id__asc,
        class_name__eq,
        class_name__ne,
        class_name__gt,
        class_name__gte,
        class_name__lt,
        class_name__lte,
        class_name__in,
        class_name__notin,
        class_name__contains,
        class_name__notcontains,
        class_name__like,
        class_name__notlike,
        class_name__ilike,
        class_name__notilike,
        class_name__desc,
        class_name__asc,
        score__eq,
        score__ne,
        score__gt,
        score__gte,
        score__lt,
        score__lte,
        score__in,
        score__notin,
        score__contains,
        score__notcontains,
        score__desc,
        score__asc,
        centroid__contains,
        centroid__notcontains,
        centroid__desc,
        centroid__asc,
        bounding_box__contains,
        bounding_box__notcontains,
        bounding_box__desc,
        bounding_box__asc,
        video_id__eq,
        video_id__ne,
        video_id__gt,
        video_id__gte,
        video_id__lt,
        video_id__lte,
        video_id__in,
        video_id__notin,
        video_id__contains,
        video_id__notcontains,
        video_id__like,
        video_id__notlike,
        video_id__ilike,
        video_id__notilike,
        video_id__desc,
        video_id__asc,
        video_id_object__contains,
        video_id_object__notcontains,
        video_id_object__desc,
        video_id_object__asc,
        camera_id__eq,
        camera_id__ne,
        camera_id__gt,
        camera_id__gte,
        camera_id__lt,
        camera_id__lte,
        camera_id__in,
        camera_id__notin,
        camera_id__contains,
        camera_id__notcontains,
        camera_id__like,
        camera_id__notlike,
        camera_id__ilike,
        camera_id__notilike,
        camera_id__desc,
        camera_id__asc,
        camera_id_object__contains,
        camera_id_object__notcontains,
        camera_id_object__desc,
        camera_id_object__asc,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if video__load is not None:
            
            _query_params.append(('video__load', video__load))
            
        if camera__load is not None:
            
            _query_params.append(('camera__load', camera__load))
            
        if id__eq is not None:
            
            _query_params.append(('id__eq', id__eq))
            
        if id__ne is not None:
            
            _query_params.append(('id__ne', id__ne))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__in is not None:
            
            _query_params.append(('id__in', id__in))
            
        if id__notin is not None:
            
            _query_params.append(('id__notin', id__notin))
            
        if id__contains is not None:
            
            _query_params.append(('id__contains', id__contains))
            
        if id__notcontains is not None:
            
            _query_params.append(('id__notcontains', id__notcontains))
            
        if id__like is not None:
            
            _query_params.append(('id__like', id__like))
            
        if id__notlike is not None:
            
            _query_params.append(('id__notlike', id__notlike))
            
        if id__ilike is not None:
            
            _query_params.append(('id__ilike', id__ilike))
            
        if id__notilike is not None:
            
            _query_params.append(('id__notilike', id__notilike))
            
        if id__desc is not None:
            
            _query_params.append(('id__desc', id__desc))
            
        if id__asc is not None:
            
            _query_params.append(('id__asc', id__asc))
            
        if created_at__eq is not None:
            if isinstance(created_at__eq, datetime):
                _query_params.append(
                    (
                        'created_at__eq',
                        created_at__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__eq', created_at__eq))
            
        if created_at__ne is not None:
            if isinstance(created_at__ne, datetime):
                _query_params.append(
                    (
                        'created_at__ne',
                        created_at__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__ne', created_at__ne))
            
        if created_at__gt is not None:
            if isinstance(created_at__gt, datetime):
                _query_params.append(
                    (
                        'created_at__gt',
                        created_at__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__gt', created_at__gt))
            
        if created_at__gte is not None:
            if isinstance(created_at__gte, datetime):
                _query_params.append(
                    (
                        'created_at__gte',
                        created_at__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__gte', created_at__gte))
            
        if created_at__lt is not None:
            if isinstance(created_at__lt, datetime):
                _query_params.append(
                    (
                        'created_at__lt',
                        created_at__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__lt', created_at__lt))
            
        if created_at__lte is not None:
            if isinstance(created_at__lte, datetime):
                _query_params.append(
                    (
                        'created_at__lte',
                        created_at__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__lte', created_at__lte))
            
        if created_at__in is not None:
            if isinstance(created_at__in, datetime):
                _query_params.append(
                    (
                        'created_at__in',
                        created_at__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__in', created_at__in))
            
        if created_at__notin is not None:
            if isinstance(created_at__notin, datetime):
                _query_params.append(
                    (
                        'created_at__notin',
                        created_at__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__notin', created_at__notin))
            
        if created_at__contains is not None:
            if isinstance(created_at__contains, datetime):
                _query_params.append(
                    (
                        'created_at__contains',
                        created_at__contains.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__contains', created_at__contains))
            
        if created_at__notcontains is not None:
            if isinstance(created_at__notcontains, datetime):
                _query_params.append(
                    (
                        'created_at__notcontains',
                        created_at__notcontains.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__notcontains', created_at__notcontains))
            
        if created_at__like is not None:
            if isinstance(created_at__like, datetime):
                _query_params.append(
                    (
                        'created_at__like',
                        created_at__like.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__like', created_at__like))
            
        if created_at__notlike is not None:
            if isinstance(created_at__notlike, datetime):
                _query_params.append(
                    (
                        'created_at__notlike',
                        created_at__notlike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__notlike', created_at__notlike))
            
        if created_at__ilike is not None:
            if isinstance(created_at__ilike, datetime):
                _query_params.append(
                    (
                        'created_at__ilike',
                        created_at__ilike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__ilike', created_at__ilike))
            
        if created_at__notilike is not None:
            if isinstance(created_at__notilike, datetime):
                _query_params.append(
                    (
                        'created_at__notilike',
                        created_at__notilike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_at__notilike', created_at__notilike))
            
        if created_at__desc is not None:
            
            _query_params.append(('created_at__desc', created_at__desc))
            
        if created_at__asc is not None:
            
            _query_params.append(('created_at__asc', created_at__asc))
            
        if updated_at__eq is not None:
            if isinstance(updated_at__eq, datetime):
                _query_params.append(
                    (
                        'updated_at__eq',
                        updated_at__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__eq', updated_at__eq))
            
        if updated_at__ne is not None:
            if isinstance(updated_at__ne, datetime):
                _query_params.append(
                    (
                        'updated_at__ne',
                        updated_at__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__ne', updated_at__ne))
            
        if updated_at__gt is not None:
            if isinstance(updated_at__gt, datetime):
                _query_params.append(
                    (
                        'updated_at__gt',
                        updated_at__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__gt', updated_at__gt))
            
        if updated_at__gte is not None:
            if isinstance(updated_at__gte, datetime):
                _query_params.append(
                    (
                        'updated_at__gte',
                        updated_at__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__gte', updated_at__gte))
            
        if updated_at__lt is not None:
            if isinstance(updated_at__lt, datetime):
                _query_params.append(
                    (
                        'updated_at__lt',
                        updated_at__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__lt', updated_at__lt))
            
        if updated_at__lte is not None:
            if isinstance(updated_at__lte, datetime):
                _query_params.append(
                    (
                        'updated_at__lte',
                        updated_at__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__lte', updated_at__lte))
            
        if updated_at__in is not None:
            if isinstance(updated_at__in, datetime):
                _query_params.append(
                    (
                        'updated_at__in',
                        updated_at__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__in', updated_at__in))
            
        if updated_at__notin is not None:
            if isinstance(updated_at__notin, datetime):
                _query_params.append(
                    (
                        'updated_at__notin',
                        updated_at__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__notin', updated_at__notin))
            
        if updated_at__contains is not None:
            if isinstance(updated_at__contains, datetime):
                _query_params.append(
                    (
                        'updated_at__contains',
                        updated_at__contains.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__contains', updated_at__contains))
            
        if updated_at__notcontains is not None:
            if isinstance(updated_at__notcontains, datetime):
                _query_params.append(
                    (
                        'updated_at__notcontains',
                        updated_at__notcontains.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__notcontains', updated_at__notcontains))
            
        if updated_at__like is not None:
            if isinstance(updated_at__like, datetime):
                _query_params.append(
                    (
                        'updated_at__like',
                        updated_at__like.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__like', updated_at__like))
            
        if updated_at__notlike is not None:
            if isinstance(updated_at__notlike, datetime):
                _query_params.append(
                    (
                        'updated_at__notlike',
                        updated_at__notlike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__notlike', updated_at__notlike))
            
        if updated_at__ilike is not None:
            if isinstance(updated_at__ilike, datetime):
                _query_params.append(
                    (
                        'updated_at__ilike',
                        updated_at__ilike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__ilike', updated_at__ilike))
            
        if updated_at__notilike is not None:
            if isinstance(updated_at__notilike, datetime):
                _query_params.append(
                    (
                        'updated_at__notilike',
                        updated_at__notilike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at__notilike', updated_at__notilike))
            
        if updated_at__desc is not None:
            
            _query_params.append(('updated_at__desc', updated_at__desc))
            
        if updated_at__asc is not None:
            
            _query_params.append(('updated_at__asc', updated_at__asc))
            
        if deleted_at__eq is not None:
            if isinstance(deleted_at__eq, datetime):
                _query_params.append(
                    (
                        'deleted_at__eq',
                        deleted_at__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__eq', deleted_at__eq))
            
        if deleted_at__ne is not None:
            if isinstance(deleted_at__ne, datetime):
                _query_params.append(
                    (
                        'deleted_at__ne',
                        deleted_at__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__ne', deleted_at__ne))
            
        if deleted_at__gt is not None:
            if isinstance(deleted_at__gt, datetime):
                _query_params.append(
                    (
                        'deleted_at__gt',
                        deleted_at__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__gt', deleted_at__gt))
            
        if deleted_at__gte is not None:
            if isinstance(deleted_at__gte, datetime):
                _query_params.append(
                    (
                        'deleted_at__gte',
                        deleted_at__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__gte', deleted_at__gte))
            
        if deleted_at__lt is not None:
            if isinstance(deleted_at__lt, datetime):
                _query_params.append(
                    (
                        'deleted_at__lt',
                        deleted_at__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__lt', deleted_at__lt))
            
        if deleted_at__lte is not None:
            if isinstance(deleted_at__lte, datetime):
                _query_params.append(
                    (
                        'deleted_at__lte',
                        deleted_at__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__lte', deleted_at__lte))
            
        if deleted_at__in is not None:
            if isinstance(deleted_at__in, datetime):
                _query_params.append(
                    (
                        'deleted_at__in',
                        deleted_at__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__in', deleted_at__in))
            
        if deleted_at__notin is not None:
            if isinstance(deleted_at__notin, datetime):
                _query_params.append(
                    (
                        'deleted_at__notin',
                        deleted_at__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__notin', deleted_at__notin))
            
        if deleted_at__contains is not None:
            if isinstance(deleted_at__contains, datetime):
                _query_params.append(
                    (
                        'deleted_at__contains',
                        deleted_at__contains.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__contains', deleted_at__contains))
            
        if deleted_at__notcontains is not None:
            if isinstance(deleted_at__notcontains, datetime):
                _query_params.append(
                    (
                        'deleted_at__notcontains',
                        deleted_at__notcontains.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__notcontains', deleted_at__notcontains))
            
        if deleted_at__like is not None:
            if isinstance(deleted_at__like, datetime):
                _query_params.append(
                    (
                        'deleted_at__like',
                        deleted_at__like.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__like', deleted_at__like))
            
        if deleted_at__notlike is not None:
            if isinstance(deleted_at__notlike, datetime):
                _query_params.append(
                    (
                        'deleted_at__notlike',
                        deleted_at__notlike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__notlike', deleted_at__notlike))
            
        if deleted_at__ilike is not None:
            if isinstance(deleted_at__ilike, datetime):
                _query_params.append(
                    (
                        'deleted_at__ilike',
                        deleted_at__ilike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__ilike', deleted_at__ilike))
            
        if deleted_at__notilike is not None:
            if isinstance(deleted_at__notilike, datetime):
                _query_params.append(
                    (
                        'deleted_at__notilike',
                        deleted_at__notilike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('deleted_at__notilike', deleted_at__notilike))
            
        if deleted_at__desc is not None:
            
            _query_params.append(('deleted_at__desc', deleted_at__desc))
            
        if deleted_at__asc is not None:
            
            _query_params.append(('deleted_at__asc', deleted_at__asc))
            
        if seen_at__eq is not None:
            if isinstance(seen_at__eq, datetime):
                _query_params.append(
                    (
                        'seen_at__eq',
                        seen_at__eq.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__eq', seen_at__eq))
            
        if seen_at__ne is not None:
            if isinstance(seen_at__ne, datetime):
                _query_params.append(
                    (
                        'seen_at__ne',
                        seen_at__ne.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__ne', seen_at__ne))
            
        if seen_at__gt is not None:
            if isinstance(seen_at__gt, datetime):
                _query_params.append(
                    (
                        'seen_at__gt',
                        seen_at__gt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__gt', seen_at__gt))
            
        if seen_at__gte is not None:
            if isinstance(seen_at__gte, datetime):
                _query_params.append(
                    (
                        'seen_at__gte',
                        seen_at__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__gte', seen_at__gte))
            
        if seen_at__lt is not None:
            if isinstance(seen_at__lt, datetime):
                _query_params.append(
                    (
                        'seen_at__lt',
                        seen_at__lt.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__lt', seen_at__lt))
            
        if seen_at__lte is not None:
            if isinstance(seen_at__lte, datetime):
                _query_params.append(
                    (
                        'seen_at__lte',
                        seen_at__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__lte', seen_at__lte))
            
        if seen_at__in is not None:
            if isinstance(seen_at__in, datetime):
                _query_params.append(
                    (
                        'seen_at__in',
                        seen_at__in.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__in', seen_at__in))
            
        if seen_at__notin is not None:
            if isinstance(seen_at__notin, datetime):
                _query_params.append(
                    (
                        'seen_at__notin',
                        seen_at__notin.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__notin', seen_at__notin))
            
        if seen_at__contains is not None:
            if isinstance(seen_at__contains, datetime):
                _query_params.append(
                    (
                        'seen_at__contains',
                        seen_at__contains.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__contains', seen_at__contains))
            
        if seen_at__notcontains is not None:
            if isinstance(seen_at__notcontains, datetime):
                _query_params.append(
                    (
                        'seen_at__notcontains',
                        seen_at__notcontains.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__notcontains', seen_at__notcontains))
            
        if seen_at__like is not None:
            if isinstance(seen_at__like, datetime):
                _query_params.append(
                    (
                        'seen_at__like',
                        seen_at__like.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__like', seen_at__like))
            
        if seen_at__notlike is not None:
            if isinstance(seen_at__notlike, datetime):
                _query_params.append(
                    (
                        'seen_at__notlike',
                        seen_at__notlike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__notlike', seen_at__notlike))
            
        if seen_at__ilike is not None:
            if isinstance(seen_at__ilike, datetime):
                _query_params.append(
                    (
                        'seen_at__ilike',
                        seen_at__ilike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__ilike', seen_at__ilike))
            
        if seen_at__notilike is not None:
            if isinstance(seen_at__notilike, datetime):
                _query_params.append(
                    (
                        'seen_at__notilike',
                        seen_at__notilike.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('seen_at__notilike', seen_at__notilike))
            
        if seen_at__desc is not None:
            
            _query_params.append(('seen_at__desc', seen_at__desc))
            
        if seen_at__asc is not None:
            
            _query_params.append(('seen_at__asc', seen_at__asc))
            
        if class_id__eq is not None:
            
            _query_params.append(('class_id__eq', class_id__eq))
            
        if class_id__ne is not None:
            
            _query_params.append(('class_id__ne', class_id__ne))
            
        if class_id__gt is not None:
            
            _query_params.append(('class_id__gt', class_id__gt))
            
        if class_id__gte is not None:
            
            _query_params.append(('class_id__gte', class_id__gte))
            
        if class_id__lt is not None:
            
            _query_params.append(('class_id__lt', class_id__lt))
            
        if class_id__lte is not None:
            
            _query_params.append(('class_id__lte', class_id__lte))
            
        if class_id__in is not None:
            
            _query_params.append(('class_id__in', class_id__in))
            
        if class_id__notin is not None:
            
            _query_params.append(('class_id__notin', class_id__notin))
            
        if class_id__contains is not None:
            
            _query_params.append(('class_id__contains', class_id__contains))
            
        if class_id__notcontains is not None:
            
            _query_params.append(('class_id__notcontains', class_id__notcontains))
            
        if class_id__desc is not None:
            
            _query_params.append(('class_id__desc', class_id__desc))
            
        if class_id__asc is not None:
            
            _query_params.append(('class_id__asc', class_id__asc))
            
        if class_name__eq is not None:
            
            _query_params.append(('class_name__eq', class_name__eq))
            
        if class_name__ne is not None:
            
            _query_params.append(('class_name__ne', class_name__ne))
            
        if class_name__gt is not None:
            
            _query_params.append(('class_name__gt', class_name__gt))
            
        if class_name__gte is not None:
            
            _query_params.append(('class_name__gte', class_name__gte))
            
        if class_name__lt is not None:
            
            _query_params.append(('class_name__lt', class_name__lt))
            
        if class_name__lte is not None:
            
            _query_params.append(('class_name__lte', class_name__lte))
            
        if class_name__in is not None:
            
            _query_params.append(('class_name__in', class_name__in))
            
        if class_name__notin is not None:
            
            _query_params.append(('class_name__notin', class_name__notin))
            
        if class_name__contains is not None:
            
            _query_params.append(('class_name__contains', class_name__contains))
            
        if class_name__notcontains is not None:
            
            _query_params.append(('class_name__notcontains', class_name__notcontains))
            
        if class_name__like is not None:
            
            _query_params.append(('class_name__like', class_name__like))
            
        if class_name__notlike is not None:
            
            _query_params.append(('class_name__notlike', class_name__notlike))
            
        if class_name__ilike is not None:
            
            _query_params.append(('class_name__ilike', class_name__ilike))
            
        if class_name__notilike is not None:
            
            _query_params.append(('class_name__notilike', class_name__notilike))
            
        if class_name__desc is not None:
            
            _query_params.append(('class_name__desc', class_name__desc))
            
        if class_name__asc is not None:
            
            _query_params.append(('class_name__asc', class_name__asc))
            
        if score__eq is not None:
            
            _query_params.append(('score__eq', score__eq))
            
        if score__ne is not None:
            
            _query_params.append(('score__ne', score__ne))
            
        if score__gt is not None:
            
            _query_params.append(('score__gt', score__gt))
            
        if score__gte is not None:
            
            _query_params.append(('score__gte', score__gte))
            
        if score__lt is not None:
            
            _query_params.append(('score__lt', score__lt))
            
        if score__lte is not None:
            
            _query_params.append(('score__lte', score__lte))
            
        if score__in is not None:
            
            _query_params.append(('score__in', score__in))
            
        if score__notin is not None:
            
            _query_params.append(('score__notin', score__notin))
            
        if score__contains is not None:
            
            _query_params.append(('score__contains', score__contains))
            
        if score__notcontains is not None:
            
            _query_params.append(('score__notcontains', score__notcontains))
            
        if score__desc is not None:
            
            _query_params.append(('score__desc', score__desc))
            
        if score__asc is not None:
            
            _query_params.append(('score__asc', score__asc))
            
        if centroid__contains is not None:
            
            _query_params.append(('centroid__contains', centroid__contains))
            
        if centroid__notcontains is not None:
            
            _query_params.append(('centroid__notcontains', centroid__notcontains))
            
        if centroid__desc is not None:
            
            _query_params.append(('centroid__desc', centroid__desc))
            
        if centroid__asc is not None:
            
            _query_params.append(('centroid__asc', centroid__asc))
            
        if bounding_box__contains is not None:
            
            _query_params.append(('bounding_box__contains', bounding_box__contains))
            
        if bounding_box__notcontains is not None:
            
            _query_params.append(('bounding_box__notcontains', bounding_box__notcontains))
            
        if bounding_box__desc is not None:
            
            _query_params.append(('bounding_box__desc', bounding_box__desc))
            
        if bounding_box__asc is not None:
            
            _query_params.append(('bounding_box__asc', bounding_box__asc))
            
        if video_id__eq is not None:
            
            _query_params.append(('video_id__eq', video_id__eq))
            
        if video_id__ne is not None:
            
            _query_params.append(('video_id__ne', video_id__ne))
            
        if video_id__gt is not None:
            
            _query_params.append(('video_id__gt', video_id__gt))
            
        if video_id__gte is not None:
            
            _query_params.append(('video_id__gte', video_id__gte))
            
        if video_id__lt is not None:
            
            _query_params.append(('video_id__lt', video_id__lt))
            
        if video_id__lte is not None:
            
            _query_params.append(('video_id__lte', video_id__lte))
            
        if video_id__in is not None:
            
            _query_params.append(('video_id__in', video_id__in))
            
        if video_id__notin is not None:
            
            _query_params.append(('video_id__notin', video_id__notin))
            
        if video_id__contains is not None:
            
            _query_params.append(('video_id__contains', video_id__contains))
            
        if video_id__notcontains is not None:
            
            _query_params.append(('video_id__notcontains', video_id__notcontains))
            
        if video_id__like is not None:
            
            _query_params.append(('video_id__like', video_id__like))
            
        if video_id__notlike is not None:
            
            _query_params.append(('video_id__notlike', video_id__notlike))
            
        if video_id__ilike is not None:
            
            _query_params.append(('video_id__ilike', video_id__ilike))
            
        if video_id__notilike is not None:
            
            _query_params.append(('video_id__notilike', video_id__notilike))
            
        if video_id__desc is not None:
            
            _query_params.append(('video_id__desc', video_id__desc))
            
        if video_id__asc is not None:
            
            _query_params.append(('video_id__asc', video_id__asc))
            
        if video_id_object__contains is not None:
            
            _query_params.append(('video_id_object__contains', video_id_object__contains))
            
        if video_id_object__notcontains is not None:
            
            _query_params.append(('video_id_object__notcontains', video_id_object__notcontains))
            
        if video_id_object__desc is not None:
            
            _query_params.append(('video_id_object__desc', video_id_object__desc))
            
        if video_id_object__asc is not None:
            
            _query_params.append(('video_id_object__asc', video_id_object__asc))
            
        if camera_id__eq is not None:
            
            _query_params.append(('camera_id__eq', camera_id__eq))
            
        if camera_id__ne is not None:
            
            _query_params.append(('camera_id__ne', camera_id__ne))
            
        if camera_id__gt is not None:
            
            _query_params.append(('camera_id__gt', camera_id__gt))
            
        if camera_id__gte is not None:
            
            _query_params.append(('camera_id__gte', camera_id__gte))
            
        if camera_id__lt is not None:
            
            _query_params.append(('camera_id__lt', camera_id__lt))
            
        if camera_id__lte is not None:
            
            _query_params.append(('camera_id__lte', camera_id__lte))
            
        if camera_id__in is not None:
            
            _query_params.append(('camera_id__in', camera_id__in))
            
        if camera_id__notin is not None:
            
            _query_params.append(('camera_id__notin', camera_id__notin))
            
        if camera_id__contains is not None:
            
            _query_params.append(('camera_id__contains', camera_id__contains))
            
        if camera_id__notcontains is not None:
            
            _query_params.append(('camera_id__notcontains', camera_id__notcontains))
            
        if camera_id__like is not None:
            
            _query_params.append(('camera_id__like', camera_id__like))
            
        if camera_id__notlike is not None:
            
            _query_params.append(('camera_id__notlike', camera_id__notlike))
            
        if camera_id__ilike is not None:
            
            _query_params.append(('camera_id__ilike', camera_id__ilike))
            
        if camera_id__notilike is not None:
            
            _query_params.append(('camera_id__notilike', camera_id__notilike))
            
        if camera_id__desc is not None:
            
            _query_params.append(('camera_id__desc', camera_id__desc))
            
        if camera_id__asc is not None:
            
            _query_params.append(('camera_id__asc', camera_id__asc))
            
        if camera_id_object__contains is not None:
            
            _query_params.append(('camera_id_object__contains', camera_id_object__contains))
            
        if camera_id_object__notcontains is not None:
            
            _query_params.append(('camera_id_object__notcontains', camera_id_object__notcontains))
            
        if camera_id_object__desc is not None:
            
            _query_params.append(('camera_id_object__desc', camera_id_object__desc))
            
        if camera_id_object__asc is not None:
            
            _query_params.append(('camera_id_object__asc', camera_id_object__asc))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/detections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_detection(
        self,
        primary_key: Annotated[StrictStr, Field(description="Path parameter primaryKey")],
        detection: Detection,
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ResponseWithGenericOfDetection:
        """patch_detection


        :param primary_key: Path parameter primaryKey (required)
        :type primary_key: str
        :param detection: (required)
        :type detection: Detection
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_detection_serialize(
            primary_key=primary_key,
            detection=detection,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_detection_with_http_info(
        self,
        primary_key: Annotated[StrictStr, Field(description="Path parameter primaryKey")],
        detection: Detection,
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ResponseWithGenericOfDetection]:
        """patch_detection


        :param primary_key: Path parameter primaryKey (required)
        :type primary_key: str
        :param detection: (required)
        :type detection: Detection
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_detection_serialize(
            primary_key=primary_key,
            detection=detection,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_detection_without_preload_content(
        self,
        primary_key: Annotated[StrictStr, Field(description="Path parameter primaryKey")],
        detection: Detection,
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_detection


        :param primary_key: Path parameter primaryKey (required)
        :type primary_key: str
        :param detection: (required)
        :type detection: Detection
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_detection_serialize(
            primary_key=primary_key,
            detection=detection,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_detection_serialize(
        self,
        primary_key,
        detection,
        depth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if primary_key is not None:
            _path_params['primaryKey'] = primary_key
        # process the query parameters
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if detection is not None:
            _body_params = detection


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/detections/{primaryKey}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_detections(
        self,
        detection: List[Detection],
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ResponseWithGenericOfDetection:
        """post_detections


        :param detection: (required)
        :type detection: List[Detection]
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_detections_serialize(
            detection=detection,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_detections_with_http_info(
        self,
        detection: List[Detection],
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ResponseWithGenericOfDetection]:
        """post_detections


        :param detection: (required)
        :type detection: List[Detection]
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_detections_serialize(
            detection=detection,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_detections_without_preload_content(
        self,
        detection: List[Detection],
        depth: Annotated[Optional[StrictInt], Field(description="Query parameter depth")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_detections


        :param detection: (required)
        :type detection: List[Detection]
        :param depth: Query parameter depth
        :type depth: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_detections_serialize(
            detection=detection,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ResponseWithGenericOfDetection",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_detections_serialize(
        self,
        detection,
        depth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'Detection': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if detection is not None:
            _body_params = detection


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/detections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


