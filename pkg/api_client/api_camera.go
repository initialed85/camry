/*
Djangolang

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// CameraAPIService CameraAPI service
type CameraAPIService service

type ApiDeleteCameraRequest struct {
	ctx context.Context
	ApiService *CameraAPIService
	primaryKey string
	depth *int64
}

// Query parameter depth
func (r ApiDeleteCameraRequest) Depth(depth int64) ApiDeleteCameraRequest {
	r.depth = &depth
	return r
}

func (r ApiDeleteCameraRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCameraExecute(r)
}

/*
DeleteCamera Method for DeleteCamera

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param primaryKey Path parameter primaryKey
 @return ApiDeleteCameraRequest
*/
func (a *CameraAPIService) DeleteCamera(ctx context.Context, primaryKey string) ApiDeleteCameraRequest {
	return ApiDeleteCameraRequest{
		ApiService: a,
		ctx: ctx,
		primaryKey: primaryKey,
	}
}

// Execute executes the request
func (a *CameraAPIService) DeleteCameraExecute(r ApiDeleteCameraRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CameraAPIService.DeleteCamera")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/cameras/{primaryKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"primaryKey"+"}", url.PathEscape(parameterValueToString(r.primaryKey, "primaryKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCameraRequest struct {
	ctx context.Context
	ApiService *CameraAPIService
	primaryKey string
	depth *int64
}

// Query parameter depth
func (r ApiGetCameraRequest) Depth(depth int64) ApiGetCameraRequest {
	r.depth = &depth
	return r
}

func (r ApiGetCameraRequest) Execute() (*ResponseWithGenericOfCamera, *http.Response, error) {
	return r.ApiService.GetCameraExecute(r)
}

/*
GetCamera Method for GetCamera

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param primaryKey Path parameter primaryKey
 @return ApiGetCameraRequest
*/
func (a *CameraAPIService) GetCamera(ctx context.Context, primaryKey string) ApiGetCameraRequest {
	return ApiGetCameraRequest{
		ApiService: a,
		ctx: ctx,
		primaryKey: primaryKey,
	}
}

// Execute executes the request
//  @return ResponseWithGenericOfCamera
func (a *CameraAPIService) GetCameraExecute(r ApiGetCameraRequest) (*ResponseWithGenericOfCamera, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseWithGenericOfCamera
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CameraAPIService.GetCamera")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/cameras/{primaryKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"primaryKey"+"}", url.PathEscape(parameterValueToString(r.primaryKey, "primaryKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetCamerasDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCamerasRequest struct {
	ctx context.Context
	ApiService *CameraAPIService
	limit *int32
	offset *int32
	depth *int32
	referencedByDetectionLoad *string
	referencedByVideoLoad *string
	idEq *string
	idNe *string
	idGt *string
	idGte *string
	idLt *string
	idLte *string
	idIn *string
	idNotin *string
	idContains *string
	idNotcontains *string
	idLike *string
	idNotlike *string
	idIlike *string
	idNotilike *string
	idDesc *string
	idAsc *string
	createdAtEq *time.Time
	createdAtNe *time.Time
	createdAtGt *time.Time
	createdAtGte *time.Time
	createdAtLt *time.Time
	createdAtLte *time.Time
	createdAtIn *time.Time
	createdAtNotin *time.Time
	createdAtContains *time.Time
	createdAtNotcontains *time.Time
	createdAtLike *time.Time
	createdAtNotlike *time.Time
	createdAtIlike *time.Time
	createdAtNotilike *time.Time
	createdAtDesc *string
	createdAtAsc *string
	updatedAtEq *time.Time
	updatedAtNe *time.Time
	updatedAtGt *time.Time
	updatedAtGte *time.Time
	updatedAtLt *time.Time
	updatedAtLte *time.Time
	updatedAtIn *time.Time
	updatedAtNotin *time.Time
	updatedAtContains *time.Time
	updatedAtNotcontains *time.Time
	updatedAtLike *time.Time
	updatedAtNotlike *time.Time
	updatedAtIlike *time.Time
	updatedAtNotilike *time.Time
	updatedAtDesc *string
	updatedAtAsc *string
	deletedAtEq *time.Time
	deletedAtNe *time.Time
	deletedAtGt *time.Time
	deletedAtGte *time.Time
	deletedAtLt *time.Time
	deletedAtLte *time.Time
	deletedAtIn *time.Time
	deletedAtNotin *time.Time
	deletedAtContains *time.Time
	deletedAtNotcontains *time.Time
	deletedAtLike *time.Time
	deletedAtNotlike *time.Time
	deletedAtIlike *time.Time
	deletedAtNotilike *time.Time
	deletedAtDesc *string
	deletedAtAsc *string
	nameEq *string
	nameNe *string
	nameGt *string
	nameGte *string
	nameLt *string
	nameLte *string
	nameIn *string
	nameNotin *string
	nameContains *string
	nameNotcontains *string
	nameLike *string
	nameNotlike *string
	nameIlike *string
	nameNotilike *string
	nameDesc *string
	nameAsc *string
	streamUrlEq *string
	streamUrlNe *string
	streamUrlGt *string
	streamUrlGte *string
	streamUrlLt *string
	streamUrlLte *string
	streamUrlIn *string
	streamUrlNotin *string
	streamUrlContains *string
	streamUrlNotcontains *string
	streamUrlLike *string
	streamUrlNotlike *string
	streamUrlIlike *string
	streamUrlNotilike *string
	streamUrlDesc *string
	streamUrlAsc *string
	lastSeenEq *time.Time
	lastSeenNe *time.Time
	lastSeenGt *time.Time
	lastSeenGte *time.Time
	lastSeenLt *time.Time
	lastSeenLte *time.Time
	lastSeenIn *time.Time
	lastSeenNotin *time.Time
	lastSeenContains *time.Time
	lastSeenNotcontains *time.Time
	lastSeenLike *time.Time
	lastSeenNotlike *time.Time
	lastSeenIlike *time.Time
	lastSeenNotilike *time.Time
	lastSeenDesc *string
	lastSeenAsc *string
	segmentProducerClaimedUntilEq *time.Time
	segmentProducerClaimedUntilNe *time.Time
	segmentProducerClaimedUntilGt *time.Time
	segmentProducerClaimedUntilGte *time.Time
	segmentProducerClaimedUntilLt *time.Time
	segmentProducerClaimedUntilLte *time.Time
	segmentProducerClaimedUntilIn *time.Time
	segmentProducerClaimedUntilNotin *time.Time
	segmentProducerClaimedUntilContains *time.Time
	segmentProducerClaimedUntilNotcontains *time.Time
	segmentProducerClaimedUntilLike *time.Time
	segmentProducerClaimedUntilNotlike *time.Time
	segmentProducerClaimedUntilIlike *time.Time
	segmentProducerClaimedUntilNotilike *time.Time
	segmentProducerClaimedUntilDesc *string
	segmentProducerClaimedUntilAsc *string
	streamProducerClaimedUntilEq *time.Time
	streamProducerClaimedUntilNe *time.Time
	streamProducerClaimedUntilGt *time.Time
	streamProducerClaimedUntilGte *time.Time
	streamProducerClaimedUntilLt *time.Time
	streamProducerClaimedUntilLte *time.Time
	streamProducerClaimedUntilIn *time.Time
	streamProducerClaimedUntilNotin *time.Time
	streamProducerClaimedUntilContains *time.Time
	streamProducerClaimedUntilNotcontains *time.Time
	streamProducerClaimedUntilLike *time.Time
	streamProducerClaimedUntilNotlike *time.Time
	streamProducerClaimedUntilIlike *time.Time
	streamProducerClaimedUntilNotilike *time.Time
	streamProducerClaimedUntilDesc *string
	streamProducerClaimedUntilAsc *string
	referencedByDetectionCameraIdObjectsContains *interface{}
	referencedByDetectionCameraIdObjectsNotcontains *interface{}
	referencedByDetectionCameraIdObjectsDesc *string
	referencedByDetectionCameraIdObjectsAsc *string
	referencedByVideoCameraIdObjectsContains *interface{}
	referencedByVideoCameraIdObjectsNotcontains *interface{}
	referencedByVideoCameraIdObjectsDesc *string
	referencedByVideoCameraIdObjectsAsc *string
}

// SQL LIMIT operator
func (r ApiGetCamerasRequest) Limit(limit int32) ApiGetCamerasRequest {
	r.limit = &limit
	return r
}

// SQL OFFSET operator
func (r ApiGetCamerasRequest) Offset(offset int32) ApiGetCamerasRequest {
	r.offset = &offset
	return r
}

// Max recursion depth for loading foreign objects; default &#x3D; 1  (0 &#x3D; recurse until graph cycle detected, 1 &#x3D; this object only, 2 &#x3D; this object + neighbours, 3 &#x3D; this object + neighbours + their neighbours... etc)
func (r ApiGetCamerasRequest) Depth(depth int32) ApiGetCamerasRequest {
	r.depth = &depth
	return r
}

// load the given indirectly related objects, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) ReferencedByDetectionLoad(referencedByDetectionLoad string) ApiGetCamerasRequest {
	r.referencedByDetectionLoad = &referencedByDetectionLoad
	return r
}

// load the given indirectly related objects, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) ReferencedByVideoLoad(referencedByVideoLoad string) ApiGetCamerasRequest {
	r.referencedByVideoLoad = &referencedByVideoLoad
	return r
}

// SQL &#x3D; comparison
func (r ApiGetCamerasRequest) IdEq(idEq string) ApiGetCamerasRequest {
	r.idEq = &idEq
	return r
}

// SQL !&#x3D; comparison
func (r ApiGetCamerasRequest) IdNe(idNe string) ApiGetCamerasRequest {
	r.idNe = &idNe
	return r
}

// SQL &gt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) IdGt(idGt string) ApiGetCamerasRequest {
	r.idGt = &idGt
	return r
}

// SQL &gt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) IdGte(idGte string) ApiGetCamerasRequest {
	r.idGte = &idGte
	return r
}

// SQL &lt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) IdLt(idLt string) ApiGetCamerasRequest {
	r.idLt = &idLt
	return r
}

// SQL &lt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) IdLte(idLte string) ApiGetCamerasRequest {
	r.idLte = &idLte
	return r
}

// SQL IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) IdIn(idIn string) ApiGetCamerasRequest {
	r.idIn = &idIn
	return r
}

// SQL NOT IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) IdNotin(idNotin string) ApiGetCamerasRequest {
	r.idNotin = &idNotin
	return r
}

// SQL @&gt; comparison
func (r ApiGetCamerasRequest) IdContains(idContains string) ApiGetCamerasRequest {
	r.idContains = &idContains
	return r
}

// SQL NOT @&gt; comparison
func (r ApiGetCamerasRequest) IdNotcontains(idNotcontains string) ApiGetCamerasRequest {
	r.idNotcontains = &idNotcontains
	return r
}

// SQL LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) IdLike(idLike string) ApiGetCamerasRequest {
	r.idLike = &idLike
	return r
}

// SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) IdNotlike(idNotlike string) ApiGetCamerasRequest {
	r.idNotlike = &idNotlike
	return r
}

// SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) IdIlike(idIlike string) ApiGetCamerasRequest {
	r.idIlike = &idIlike
	return r
}

// SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) IdNotilike(idNotilike string) ApiGetCamerasRequest {
	r.idNotilike = &idNotilike
	return r
}

// SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) IdDesc(idDesc string) ApiGetCamerasRequest {
	r.idDesc = &idDesc
	return r
}

// SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) IdAsc(idAsc string) ApiGetCamerasRequest {
	r.idAsc = &idAsc
	return r
}

// SQL &#x3D; comparison
func (r ApiGetCamerasRequest) CreatedAtEq(createdAtEq time.Time) ApiGetCamerasRequest {
	r.createdAtEq = &createdAtEq
	return r
}

// SQL !&#x3D; comparison
func (r ApiGetCamerasRequest) CreatedAtNe(createdAtNe time.Time) ApiGetCamerasRequest {
	r.createdAtNe = &createdAtNe
	return r
}

// SQL &gt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) CreatedAtGt(createdAtGt time.Time) ApiGetCamerasRequest {
	r.createdAtGt = &createdAtGt
	return r
}

// SQL &gt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) CreatedAtGte(createdAtGte time.Time) ApiGetCamerasRequest {
	r.createdAtGte = &createdAtGte
	return r
}

// SQL &lt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) CreatedAtLt(createdAtLt time.Time) ApiGetCamerasRequest {
	r.createdAtLt = &createdAtLt
	return r
}

// SQL &lt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) CreatedAtLte(createdAtLte time.Time) ApiGetCamerasRequest {
	r.createdAtLte = &createdAtLte
	return r
}

// SQL IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) CreatedAtIn(createdAtIn time.Time) ApiGetCamerasRequest {
	r.createdAtIn = &createdAtIn
	return r
}

// SQL NOT IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) CreatedAtNotin(createdAtNotin time.Time) ApiGetCamerasRequest {
	r.createdAtNotin = &createdAtNotin
	return r
}

// SQL @&gt; comparison
func (r ApiGetCamerasRequest) CreatedAtContains(createdAtContains time.Time) ApiGetCamerasRequest {
	r.createdAtContains = &createdAtContains
	return r
}

// SQL NOT @&gt; comparison
func (r ApiGetCamerasRequest) CreatedAtNotcontains(createdAtNotcontains time.Time) ApiGetCamerasRequest {
	r.createdAtNotcontains = &createdAtNotcontains
	return r
}

// SQL LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) CreatedAtLike(createdAtLike time.Time) ApiGetCamerasRequest {
	r.createdAtLike = &createdAtLike
	return r
}

// SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) CreatedAtNotlike(createdAtNotlike time.Time) ApiGetCamerasRequest {
	r.createdAtNotlike = &createdAtNotlike
	return r
}

// SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) CreatedAtIlike(createdAtIlike time.Time) ApiGetCamerasRequest {
	r.createdAtIlike = &createdAtIlike
	return r
}

// SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) CreatedAtNotilike(createdAtNotilike time.Time) ApiGetCamerasRequest {
	r.createdAtNotilike = &createdAtNotilike
	return r
}

// SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) CreatedAtDesc(createdAtDesc string) ApiGetCamerasRequest {
	r.createdAtDesc = &createdAtDesc
	return r
}

// SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) CreatedAtAsc(createdAtAsc string) ApiGetCamerasRequest {
	r.createdAtAsc = &createdAtAsc
	return r
}

// SQL &#x3D; comparison
func (r ApiGetCamerasRequest) UpdatedAtEq(updatedAtEq time.Time) ApiGetCamerasRequest {
	r.updatedAtEq = &updatedAtEq
	return r
}

// SQL !&#x3D; comparison
func (r ApiGetCamerasRequest) UpdatedAtNe(updatedAtNe time.Time) ApiGetCamerasRequest {
	r.updatedAtNe = &updatedAtNe
	return r
}

// SQL &gt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) UpdatedAtGt(updatedAtGt time.Time) ApiGetCamerasRequest {
	r.updatedAtGt = &updatedAtGt
	return r
}

// SQL &gt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) UpdatedAtGte(updatedAtGte time.Time) ApiGetCamerasRequest {
	r.updatedAtGte = &updatedAtGte
	return r
}

// SQL &lt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) UpdatedAtLt(updatedAtLt time.Time) ApiGetCamerasRequest {
	r.updatedAtLt = &updatedAtLt
	return r
}

// SQL &lt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) UpdatedAtLte(updatedAtLte time.Time) ApiGetCamerasRequest {
	r.updatedAtLte = &updatedAtLte
	return r
}

// SQL IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) UpdatedAtIn(updatedAtIn time.Time) ApiGetCamerasRequest {
	r.updatedAtIn = &updatedAtIn
	return r
}

// SQL NOT IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) UpdatedAtNotin(updatedAtNotin time.Time) ApiGetCamerasRequest {
	r.updatedAtNotin = &updatedAtNotin
	return r
}

// SQL @&gt; comparison
func (r ApiGetCamerasRequest) UpdatedAtContains(updatedAtContains time.Time) ApiGetCamerasRequest {
	r.updatedAtContains = &updatedAtContains
	return r
}

// SQL NOT @&gt; comparison
func (r ApiGetCamerasRequest) UpdatedAtNotcontains(updatedAtNotcontains time.Time) ApiGetCamerasRequest {
	r.updatedAtNotcontains = &updatedAtNotcontains
	return r
}

// SQL LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) UpdatedAtLike(updatedAtLike time.Time) ApiGetCamerasRequest {
	r.updatedAtLike = &updatedAtLike
	return r
}

// SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) UpdatedAtNotlike(updatedAtNotlike time.Time) ApiGetCamerasRequest {
	r.updatedAtNotlike = &updatedAtNotlike
	return r
}

// SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) UpdatedAtIlike(updatedAtIlike time.Time) ApiGetCamerasRequest {
	r.updatedAtIlike = &updatedAtIlike
	return r
}

// SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) UpdatedAtNotilike(updatedAtNotilike time.Time) ApiGetCamerasRequest {
	r.updatedAtNotilike = &updatedAtNotilike
	return r
}

// SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) UpdatedAtDesc(updatedAtDesc string) ApiGetCamerasRequest {
	r.updatedAtDesc = &updatedAtDesc
	return r
}

// SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) UpdatedAtAsc(updatedAtAsc string) ApiGetCamerasRequest {
	r.updatedAtAsc = &updatedAtAsc
	return r
}

// SQL &#x3D; comparison
func (r ApiGetCamerasRequest) DeletedAtEq(deletedAtEq time.Time) ApiGetCamerasRequest {
	r.deletedAtEq = &deletedAtEq
	return r
}

// SQL !&#x3D; comparison
func (r ApiGetCamerasRequest) DeletedAtNe(deletedAtNe time.Time) ApiGetCamerasRequest {
	r.deletedAtNe = &deletedAtNe
	return r
}

// SQL &gt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) DeletedAtGt(deletedAtGt time.Time) ApiGetCamerasRequest {
	r.deletedAtGt = &deletedAtGt
	return r
}

// SQL &gt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) DeletedAtGte(deletedAtGte time.Time) ApiGetCamerasRequest {
	r.deletedAtGte = &deletedAtGte
	return r
}

// SQL &lt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) DeletedAtLt(deletedAtLt time.Time) ApiGetCamerasRequest {
	r.deletedAtLt = &deletedAtLt
	return r
}

// SQL &lt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) DeletedAtLte(deletedAtLte time.Time) ApiGetCamerasRequest {
	r.deletedAtLte = &deletedAtLte
	return r
}

// SQL IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) DeletedAtIn(deletedAtIn time.Time) ApiGetCamerasRequest {
	r.deletedAtIn = &deletedAtIn
	return r
}

// SQL NOT IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) DeletedAtNotin(deletedAtNotin time.Time) ApiGetCamerasRequest {
	r.deletedAtNotin = &deletedAtNotin
	return r
}

// SQL @&gt; comparison
func (r ApiGetCamerasRequest) DeletedAtContains(deletedAtContains time.Time) ApiGetCamerasRequest {
	r.deletedAtContains = &deletedAtContains
	return r
}

// SQL NOT @&gt; comparison
func (r ApiGetCamerasRequest) DeletedAtNotcontains(deletedAtNotcontains time.Time) ApiGetCamerasRequest {
	r.deletedAtNotcontains = &deletedAtNotcontains
	return r
}

// SQL LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) DeletedAtLike(deletedAtLike time.Time) ApiGetCamerasRequest {
	r.deletedAtLike = &deletedAtLike
	return r
}

// SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) DeletedAtNotlike(deletedAtNotlike time.Time) ApiGetCamerasRequest {
	r.deletedAtNotlike = &deletedAtNotlike
	return r
}

// SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) DeletedAtIlike(deletedAtIlike time.Time) ApiGetCamerasRequest {
	r.deletedAtIlike = &deletedAtIlike
	return r
}

// SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) DeletedAtNotilike(deletedAtNotilike time.Time) ApiGetCamerasRequest {
	r.deletedAtNotilike = &deletedAtNotilike
	return r
}

// SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) DeletedAtDesc(deletedAtDesc string) ApiGetCamerasRequest {
	r.deletedAtDesc = &deletedAtDesc
	return r
}

// SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) DeletedAtAsc(deletedAtAsc string) ApiGetCamerasRequest {
	r.deletedAtAsc = &deletedAtAsc
	return r
}

// SQL &#x3D; comparison
func (r ApiGetCamerasRequest) NameEq(nameEq string) ApiGetCamerasRequest {
	r.nameEq = &nameEq
	return r
}

// SQL !&#x3D; comparison
func (r ApiGetCamerasRequest) NameNe(nameNe string) ApiGetCamerasRequest {
	r.nameNe = &nameNe
	return r
}

// SQL &gt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) NameGt(nameGt string) ApiGetCamerasRequest {
	r.nameGt = &nameGt
	return r
}

// SQL &gt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) NameGte(nameGte string) ApiGetCamerasRequest {
	r.nameGte = &nameGte
	return r
}

// SQL &lt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) NameLt(nameLt string) ApiGetCamerasRequest {
	r.nameLt = &nameLt
	return r
}

// SQL &lt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) NameLte(nameLte string) ApiGetCamerasRequest {
	r.nameLte = &nameLte
	return r
}

// SQL IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) NameIn(nameIn string) ApiGetCamerasRequest {
	r.nameIn = &nameIn
	return r
}

// SQL NOT IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) NameNotin(nameNotin string) ApiGetCamerasRequest {
	r.nameNotin = &nameNotin
	return r
}

// SQL @&gt; comparison
func (r ApiGetCamerasRequest) NameContains(nameContains string) ApiGetCamerasRequest {
	r.nameContains = &nameContains
	return r
}

// SQL NOT @&gt; comparison
func (r ApiGetCamerasRequest) NameNotcontains(nameNotcontains string) ApiGetCamerasRequest {
	r.nameNotcontains = &nameNotcontains
	return r
}

// SQL LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) NameLike(nameLike string) ApiGetCamerasRequest {
	r.nameLike = &nameLike
	return r
}

// SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) NameNotlike(nameNotlike string) ApiGetCamerasRequest {
	r.nameNotlike = &nameNotlike
	return r
}

// SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) NameIlike(nameIlike string) ApiGetCamerasRequest {
	r.nameIlike = &nameIlike
	return r
}

// SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) NameNotilike(nameNotilike string) ApiGetCamerasRequest {
	r.nameNotilike = &nameNotilike
	return r
}

// SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) NameDesc(nameDesc string) ApiGetCamerasRequest {
	r.nameDesc = &nameDesc
	return r
}

// SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) NameAsc(nameAsc string) ApiGetCamerasRequest {
	r.nameAsc = &nameAsc
	return r
}

// SQL &#x3D; comparison
func (r ApiGetCamerasRequest) StreamUrlEq(streamUrlEq string) ApiGetCamerasRequest {
	r.streamUrlEq = &streamUrlEq
	return r
}

// SQL !&#x3D; comparison
func (r ApiGetCamerasRequest) StreamUrlNe(streamUrlNe string) ApiGetCamerasRequest {
	r.streamUrlNe = &streamUrlNe
	return r
}

// SQL &gt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) StreamUrlGt(streamUrlGt string) ApiGetCamerasRequest {
	r.streamUrlGt = &streamUrlGt
	return r
}

// SQL &gt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) StreamUrlGte(streamUrlGte string) ApiGetCamerasRequest {
	r.streamUrlGte = &streamUrlGte
	return r
}

// SQL &lt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) StreamUrlLt(streamUrlLt string) ApiGetCamerasRequest {
	r.streamUrlLt = &streamUrlLt
	return r
}

// SQL &lt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) StreamUrlLte(streamUrlLte string) ApiGetCamerasRequest {
	r.streamUrlLte = &streamUrlLte
	return r
}

// SQL IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) StreamUrlIn(streamUrlIn string) ApiGetCamerasRequest {
	r.streamUrlIn = &streamUrlIn
	return r
}

// SQL NOT IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) StreamUrlNotin(streamUrlNotin string) ApiGetCamerasRequest {
	r.streamUrlNotin = &streamUrlNotin
	return r
}

// SQL @&gt; comparison
func (r ApiGetCamerasRequest) StreamUrlContains(streamUrlContains string) ApiGetCamerasRequest {
	r.streamUrlContains = &streamUrlContains
	return r
}

// SQL NOT @&gt; comparison
func (r ApiGetCamerasRequest) StreamUrlNotcontains(streamUrlNotcontains string) ApiGetCamerasRequest {
	r.streamUrlNotcontains = &streamUrlNotcontains
	return r
}

// SQL LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) StreamUrlLike(streamUrlLike string) ApiGetCamerasRequest {
	r.streamUrlLike = &streamUrlLike
	return r
}

// SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) StreamUrlNotlike(streamUrlNotlike string) ApiGetCamerasRequest {
	r.streamUrlNotlike = &streamUrlNotlike
	return r
}

// SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) StreamUrlIlike(streamUrlIlike string) ApiGetCamerasRequest {
	r.streamUrlIlike = &streamUrlIlike
	return r
}

// SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) StreamUrlNotilike(streamUrlNotilike string) ApiGetCamerasRequest {
	r.streamUrlNotilike = &streamUrlNotilike
	return r
}

// SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) StreamUrlDesc(streamUrlDesc string) ApiGetCamerasRequest {
	r.streamUrlDesc = &streamUrlDesc
	return r
}

// SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) StreamUrlAsc(streamUrlAsc string) ApiGetCamerasRequest {
	r.streamUrlAsc = &streamUrlAsc
	return r
}

// SQL &#x3D; comparison
func (r ApiGetCamerasRequest) LastSeenEq(lastSeenEq time.Time) ApiGetCamerasRequest {
	r.lastSeenEq = &lastSeenEq
	return r
}

// SQL !&#x3D; comparison
func (r ApiGetCamerasRequest) LastSeenNe(lastSeenNe time.Time) ApiGetCamerasRequest {
	r.lastSeenNe = &lastSeenNe
	return r
}

// SQL &gt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) LastSeenGt(lastSeenGt time.Time) ApiGetCamerasRequest {
	r.lastSeenGt = &lastSeenGt
	return r
}

// SQL &gt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) LastSeenGte(lastSeenGte time.Time) ApiGetCamerasRequest {
	r.lastSeenGte = &lastSeenGte
	return r
}

// SQL &lt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) LastSeenLt(lastSeenLt time.Time) ApiGetCamerasRequest {
	r.lastSeenLt = &lastSeenLt
	return r
}

// SQL &lt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) LastSeenLte(lastSeenLte time.Time) ApiGetCamerasRequest {
	r.lastSeenLte = &lastSeenLte
	return r
}

// SQL IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) LastSeenIn(lastSeenIn time.Time) ApiGetCamerasRequest {
	r.lastSeenIn = &lastSeenIn
	return r
}

// SQL NOT IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) LastSeenNotin(lastSeenNotin time.Time) ApiGetCamerasRequest {
	r.lastSeenNotin = &lastSeenNotin
	return r
}

// SQL @&gt; comparison
func (r ApiGetCamerasRequest) LastSeenContains(lastSeenContains time.Time) ApiGetCamerasRequest {
	r.lastSeenContains = &lastSeenContains
	return r
}

// SQL NOT @&gt; comparison
func (r ApiGetCamerasRequest) LastSeenNotcontains(lastSeenNotcontains time.Time) ApiGetCamerasRequest {
	r.lastSeenNotcontains = &lastSeenNotcontains
	return r
}

// SQL LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) LastSeenLike(lastSeenLike time.Time) ApiGetCamerasRequest {
	r.lastSeenLike = &lastSeenLike
	return r
}

// SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) LastSeenNotlike(lastSeenNotlike time.Time) ApiGetCamerasRequest {
	r.lastSeenNotlike = &lastSeenNotlike
	return r
}

// SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) LastSeenIlike(lastSeenIlike time.Time) ApiGetCamerasRequest {
	r.lastSeenIlike = &lastSeenIlike
	return r
}

// SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) LastSeenNotilike(lastSeenNotilike time.Time) ApiGetCamerasRequest {
	r.lastSeenNotilike = &lastSeenNotilike
	return r
}

// SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) LastSeenDesc(lastSeenDesc string) ApiGetCamerasRequest {
	r.lastSeenDesc = &lastSeenDesc
	return r
}

// SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) LastSeenAsc(lastSeenAsc string) ApiGetCamerasRequest {
	r.lastSeenAsc = &lastSeenAsc
	return r
}

// SQL &#x3D; comparison
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilEq(segmentProducerClaimedUntilEq time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilEq = &segmentProducerClaimedUntilEq
	return r
}

// SQL !&#x3D; comparison
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilNe(segmentProducerClaimedUntilNe time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilNe = &segmentProducerClaimedUntilNe
	return r
}

// SQL &gt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilGt(segmentProducerClaimedUntilGt time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilGt = &segmentProducerClaimedUntilGt
	return r
}

// SQL &gt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilGte(segmentProducerClaimedUntilGte time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilGte = &segmentProducerClaimedUntilGte
	return r
}

// SQL &lt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilLt(segmentProducerClaimedUntilLt time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilLt = &segmentProducerClaimedUntilLt
	return r
}

// SQL &lt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilLte(segmentProducerClaimedUntilLte time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilLte = &segmentProducerClaimedUntilLte
	return r
}

// SQL IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilIn(segmentProducerClaimedUntilIn time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilIn = &segmentProducerClaimedUntilIn
	return r
}

// SQL NOT IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilNotin(segmentProducerClaimedUntilNotin time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilNotin = &segmentProducerClaimedUntilNotin
	return r
}

// SQL @&gt; comparison
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilContains(segmentProducerClaimedUntilContains time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilContains = &segmentProducerClaimedUntilContains
	return r
}

// SQL NOT @&gt; comparison
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilNotcontains(segmentProducerClaimedUntilNotcontains time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilNotcontains = &segmentProducerClaimedUntilNotcontains
	return r
}

// SQL LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilLike(segmentProducerClaimedUntilLike time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilLike = &segmentProducerClaimedUntilLike
	return r
}

// SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilNotlike(segmentProducerClaimedUntilNotlike time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilNotlike = &segmentProducerClaimedUntilNotlike
	return r
}

// SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilIlike(segmentProducerClaimedUntilIlike time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilIlike = &segmentProducerClaimedUntilIlike
	return r
}

// SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilNotilike(segmentProducerClaimedUntilNotilike time.Time) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilNotilike = &segmentProducerClaimedUntilNotilike
	return r
}

// SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilDesc(segmentProducerClaimedUntilDesc string) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilDesc = &segmentProducerClaimedUntilDesc
	return r
}

// SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) SegmentProducerClaimedUntilAsc(segmentProducerClaimedUntilAsc string) ApiGetCamerasRequest {
	r.segmentProducerClaimedUntilAsc = &segmentProducerClaimedUntilAsc
	return r
}

// SQL &#x3D; comparison
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilEq(streamProducerClaimedUntilEq time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilEq = &streamProducerClaimedUntilEq
	return r
}

// SQL !&#x3D; comparison
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilNe(streamProducerClaimedUntilNe time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilNe = &streamProducerClaimedUntilNe
	return r
}

// SQL &gt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilGt(streamProducerClaimedUntilGt time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilGt = &streamProducerClaimedUntilGt
	return r
}

// SQL &gt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilGte(streamProducerClaimedUntilGte time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilGte = &streamProducerClaimedUntilGte
	return r
}

// SQL &lt; comparison, may not work with all column types
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilLt(streamProducerClaimedUntilLt time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilLt = &streamProducerClaimedUntilLt
	return r
}

// SQL &lt;&#x3D; comparison, may not work with all column types
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilLte(streamProducerClaimedUntilLte time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilLte = &streamProducerClaimedUntilLte
	return r
}

// SQL IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilIn(streamProducerClaimedUntilIn time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilIn = &streamProducerClaimedUntilIn
	return r
}

// SQL NOT IN comparison, permits comma-separated values
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilNotin(streamProducerClaimedUntilNotin time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilNotin = &streamProducerClaimedUntilNotin
	return r
}

// SQL @&gt; comparison
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilContains(streamProducerClaimedUntilContains time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilContains = &streamProducerClaimedUntilContains
	return r
}

// SQL NOT @&gt; comparison
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilNotcontains(streamProducerClaimedUntilNotcontains time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilNotcontains = &streamProducerClaimedUntilNotcontains
	return r
}

// SQL LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilLike(streamProducerClaimedUntilLike time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilLike = &streamProducerClaimedUntilLike
	return r
}

// SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilNotlike(streamProducerClaimedUntilNotlike time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilNotlike = &streamProducerClaimedUntilNotlike
	return r
}

// SQL ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilIlike(streamProducerClaimedUntilIlike time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilIlike = &streamProducerClaimedUntilIlike
	return r
}

// SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with %
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilNotilike(streamProducerClaimedUntilNotilike time.Time) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilNotilike = &streamProducerClaimedUntilNotilike
	return r
}

// SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilDesc(streamProducerClaimedUntilDesc string) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilDesc = &streamProducerClaimedUntilDesc
	return r
}

// SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) StreamProducerClaimedUntilAsc(streamProducerClaimedUntilAsc string) ApiGetCamerasRequest {
	r.streamProducerClaimedUntilAsc = &streamProducerClaimedUntilAsc
	return r
}

// SQL @&gt; comparison
func (r ApiGetCamerasRequest) ReferencedByDetectionCameraIdObjectsContains(referencedByDetectionCameraIdObjectsContains interface{}) ApiGetCamerasRequest {
	r.referencedByDetectionCameraIdObjectsContains = &referencedByDetectionCameraIdObjectsContains
	return r
}

// SQL NOT @&gt; comparison
func (r ApiGetCamerasRequest) ReferencedByDetectionCameraIdObjectsNotcontains(referencedByDetectionCameraIdObjectsNotcontains interface{}) ApiGetCamerasRequest {
	r.referencedByDetectionCameraIdObjectsNotcontains = &referencedByDetectionCameraIdObjectsNotcontains
	return r
}

// SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) ReferencedByDetectionCameraIdObjectsDesc(referencedByDetectionCameraIdObjectsDesc string) ApiGetCamerasRequest {
	r.referencedByDetectionCameraIdObjectsDesc = &referencedByDetectionCameraIdObjectsDesc
	return r
}

// SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) ReferencedByDetectionCameraIdObjectsAsc(referencedByDetectionCameraIdObjectsAsc string) ApiGetCamerasRequest {
	r.referencedByDetectionCameraIdObjectsAsc = &referencedByDetectionCameraIdObjectsAsc
	return r
}

// SQL @&gt; comparison
func (r ApiGetCamerasRequest) ReferencedByVideoCameraIdObjectsContains(referencedByVideoCameraIdObjectsContains interface{}) ApiGetCamerasRequest {
	r.referencedByVideoCameraIdObjectsContains = &referencedByVideoCameraIdObjectsContains
	return r
}

// SQL NOT @&gt; comparison
func (r ApiGetCamerasRequest) ReferencedByVideoCameraIdObjectsNotcontains(referencedByVideoCameraIdObjectsNotcontains interface{}) ApiGetCamerasRequest {
	r.referencedByVideoCameraIdObjectsNotcontains = &referencedByVideoCameraIdObjectsNotcontains
	return r
}

// SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) ReferencedByVideoCameraIdObjectsDesc(referencedByVideoCameraIdObjectsDesc string) ApiGetCamerasRequest {
	r.referencedByVideoCameraIdObjectsDesc = &referencedByVideoCameraIdObjectsDesc
	return r
}

// SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient)
func (r ApiGetCamerasRequest) ReferencedByVideoCameraIdObjectsAsc(referencedByVideoCameraIdObjectsAsc string) ApiGetCamerasRequest {
	r.referencedByVideoCameraIdObjectsAsc = &referencedByVideoCameraIdObjectsAsc
	return r
}

func (r ApiGetCamerasRequest) Execute() (*ResponseWithGenericOfCamera, *http.Response, error) {
	return r.ApiService.GetCamerasExecute(r)
}

/*
GetCameras Method for GetCameras

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCamerasRequest
*/
func (a *CameraAPIService) GetCameras(ctx context.Context) ApiGetCamerasRequest {
	return ApiGetCamerasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResponseWithGenericOfCamera
func (a *CameraAPIService) GetCamerasExecute(r ApiGetCamerasRequest) (*ResponseWithGenericOfCamera, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseWithGenericOfCamera
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CameraAPIService.GetCameras")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/cameras"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	}
	if r.referencedByDetectionLoad != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenced_by_detection__load", r.referencedByDetectionLoad, "")
	}
	if r.referencedByVideoLoad != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenced_by_video__load", r.referencedByVideoLoad, "")
	}
	if r.idEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__eq", r.idEq, "")
	}
	if r.idNe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__ne", r.idNe, "")
	}
	if r.idGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", r.idGt, "")
	}
	if r.idGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", r.idGte, "")
	}
	if r.idLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", r.idLt, "")
	}
	if r.idLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", r.idLte, "")
	}
	if r.idIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__in", r.idIn, "")
	}
	if r.idNotin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__notin", r.idNotin, "")
	}
	if r.idContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__contains", r.idContains, "")
	}
	if r.idNotcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__notcontains", r.idNotcontains, "")
	}
	if r.idLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__like", r.idLike, "")
	}
	if r.idNotlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__notlike", r.idNotlike, "")
	}
	if r.idIlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__ilike", r.idIlike, "")
	}
	if r.idNotilike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__notilike", r.idNotilike, "")
	}
	if r.idDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__desc", r.idDesc, "")
	}
	if r.idAsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__asc", r.idAsc, "")
	}
	if r.createdAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__eq", r.createdAtEq, "")
	}
	if r.createdAtNe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__ne", r.createdAtNe, "")
	}
	if r.createdAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__gt", r.createdAtGt, "")
	}
	if r.createdAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__gte", r.createdAtGte, "")
	}
	if r.createdAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__lt", r.createdAtLt, "")
	}
	if r.createdAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__lte", r.createdAtLte, "")
	}
	if r.createdAtIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__in", r.createdAtIn, "")
	}
	if r.createdAtNotin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__notin", r.createdAtNotin, "")
	}
	if r.createdAtContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__contains", r.createdAtContains, "")
	}
	if r.createdAtNotcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__notcontains", r.createdAtNotcontains, "")
	}
	if r.createdAtLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__like", r.createdAtLike, "")
	}
	if r.createdAtNotlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__notlike", r.createdAtNotlike, "")
	}
	if r.createdAtIlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__ilike", r.createdAtIlike, "")
	}
	if r.createdAtNotilike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__notilike", r.createdAtNotilike, "")
	}
	if r.createdAtDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__desc", r.createdAtDesc, "")
	}
	if r.createdAtAsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__asc", r.createdAtAsc, "")
	}
	if r.updatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__eq", r.updatedAtEq, "")
	}
	if r.updatedAtNe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__ne", r.updatedAtNe, "")
	}
	if r.updatedAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__gt", r.updatedAtGt, "")
	}
	if r.updatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__gte", r.updatedAtGte, "")
	}
	if r.updatedAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__lt", r.updatedAtLt, "")
	}
	if r.updatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__lte", r.updatedAtLte, "")
	}
	if r.updatedAtIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__in", r.updatedAtIn, "")
	}
	if r.updatedAtNotin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__notin", r.updatedAtNotin, "")
	}
	if r.updatedAtContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__contains", r.updatedAtContains, "")
	}
	if r.updatedAtNotcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__notcontains", r.updatedAtNotcontains, "")
	}
	if r.updatedAtLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__like", r.updatedAtLike, "")
	}
	if r.updatedAtNotlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__notlike", r.updatedAtNotlike, "")
	}
	if r.updatedAtIlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__ilike", r.updatedAtIlike, "")
	}
	if r.updatedAtNotilike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__notilike", r.updatedAtNotilike, "")
	}
	if r.updatedAtDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__desc", r.updatedAtDesc, "")
	}
	if r.updatedAtAsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at__asc", r.updatedAtAsc, "")
	}
	if r.deletedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__eq", r.deletedAtEq, "")
	}
	if r.deletedAtNe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__ne", r.deletedAtNe, "")
	}
	if r.deletedAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__gt", r.deletedAtGt, "")
	}
	if r.deletedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__gte", r.deletedAtGte, "")
	}
	if r.deletedAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__lt", r.deletedAtLt, "")
	}
	if r.deletedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__lte", r.deletedAtLte, "")
	}
	if r.deletedAtIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__in", r.deletedAtIn, "")
	}
	if r.deletedAtNotin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__notin", r.deletedAtNotin, "")
	}
	if r.deletedAtContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__contains", r.deletedAtContains, "")
	}
	if r.deletedAtNotcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__notcontains", r.deletedAtNotcontains, "")
	}
	if r.deletedAtLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__like", r.deletedAtLike, "")
	}
	if r.deletedAtNotlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__notlike", r.deletedAtNotlike, "")
	}
	if r.deletedAtIlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__ilike", r.deletedAtIlike, "")
	}
	if r.deletedAtNotilike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__notilike", r.deletedAtNotilike, "")
	}
	if r.deletedAtDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__desc", r.deletedAtDesc, "")
	}
	if r.deletedAtAsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_at__asc", r.deletedAtAsc, "")
	}
	if r.nameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__eq", r.nameEq, "")
	}
	if r.nameNe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__ne", r.nameNe, "")
	}
	if r.nameGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__gt", r.nameGt, "")
	}
	if r.nameGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__gte", r.nameGte, "")
	}
	if r.nameLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__lt", r.nameLt, "")
	}
	if r.nameLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__lte", r.nameLte, "")
	}
	if r.nameIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__in", r.nameIn, "")
	}
	if r.nameNotin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__notin", r.nameNotin, "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__contains", r.nameContains, "")
	}
	if r.nameNotcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__notcontains", r.nameNotcontains, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__like", r.nameLike, "")
	}
	if r.nameNotlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__notlike", r.nameNotlike, "")
	}
	if r.nameIlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__ilike", r.nameIlike, "")
	}
	if r.nameNotilike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__notilike", r.nameNotilike, "")
	}
	if r.nameDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__desc", r.nameDesc, "")
	}
	if r.nameAsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__asc", r.nameAsc, "")
	}
	if r.streamUrlEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__eq", r.streamUrlEq, "")
	}
	if r.streamUrlNe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__ne", r.streamUrlNe, "")
	}
	if r.streamUrlGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__gt", r.streamUrlGt, "")
	}
	if r.streamUrlGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__gte", r.streamUrlGte, "")
	}
	if r.streamUrlLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__lt", r.streamUrlLt, "")
	}
	if r.streamUrlLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__lte", r.streamUrlLte, "")
	}
	if r.streamUrlIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__in", r.streamUrlIn, "")
	}
	if r.streamUrlNotin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__notin", r.streamUrlNotin, "")
	}
	if r.streamUrlContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__contains", r.streamUrlContains, "")
	}
	if r.streamUrlNotcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__notcontains", r.streamUrlNotcontains, "")
	}
	if r.streamUrlLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__like", r.streamUrlLike, "")
	}
	if r.streamUrlNotlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__notlike", r.streamUrlNotlike, "")
	}
	if r.streamUrlIlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__ilike", r.streamUrlIlike, "")
	}
	if r.streamUrlNotilike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__notilike", r.streamUrlNotilike, "")
	}
	if r.streamUrlDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__desc", r.streamUrlDesc, "")
	}
	if r.streamUrlAsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_url__asc", r.streamUrlAsc, "")
	}
	if r.lastSeenEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__eq", r.lastSeenEq, "")
	}
	if r.lastSeenNe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__ne", r.lastSeenNe, "")
	}
	if r.lastSeenGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__gt", r.lastSeenGt, "")
	}
	if r.lastSeenGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__gte", r.lastSeenGte, "")
	}
	if r.lastSeenLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__lt", r.lastSeenLt, "")
	}
	if r.lastSeenLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__lte", r.lastSeenLte, "")
	}
	if r.lastSeenIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__in", r.lastSeenIn, "")
	}
	if r.lastSeenNotin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__notin", r.lastSeenNotin, "")
	}
	if r.lastSeenContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__contains", r.lastSeenContains, "")
	}
	if r.lastSeenNotcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__notcontains", r.lastSeenNotcontains, "")
	}
	if r.lastSeenLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__like", r.lastSeenLike, "")
	}
	if r.lastSeenNotlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__notlike", r.lastSeenNotlike, "")
	}
	if r.lastSeenIlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__ilike", r.lastSeenIlike, "")
	}
	if r.lastSeenNotilike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__notilike", r.lastSeenNotilike, "")
	}
	if r.lastSeenDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__desc", r.lastSeenDesc, "")
	}
	if r.lastSeenAsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_seen__asc", r.lastSeenAsc, "")
	}
	if r.segmentProducerClaimedUntilEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__eq", r.segmentProducerClaimedUntilEq, "")
	}
	if r.segmentProducerClaimedUntilNe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__ne", r.segmentProducerClaimedUntilNe, "")
	}
	if r.segmentProducerClaimedUntilGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__gt", r.segmentProducerClaimedUntilGt, "")
	}
	if r.segmentProducerClaimedUntilGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__gte", r.segmentProducerClaimedUntilGte, "")
	}
	if r.segmentProducerClaimedUntilLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__lt", r.segmentProducerClaimedUntilLt, "")
	}
	if r.segmentProducerClaimedUntilLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__lte", r.segmentProducerClaimedUntilLte, "")
	}
	if r.segmentProducerClaimedUntilIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__in", r.segmentProducerClaimedUntilIn, "")
	}
	if r.segmentProducerClaimedUntilNotin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__notin", r.segmentProducerClaimedUntilNotin, "")
	}
	if r.segmentProducerClaimedUntilContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__contains", r.segmentProducerClaimedUntilContains, "")
	}
	if r.segmentProducerClaimedUntilNotcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__notcontains", r.segmentProducerClaimedUntilNotcontains, "")
	}
	if r.segmentProducerClaimedUntilLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__like", r.segmentProducerClaimedUntilLike, "")
	}
	if r.segmentProducerClaimedUntilNotlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__notlike", r.segmentProducerClaimedUntilNotlike, "")
	}
	if r.segmentProducerClaimedUntilIlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__ilike", r.segmentProducerClaimedUntilIlike, "")
	}
	if r.segmentProducerClaimedUntilNotilike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__notilike", r.segmentProducerClaimedUntilNotilike, "")
	}
	if r.segmentProducerClaimedUntilDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__desc", r.segmentProducerClaimedUntilDesc, "")
	}
	if r.segmentProducerClaimedUntilAsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segment_producer_claimed_until__asc", r.segmentProducerClaimedUntilAsc, "")
	}
	if r.streamProducerClaimedUntilEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__eq", r.streamProducerClaimedUntilEq, "")
	}
	if r.streamProducerClaimedUntilNe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__ne", r.streamProducerClaimedUntilNe, "")
	}
	if r.streamProducerClaimedUntilGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__gt", r.streamProducerClaimedUntilGt, "")
	}
	if r.streamProducerClaimedUntilGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__gte", r.streamProducerClaimedUntilGte, "")
	}
	if r.streamProducerClaimedUntilLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__lt", r.streamProducerClaimedUntilLt, "")
	}
	if r.streamProducerClaimedUntilLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__lte", r.streamProducerClaimedUntilLte, "")
	}
	if r.streamProducerClaimedUntilIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__in", r.streamProducerClaimedUntilIn, "")
	}
	if r.streamProducerClaimedUntilNotin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__notin", r.streamProducerClaimedUntilNotin, "")
	}
	if r.streamProducerClaimedUntilContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__contains", r.streamProducerClaimedUntilContains, "")
	}
	if r.streamProducerClaimedUntilNotcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__notcontains", r.streamProducerClaimedUntilNotcontains, "")
	}
	if r.streamProducerClaimedUntilLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__like", r.streamProducerClaimedUntilLike, "")
	}
	if r.streamProducerClaimedUntilNotlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__notlike", r.streamProducerClaimedUntilNotlike, "")
	}
	if r.streamProducerClaimedUntilIlike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__ilike", r.streamProducerClaimedUntilIlike, "")
	}
	if r.streamProducerClaimedUntilNotilike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__notilike", r.streamProducerClaimedUntilNotilike, "")
	}
	if r.streamProducerClaimedUntilDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__desc", r.streamProducerClaimedUntilDesc, "")
	}
	if r.streamProducerClaimedUntilAsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_producer_claimed_until__asc", r.streamProducerClaimedUntilAsc, "")
	}
	if r.referencedByDetectionCameraIdObjectsContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenced_by_detection_camera_id_objects__contains", r.referencedByDetectionCameraIdObjectsContains, "")
	}
	if r.referencedByDetectionCameraIdObjectsNotcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenced_by_detection_camera_id_objects__notcontains", r.referencedByDetectionCameraIdObjectsNotcontains, "")
	}
	if r.referencedByDetectionCameraIdObjectsDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenced_by_detection_camera_id_objects__desc", r.referencedByDetectionCameraIdObjectsDesc, "")
	}
	if r.referencedByDetectionCameraIdObjectsAsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenced_by_detection_camera_id_objects__asc", r.referencedByDetectionCameraIdObjectsAsc, "")
	}
	if r.referencedByVideoCameraIdObjectsContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenced_by_video_camera_id_objects__contains", r.referencedByVideoCameraIdObjectsContains, "")
	}
	if r.referencedByVideoCameraIdObjectsNotcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenced_by_video_camera_id_objects__notcontains", r.referencedByVideoCameraIdObjectsNotcontains, "")
	}
	if r.referencedByVideoCameraIdObjectsDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenced_by_video_camera_id_objects__desc", r.referencedByVideoCameraIdObjectsDesc, "")
	}
	if r.referencedByVideoCameraIdObjectsAsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenced_by_video_camera_id_objects__asc", r.referencedByVideoCameraIdObjectsAsc, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetCamerasDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCameraRequest struct {
	ctx context.Context
	ApiService *CameraAPIService
	primaryKey string
	camera *Camera
	depth *int64
}

func (r ApiPatchCameraRequest) Camera(camera Camera) ApiPatchCameraRequest {
	r.camera = &camera
	return r
}

// Query parameter depth
func (r ApiPatchCameraRequest) Depth(depth int64) ApiPatchCameraRequest {
	r.depth = &depth
	return r
}

func (r ApiPatchCameraRequest) Execute() (*ResponseWithGenericOfCamera, *http.Response, error) {
	return r.ApiService.PatchCameraExecute(r)
}

/*
PatchCamera Method for PatchCamera

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param primaryKey Path parameter primaryKey
 @return ApiPatchCameraRequest
*/
func (a *CameraAPIService) PatchCamera(ctx context.Context, primaryKey string) ApiPatchCameraRequest {
	return ApiPatchCameraRequest{
		ApiService: a,
		ctx: ctx,
		primaryKey: primaryKey,
	}
}

// Execute executes the request
//  @return ResponseWithGenericOfCamera
func (a *CameraAPIService) PatchCameraExecute(r ApiPatchCameraRequest) (*ResponseWithGenericOfCamera, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseWithGenericOfCamera
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CameraAPIService.PatchCamera")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/cameras/{primaryKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"primaryKey"+"}", url.PathEscape(parameterValueToString(r.primaryKey, "primaryKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.camera == nil {
		return localVarReturnValue, nil, reportError("camera is required and must be specified")
	}

	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.camera
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetCamerasDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCamerasRequest struct {
	ctx context.Context
	ApiService *CameraAPIService
	camera *[]Camera
	depth *int64
}

func (r ApiPostCamerasRequest) Camera(camera []Camera) ApiPostCamerasRequest {
	r.camera = &camera
	return r
}

// Query parameter depth
func (r ApiPostCamerasRequest) Depth(depth int64) ApiPostCamerasRequest {
	r.depth = &depth
	return r
}

func (r ApiPostCamerasRequest) Execute() (*ResponseWithGenericOfCamera, *http.Response, error) {
	return r.ApiService.PostCamerasExecute(r)
}

/*
PostCameras Method for PostCameras

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCamerasRequest
*/
func (a *CameraAPIService) PostCameras(ctx context.Context) ApiPostCamerasRequest {
	return ApiPostCamerasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResponseWithGenericOfCamera
func (a *CameraAPIService) PostCamerasExecute(r ApiPostCamerasRequest) (*ResponseWithGenericOfCamera, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseWithGenericOfCamera
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CameraAPIService.PostCameras")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/cameras"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.camera == nil {
		return localVarReturnValue, nil, reportError("camera is required and must be specified")
	}

	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.camera
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetCamerasDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCamerasSegmentProducerClaimRequest struct {
	ctx context.Context
	ApiService *CameraAPIService
	primaryKey string
	cameraSegmentProducerClaimRequest *CameraSegmentProducerClaimRequest
	depth *int64
}

func (r ApiPostCamerasSegmentProducerClaimRequest) CameraSegmentProducerClaimRequest(cameraSegmentProducerClaimRequest CameraSegmentProducerClaimRequest) ApiPostCamerasSegmentProducerClaimRequest {
	r.cameraSegmentProducerClaimRequest = &cameraSegmentProducerClaimRequest
	return r
}

// Query parameter depth
func (r ApiPostCamerasSegmentProducerClaimRequest) Depth(depth int64) ApiPostCamerasSegmentProducerClaimRequest {
	r.depth = &depth
	return r
}

func (r ApiPostCamerasSegmentProducerClaimRequest) Execute() (*ResponseWithGenericOfCamera, *http.Response, error) {
	return r.ApiService.PostCamerasSegmentProducerClaimExecute(r)
}

/*
PostCamerasSegmentProducerClaim Method for PostCamerasSegmentProducerClaim

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param primaryKey Path parameter primaryKey
 @return ApiPostCamerasSegmentProducerClaimRequest
*/
func (a *CameraAPIService) PostCamerasSegmentProducerClaim(ctx context.Context, primaryKey string) ApiPostCamerasSegmentProducerClaimRequest {
	return ApiPostCamerasSegmentProducerClaimRequest{
		ApiService: a,
		ctx: ctx,
		primaryKey: primaryKey,
	}
}

// Execute executes the request
//  @return ResponseWithGenericOfCamera
func (a *CameraAPIService) PostCamerasSegmentProducerClaimExecute(r ApiPostCamerasSegmentProducerClaimRequest) (*ResponseWithGenericOfCamera, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseWithGenericOfCamera
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CameraAPIService.PostCamerasSegmentProducerClaim")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/cameras/{primaryKey}/segment-producer-claim"
	localVarPath = strings.Replace(localVarPath, "{"+"primaryKey"+"}", url.PathEscape(parameterValueToString(r.primaryKey, "primaryKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cameraSegmentProducerClaimRequest == nil {
		return localVarReturnValue, nil, reportError("cameraSegmentProducerClaimRequest is required and must be specified")
	}

	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cameraSegmentProducerClaimRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetCamerasDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCamerasStreamProducerClaimRequest struct {
	ctx context.Context
	ApiService *CameraAPIService
	primaryKey string
	cameraStreamProducerClaimRequest *CameraStreamProducerClaimRequest
	depth *int64
}

func (r ApiPostCamerasStreamProducerClaimRequest) CameraStreamProducerClaimRequest(cameraStreamProducerClaimRequest CameraStreamProducerClaimRequest) ApiPostCamerasStreamProducerClaimRequest {
	r.cameraStreamProducerClaimRequest = &cameraStreamProducerClaimRequest
	return r
}

// Query parameter depth
func (r ApiPostCamerasStreamProducerClaimRequest) Depth(depth int64) ApiPostCamerasStreamProducerClaimRequest {
	r.depth = &depth
	return r
}

func (r ApiPostCamerasStreamProducerClaimRequest) Execute() (*ResponseWithGenericOfCamera, *http.Response, error) {
	return r.ApiService.PostCamerasStreamProducerClaimExecute(r)
}

/*
PostCamerasStreamProducerClaim Method for PostCamerasStreamProducerClaim

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param primaryKey Path parameter primaryKey
 @return ApiPostCamerasStreamProducerClaimRequest
*/
func (a *CameraAPIService) PostCamerasStreamProducerClaim(ctx context.Context, primaryKey string) ApiPostCamerasStreamProducerClaimRequest {
	return ApiPostCamerasStreamProducerClaimRequest{
		ApiService: a,
		ctx: ctx,
		primaryKey: primaryKey,
	}
}

// Execute executes the request
//  @return ResponseWithGenericOfCamera
func (a *CameraAPIService) PostCamerasStreamProducerClaimExecute(r ApiPostCamerasStreamProducerClaimRequest) (*ResponseWithGenericOfCamera, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseWithGenericOfCamera
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CameraAPIService.PostCamerasStreamProducerClaim")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/cameras/{primaryKey}/stream-producer-claim"
	localVarPath = strings.Replace(localVarPath, "{"+"primaryKey"+"}", url.PathEscape(parameterValueToString(r.primaryKey, "primaryKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cameraStreamProducerClaimRequest == nil {
		return localVarReturnValue, nil, reportError("cameraStreamProducerClaimRequest is required and must be specified")
	}

	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cameraStreamProducerClaimRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetCamerasDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
