/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/cameras": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetCameras"];
    put?: never;
    post: operations["PostCameras"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/cameras/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetCamera"];
    put: operations["PutCamera"];
    post?: never;
    delete: operations["DeleteCamera"];
    options?: never;
    head?: never;
    patch: operations["PatchCamera"];
    trace?: never;
  };
  "/api/custom/claim-video-for-object-detector": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch: operations["PatchClaimVideoForObjectDetector"];
    trace?: never;
  };
  "/api/detections": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetDetections"];
    put?: never;
    post: operations["PostDetections"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/detections/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetDetection"];
    put: operations["PutDetection"];
    post?: never;
    delete: operations["DeleteDetection"];
    options?: never;
    head?: never;
    patch: operations["PatchDetection"];
    trace?: never;
  };
  "/api/videos": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetVideos"];
    put?: never;
    post: operations["PostVideos"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/videos/{primaryKey}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["GetVideo"];
    put: operations["PutVideo"];
    post?: never;
    delete: operations["DeleteVideo"];
    options?: never;
    head?: never;
    patch: operations["PatchVideo"];
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    Camera: {
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string | null;
      /** Format: uuid */
      id?: string;
      /** Format: date-time */
      last_seen?: string;
      name?: string;
      referenced_by_detection_camera_id_objects?: components["schemas"]["NullableArrayOfDetection"];
      referenced_by_video_camera_id_objects?: components["schemas"]["NullableArrayOfVideo"];
      /** Format: date-time */
      segment_producer_claimed_until?: string;
      /** Format: date-time */
      stream_producer_claimed_until?: string;
      stream_url?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    ClaimRequest: {
      claim_duration_seconds: components["schemas"]["Float64"];
    };
    Detection: {
      bounding_box?:
        | {
            /** Format: double */
            X?: number;
            /** Format: double */
            Y?: number;
          }[]
        | null;
      /** Format: uuid */
      camera_id?: string;
      camera_id_object?: components["schemas"]["NullableCamera"];
      centroid?: {
        /** Format: double */
        X?: number;
        /** Format: double */
        Y?: number;
      };
      /** Format: int64 */
      class_id?: number;
      class_name?: string;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string | null;
      /** Format: uuid */
      id?: string;
      /** Format: double */
      score?: number;
      /** Format: date-time */
      seen_at?: string;
      /** Format: date-time */
      updated_at?: string;
      /** Format: uuid */
      video_id?: string;
      video_id_object?: components["schemas"]["NullableVideo"];
    };
    /** Format: double */
    Float64: number;
    NullableArrayOfCamera: components["schemas"]["Camera"][] | null;
    NullableArrayOfDetection: components["schemas"]["Detection"][] | null;
    NullableArrayOfVideo: components["schemas"]["Video"][] | null;
    NullableCamera: components["schemas"]["Camera"];
    NullableDetection: components["schemas"]["Detection"];
    NullableVideo: components["schemas"]["Video"];
    Vec2: {
      /** Format: double */
      X?: number;
      /** Format: double */
      Y?: number;
    };
    Video: {
      /** Format: uuid */
      camera_id?: string;
      camera_id_object?: components["schemas"]["NullableCamera"];
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      deleted_at?: string | null;
      detection_summary?: unknown;
      /** Format: int64 */
      duration?: number | null;
      /** Format: date-time */
      ended_at?: string | null;
      file_name?: string;
      /** Format: double */
      file_size?: number | null;
      /** Format: uuid */
      id?: string;
      /** Format: date-time */
      object_detector_claimed_until?: string;
      /** Format: date-time */
      object_tracker_claimed_until?: string;
      referenced_by_detection_video_id_objects?: components["schemas"]["NullableArrayOfDetection"];
      /** Format: date-time */
      started_at?: string;
      status?: string;
      thumbnail_name?: string;
      /** Format: date-time */
      updated_at?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  GetCameras: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        id__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        id__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        id__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        id__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        created_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        created_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        created_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        created_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        updated_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        updated_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        updated_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        updated_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        deleted_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        deleted_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        deleted_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        deleted_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        name__eq?: string;
        /** @description SQL != comparison */
        name__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        name__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        name__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        name__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        name__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        name__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        name__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        name__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        name__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        name__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        name__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        name__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        name__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        name__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        name__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        name__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        name__asc?: string;
        /** @description SQL = comparison */
        stream_url__eq?: string;
        /** @description SQL != comparison */
        stream_url__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        stream_url__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        stream_url__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        stream_url__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        stream_url__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        stream_url__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        stream_url__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        stream_url__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        stream_url__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        stream_url__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        stream_url__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        stream_url__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        stream_url__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        stream_url__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        stream_url__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        stream_url__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        stream_url__asc?: string;
        /** @description SQL = comparison */
        last_seen__eq?: string;
        /** @description SQL != comparison */
        last_seen__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        last_seen__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        last_seen__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        last_seen__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        last_seen__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        last_seen__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        last_seen__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        last_seen__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        last_seen__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        last_seen__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        last_seen__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        last_seen__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        last_seen__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        last_seen__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        last_seen__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        last_seen__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        last_seen__asc?: string;
        /** @description SQL = comparison */
        segment_producer_claimed_until__eq?: string;
        /** @description SQL != comparison */
        segment_producer_claimed_until__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        segment_producer_claimed_until__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        segment_producer_claimed_until__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        segment_producer_claimed_until__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        segment_producer_claimed_until__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        segment_producer_claimed_until__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        segment_producer_claimed_until__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        segment_producer_claimed_until__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        segment_producer_claimed_until__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        segment_producer_claimed_until__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        segment_producer_claimed_until__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        segment_producer_claimed_until__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        segment_producer_claimed_until__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        segment_producer_claimed_until__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        segment_producer_claimed_until__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        segment_producer_claimed_until__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        segment_producer_claimed_until__asc?: string;
        /** @description SQL = comparison */
        stream_producer_claimed_until__eq?: string;
        /** @description SQL != comparison */
        stream_producer_claimed_until__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        stream_producer_claimed_until__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        stream_producer_claimed_until__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        stream_producer_claimed_until__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        stream_producer_claimed_until__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        stream_producer_claimed_until__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        stream_producer_claimed_until__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        stream_producer_claimed_until__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        stream_producer_claimed_until__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        stream_producer_claimed_until__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        stream_producer_claimed_until__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        stream_producer_claimed_until__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        stream_producer_claimed_until__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        stream_producer_claimed_until__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        stream_producer_claimed_until__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        stream_producer_claimed_until__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        stream_producer_claimed_until__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful List Fetch for Cameras */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Camera"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed List Fetch for Cameras */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostCameras: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Camera"][];
      };
    };
    responses: {
      /** @description Successful List Create for Cameras */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Camera"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed List Create for Cameras */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetCamera: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Camera */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Item Fetch for Cameras */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Camera"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed Item Fetch for Cameras */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PutCamera: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Camera */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Camera"];
      };
    };
    responses: {
      /** @description Successful Item Replace for Cameras */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Camera"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed Item Replace for Cameras */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteCamera: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Camera */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Item Delete for Cameras */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Failed Item Delete for Cameras */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PatchCamera: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Camera */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Camera"];
      };
    };
    responses: {
      /** @description Successful Item Update for Cameras */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Camera"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed Item Update for Cameras */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PatchClaimVideoForObjectDetector: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ClaimRequest"];
      };
    };
    responses: {
      /** @description PatchClaimVideoForObjectDetector success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Video"];
        };
      };
      /** @description PatchClaimVideoForObjectDetector failure */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetDetections: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        id__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        id__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        id__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        id__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        created_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        created_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        created_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        created_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        updated_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        updated_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        updated_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        updated_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        deleted_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        deleted_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        deleted_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        deleted_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        seen_at__eq?: string;
        /** @description SQL != comparison */
        seen_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        seen_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        seen_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        seen_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        seen_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        seen_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        seen_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        seen_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        seen_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        seen_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        seen_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        seen_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        seen_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        seen_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        seen_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        seen_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        seen_at__asc?: string;
        /** @description SQL = comparison */
        class_id__eq?: number;
        /** @description SQL != comparison */
        class_id__ne?: number;
        /** @description SQL > comparison, may not work with all column types */
        class_id__gt?: number;
        /** @description SQL >= comparison, may not work with all column types */
        class_id__gte?: number;
        /** @description SQL < comparison, may not work with all column types */
        class_id__lt?: number;
        /** @description SQL <= comparison, may not work with all column types */
        class_id__lte?: number;
        /** @description SQL IN comparison, permits comma-separated values */
        class_id__in?: number;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        class_id__notin?: number;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        class_id__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        class_id__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        class_id__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        class_id__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        class_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        class_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        class_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        class_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        class_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        class_id__asc?: string;
        /** @description SQL = comparison */
        class_name__eq?: string;
        /** @description SQL != comparison */
        class_name__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        class_name__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        class_name__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        class_name__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        class_name__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        class_name__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        class_name__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        class_name__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        class_name__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        class_name__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        class_name__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        class_name__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        class_name__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        class_name__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        class_name__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        class_name__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        class_name__asc?: string;
        /** @description SQL = comparison */
        score__eq?: number;
        /** @description SQL != comparison */
        score__ne?: number;
        /** @description SQL > comparison, may not work with all column types */
        score__gt?: number;
        /** @description SQL >= comparison, may not work with all column types */
        score__gte?: number;
        /** @description SQL < comparison, may not work with all column types */
        score__lt?: number;
        /** @description SQL <= comparison, may not work with all column types */
        score__lte?: number;
        /** @description SQL IN comparison, permits comma-separated values */
        score__in?: number;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        score__notin?: number;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        score__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        score__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        score__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        score__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        score__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        score__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        score__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        score__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        score__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        score__asc?: string;
        /** @description SQL = comparison */
        video_id__eq?: string;
        /** @description SQL != comparison */
        video_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        video_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        video_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        video_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        video_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        video_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        video_id__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        video_id__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        video_id__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        video_id__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        video_id__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        video_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        video_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        video_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        video_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        video_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        video_id__asc?: string;
        /** @description SQL = comparison */
        camera_id__eq?: string;
        /** @description SQL != comparison */
        camera_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        camera_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        camera_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        camera_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        camera_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        camera_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        camera_id__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        camera_id__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        camera_id__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        camera_id__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        camera_id__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        camera_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        camera_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        camera_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        camera_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        camera_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        camera_id__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful List Fetch for Detections */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Detection"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed List Fetch for Detections */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostDetections: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Detection"][];
      };
    };
    responses: {
      /** @description Successful List Create for Detections */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Detection"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed List Create for Detections */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetDetection: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Detection */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Item Fetch for Detections */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Detection"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed Item Fetch for Detections */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PutDetection: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Detection */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Detection"];
      };
    };
    responses: {
      /** @description Successful Item Replace for Detections */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Detection"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed Item Replace for Detections */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteDetection: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Detection */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Item Delete for Detections */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Failed Item Delete for Detections */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PatchDetection: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Detection */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Detection"];
      };
    };
    responses: {
      /** @description Successful Item Update for Detections */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Detection"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed Item Update for Detections */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetVideos: {
    parameters: {
      query?: {
        /** @description SQL LIMIT operator */
        limit?: number;
        /** @description SQL OFFSET operator */
        offset?: number;
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
        /** @description SQL = comparison */
        id__eq?: string;
        /** @description SQL != comparison */
        id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        id__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        id__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        id__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        id__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        id__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        id__asc?: string;
        /** @description SQL = comparison */
        created_at__eq?: string;
        /** @description SQL != comparison */
        created_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        created_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        created_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        created_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        created_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        created_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        created_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        created_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        created_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        created_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        created_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        created_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        created_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        created_at__asc?: string;
        /** @description SQL = comparison */
        updated_at__eq?: string;
        /** @description SQL != comparison */
        updated_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        updated_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        updated_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        updated_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        updated_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        updated_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        updated_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        updated_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        updated_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        updated_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        updated_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        updated_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        updated_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        updated_at__asc?: string;
        /** @description SQL = comparison */
        deleted_at__eq?: string;
        /** @description SQL != comparison */
        deleted_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        deleted_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        deleted_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        deleted_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        deleted_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        deleted_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        deleted_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        deleted_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        deleted_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        deleted_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        deleted_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        deleted_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        deleted_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        deleted_at__asc?: string;
        /** @description SQL = comparison */
        file_name__eq?: string;
        /** @description SQL != comparison */
        file_name__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        file_name__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        file_name__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        file_name__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        file_name__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        file_name__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        file_name__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        file_name__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        file_name__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        file_name__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        file_name__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        file_name__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        file_name__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        file_name__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        file_name__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        file_name__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        file_name__asc?: string;
        /** @description SQL = comparison */
        started_at__eq?: string;
        /** @description SQL != comparison */
        started_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        started_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        started_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        started_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        started_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        started_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        started_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        started_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        started_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        started_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        started_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        started_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        started_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        started_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        started_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        started_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        started_at__asc?: string;
        /** @description SQL = comparison */
        ended_at__eq?: string;
        /** @description SQL != comparison */
        ended_at__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        ended_at__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        ended_at__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        ended_at__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        ended_at__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        ended_at__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        ended_at__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        ended_at__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        ended_at__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        ended_at__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        ended_at__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        ended_at__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        ended_at__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        ended_at__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        ended_at__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        ended_at__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        ended_at__asc?: string;
        /** @description SQL = comparison */
        duration__eq?: number;
        /** @description SQL != comparison */
        duration__ne?: number;
        /** @description SQL > comparison, may not work with all column types */
        duration__gt?: number;
        /** @description SQL >= comparison, may not work with all column types */
        duration__gte?: number;
        /** @description SQL < comparison, may not work with all column types */
        duration__lt?: number;
        /** @description SQL <= comparison, may not work with all column types */
        duration__lte?: number;
        /** @description SQL IN comparison, permits comma-separated values */
        duration__in?: number;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        duration__notin?: number;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        duration__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        duration__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        duration__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        duration__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        duration__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        duration__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        duration__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        duration__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        duration__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        duration__asc?: string;
        /** @description SQL = comparison */
        file_size__eq?: number;
        /** @description SQL != comparison */
        file_size__ne?: number;
        /** @description SQL > comparison, may not work with all column types */
        file_size__gt?: number;
        /** @description SQL >= comparison, may not work with all column types */
        file_size__gte?: number;
        /** @description SQL < comparison, may not work with all column types */
        file_size__lt?: number;
        /** @description SQL <= comparison, may not work with all column types */
        file_size__lte?: number;
        /** @description SQL IN comparison, permits comma-separated values */
        file_size__in?: number;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        file_size__notin?: number;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        file_size__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        file_size__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        file_size__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        file_size__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        file_size__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        file_size__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        file_size__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        file_size__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        file_size__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        file_size__asc?: string;
        /** @description SQL = comparison */
        thumbnail_name__eq?: string;
        /** @description SQL != comparison */
        thumbnail_name__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        thumbnail_name__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        thumbnail_name__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        thumbnail_name__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        thumbnail_name__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        thumbnail_name__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        thumbnail_name__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        thumbnail_name__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        thumbnail_name__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        thumbnail_name__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        thumbnail_name__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        thumbnail_name__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        thumbnail_name__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        thumbnail_name__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        thumbnail_name__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        thumbnail_name__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        thumbnail_name__asc?: string;
        /** @description SQL = comparison */
        status__eq?: string;
        /** @description SQL != comparison */
        status__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        status__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        status__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        status__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        status__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        status__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        status__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        status__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        status__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        status__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        status__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        status__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        status__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        status__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        status__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        status__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        status__asc?: string;
        /** @description SQL = comparison */
        object_detector_claimed_until__eq?: string;
        /** @description SQL != comparison */
        object_detector_claimed_until__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        object_detector_claimed_until__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        object_detector_claimed_until__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        object_detector_claimed_until__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        object_detector_claimed_until__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        object_detector_claimed_until__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        object_detector_claimed_until__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        object_detector_claimed_until__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        object_detector_claimed_until__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        object_detector_claimed_until__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        object_detector_claimed_until__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        object_detector_claimed_until__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        object_detector_claimed_until__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        object_detector_claimed_until__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        object_detector_claimed_until__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        object_detector_claimed_until__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        object_detector_claimed_until__asc?: string;
        /** @description SQL = comparison */
        object_tracker_claimed_until__eq?: string;
        /** @description SQL != comparison */
        object_tracker_claimed_until__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        object_tracker_claimed_until__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        object_tracker_claimed_until__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        object_tracker_claimed_until__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        object_tracker_claimed_until__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        object_tracker_claimed_until__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        object_tracker_claimed_until__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        object_tracker_claimed_until__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        object_tracker_claimed_until__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        object_tracker_claimed_until__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        object_tracker_claimed_until__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        object_tracker_claimed_until__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        object_tracker_claimed_until__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        object_tracker_claimed_until__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        object_tracker_claimed_until__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        object_tracker_claimed_until__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        object_tracker_claimed_until__asc?: string;
        /** @description SQL = comparison */
        camera_id__eq?: string;
        /** @description SQL != comparison */
        camera_id__ne?: string;
        /** @description SQL > comparison, may not work with all column types */
        camera_id__gt?: string;
        /** @description SQL >= comparison, may not work with all column types */
        camera_id__gte?: string;
        /** @description SQL < comparison, may not work with all column types */
        camera_id__lt?: string;
        /** @description SQL <= comparison, may not work with all column types */
        camera_id__lte?: string;
        /** @description SQL IN comparison, permits comma-separated values */
        camera_id__in?: string;
        /** @description SQL NOT IN comparison, permits comma-separated values */
        camera_id__notin?: string;
        /** @description SQL IS null comparison, value is ignored (presence of key is sufficient) */
        camera_id__isnull?: string;
        /** @description SQL IS NOT null comparison, value is ignored (presence of key is sufficient) */
        camera_id__isnotnull?: string;
        /** @description SQL IS false comparison, value is ignored (presence of key is sufficient) */
        camera_id__isfalse?: string;
        /** @description SQL IS true comparison, value is ignored (presence of key is sufficient) */
        camera_id__istrue?: string;
        /** @description SQL LIKE comparison, value is implicitly prefixed and suffixed with % */
        camera_id__like?: string;
        /** @description SQL NOT LIKE comparison, value is implicitly prefixed and suffixed with % */
        camera_id__notlike?: string;
        /** @description SQL ILIKE comparison, value is implicitly prefixed and suffixed with % */
        camera_id__ilike?: string;
        /** @description SQL NOT ILIKE comparison, value is implicitly prefixed and suffixed with % */
        camera_id__notilike?: string;
        /** @description SQL ORDER BY _ DESC clause, value is ignored (presence of key is sufficient) */
        camera_id__desc?: string;
        /** @description SQL ORDER BY _ ASC clause, value is ignored (presence of key is sufficient) */
        camera_id__asc?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful List Fetch for Videos */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Video"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed List Fetch for Videos */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PostVideos: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Video"][];
      };
    };
    responses: {
      /** @description Successful List Create for Videos */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Video"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed List Create for Videos */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  GetVideo: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Video */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Item Fetch for Videos */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Video"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed Item Fetch for Videos */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PutVideo: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Video */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Video"];
      };
    };
    responses: {
      /** @description Successful Item Replace for Videos */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Video"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed Item Replace for Videos */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  DeleteVideo: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Video */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Item Delete for Videos */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Failed Item Delete for Videos */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
  PatchVideo: {
    parameters: {
      query?: {
        /** @description Max recursion depth for loading foreign objects; default = 1
         *
         *     (0 = recurse until graph cycle detected, 1 = this object only, 2 = this object + neighbours, 3 = this object + neighbours + their neighbours... etc) */
        depth?: number;
      };
      header?: never;
      path: {
        /** @description Primary key for Video */
        primaryKey: unknown;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Video"];
      };
    };
    responses: {
      /** @description Successful Item Update for Videos */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Format: int64 */
            count?: number;
            error?: string[];
            /** Format: int64 */
            limit?: number;
            objects?: components["schemas"]["Video"][];
            /** Format: int64 */
            offset?: number;
            /** Format: int32 */
            status: number;
            success: boolean;
            /** Format: int64 */
            total_count?: number;
          };
        };
      };
      /** @description Failed Item Update for Videos */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string[];
            /** Format: int32 */
            status: number;
            success: boolean;
          };
        };
      };
    };
  };
}
